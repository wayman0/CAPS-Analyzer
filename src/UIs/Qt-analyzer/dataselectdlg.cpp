/***************************************************************************
 *   dataselectdlg.cpp                                                      *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   suson@calumet.purdue.edu                                              *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * This class defines the map select dialog structure associated with      *
 * the Qt4 user interface.                                                 *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#include <algorithm>

#include "dataselectdlg.h"
#include "../libanalyzer/atypes.h"
#include "../libanalyzer/matrixdata.h"
#include "ui_dataselectdlg.h"

dataSelectDialog::dataSelectDialog(association *assoc, RWMode m) :
                 ui(new Ui::dataSelectDialog) {
  /* set up the user interface first */
  ui->setupUi(this);

  dataMgr = assoc;
  
  /* initialize internal variables*/
  dataType = fileType::Null;
  dataSets = new std::vector<FILETYPE>;
  dirty = false;
  mode = m;
  

  //if(mode == Write)
  //{
    // enable all data sets
    ui->inputDataCB->setEnabled(false);
    ui->pixelDataCB->setEnabled(false);
    ui->transDataCB->setEnabled(false);
    ui->dataAlmCB->setEnabled(false);
    ui->invDataCB->setEnabled(false);
    ui->inputWeightCB->setEnabled(false);
    ui->pixelWeightsCB->setEnabled(false);
    ui->transWeightCB->setEnabled(false);
    ui->weightAlmCB->setEnabled(false);
    ui->invWeightsCB->setEnabled(false);
    ui->inputNoiseCB->setEnabled(false);
    ui->pixelNoiseCB->setEnabled(false);
    ui->transNoiseCB->setEnabled(false);
    ui->noiseAlmCB->setEnabled(false);
    ui->invNoiseCB->setEnabled(false);
    ui->inputFilterCB->setEnabled(false);
    ui->pixelFilterCB->setEnabled(false);
    ui->transFilterCB->setEnabled(false);
    ui->filterAlmCB->setEnabled(false);
    ui->invFilterCB->setEnabled(false);
    ui->inputBeamCB->setEnabled(false);
    ui->pixelBeamCB->setEnabled(false);
    ui->transBeamCB->setEnabled(false);
    ui->beamAlmCB->setEnabled(false);
    ui->invBeamCB->setEnabled(false);
    ui->binCB->setEnabled(false);
    ui->invBinCB->setEnabled(false);
    ui->modeCB->setEnabled(false);
    ui->invModeCB->setEnabled(false);
    ui->comboSpectrumCB->setEnabled(false);
    ui->ensembleCB->setEnabled(false);
  //}

  /* set up signals and slots */
  connect(ui->buttonBox, &QDialogButtonBox::accepted, this, &dataSelectDialog::finalize);
  connect(ui->buttonBox, &QDialogButtonBox::rejected, this, &dataSelectDialog::cancel);
  connect(ui->buttonBox, &QDialogButtonBox::helpRequested, this, &dataSelectDialog::help);
}

dataSelectDialog::~dataSelectDialog() {
  delete dataSets;
  delete ui;
}

void dataSelectDialog::validate() {
  dirty = false; // assume nothing has changed
  
  std::vector<FILETYPE> oldDataSets(*dataSets);
  if (ui->inputDataCB->isEnabled())
  {
    if (ui->inputDataCB->isChecked() == true)
      dataSets->push_back(fileType::InputData);
    else
    {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::InputData;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->pixelDataCB->isEnabled())
  {
    if (ui->pixelDataCB->isChecked() == true)
      dataSets->push_back(fileType::PixelizedData);
    else
    {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::PixelizedData;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->transDataCB->isEnabled())
  {
    if (ui->transDataCB->isChecked() == true)
      dataSets->push_back(fileType::TransformedData);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::TransformedData;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->dataAlmCB->isEnabled())
  {
    if (ui->dataAlmCB->isChecked() == true)
      dataSets->push_back(fileType::AlmData);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::AlmData;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->invDataCB->isEnabled())
  {
    if (ui->invDataCB->isChecked() == true)
      dataSets->push_back(fileType::InverseData);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::InverseData;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->inputWeightCB->isEnabled())
  {
    if (ui->inputWeightCB->isChecked() == true)
      dataSets->push_back(fileType::InputWeights);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::InputWeights;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->pixelWeightsCB->isEnabled())
  {
    if (ui->pixelWeightsCB->isChecked() == true)
      dataSets->push_back(fileType::PixelizedWeights);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::PixelizedWeights;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->transWeightCB->isEnabled())
  {
    if (ui->transWeightCB->isChecked() == true)
      dataSets->push_back(fileType::TransformedWeights);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::TransformedWeights;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->weightAlmCB->isEnabled())
  {
    if (ui->weightAlmCB->isChecked() == true)
      dataSets->push_back(fileType::AlmWeights);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::AlmWeights;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->invWeightsCB->isEnabled())
  {
    if (ui->invWeightsCB->isChecked() == true)
      dataSets->push_back(fileType::InverseWeights);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::InverseWeights;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->inputNoiseCB->isEnabled())
  {
    if (ui->inputNoiseCB->isChecked() == true)
      dataSets->push_back(fileType::InputNoise);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::InputNoise;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->pixelNoiseCB->isEnabled())
  {
    if (ui->pixelNoiseCB->isChecked() == true)
      dataSets->push_back(fileType::PixelizedNoise);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::PixelizedNoise;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->transNoiseCB->isEnabled())
  {
    if (ui->transNoiseCB->isChecked() == true)
      dataSets->push_back(fileType::TransformedNoise);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::TransformedNoise;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->noiseAlmCB->isEnabled())
  {
    if (ui->noiseAlmCB->isChecked() == true)
      dataSets->push_back(fileType::AlmNoise);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::AlmNoise;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->invNoiseCB->isEnabled())
  {
    if (ui->invNoiseCB->isChecked() == true)
      dataSets->push_back(fileType::InverseNoise);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::InverseNoise;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->inputFilterCB->isEnabled())
  {
    if (ui->inputFilterCB->isChecked() == true)
      dataSets->push_back(fileType::InputFilter);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::InputFilter;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->pixelFilterCB->isEnabled())
  {
    if (ui->pixelFilterCB->isChecked() == true)
      dataSets->push_back(fileType::PixelizedFilter);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::PixelizedFilter;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->transFilterCB->isEnabled())
  {
    if (ui->transFilterCB->isChecked() == true)
      dataSets->push_back(fileType::TransformedFilter);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::TransformedFilter;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->filterAlmCB->isEnabled())
  {
    if (ui->filterAlmCB->isChecked() == true)
      dataSets->push_back(fileType::AlmFilter);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::AlmFilter;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->invFilterCB->isEnabled())
  {
    if (ui->invFilterCB->isChecked() == true)
      dataSets->push_back(fileType::InverseFilter);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::InverseFilter;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->inputBeamCB->isEnabled())
  {
    if (ui->inputBeamCB->isChecked() == true)
      dataSets->push_back(fileType::InputBeam);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::InputBeam;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->pixelBeamCB->isEnabled())
  {
    if (ui->pixelBeamCB->isChecked() == true)
      dataSets->push_back(fileType::PixelizedBeam);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::PixelizedBeam;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->transBeamCB->isEnabled())
  {
    if (ui->transBeamCB->isChecked() == true)
      dataSets->push_back(fileType::TransformedBeam);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::TransformedBeam;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->beamAlmCB->isEnabled())
  {
    if (ui->beamAlmCB->isChecked() == true)
      dataSets->push_back(fileType::AlmBeam);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::AlmBeam;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->invBeamCB->isEnabled())
  {
    if (ui->invBeamCB->isChecked() == true)
      dataSets->push_back(fileType::InverseBeam);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::InverseBeam;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->binCB->isEnabled())
  {
    if (ui->binCB->isChecked() == true)
      dataSets->push_back(fileType::BinCouplingMatrix);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::BinCouplingMatrix;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->invBinCB->isEnabled())
  {
    if (ui->invBinCB->isChecked() == true)
      dataSets->push_back(fileType::InverseBinMatrix);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::InverseBinMatrix;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->modeCB->isEnabled())
  {
    if (ui->modeCB->isChecked() == true)
      dataSets->push_back(fileType::ModeCouplingMatrix);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::ModeCouplingMatrix;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->invModeCB->isEnabled())
  {
    if (ui->invModeCB->isChecked() == true)
      dataSets->push_back(fileType::InverseModeMatrix);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::InverseModeMatrix;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->comboSpectrumCB->isEnabled())
  {
    if (ui->comboSpectrumCB->isChecked() == true)
      dataSets->push_back(fileType::SpectralData);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::SpectralData;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (ui->ensembleCB->isEnabled())
  {
    if (ui->ensembleCB->isChecked() == true)
      dataSets->push_back(fileType::EnsembleData);
    else {
      auto ftIterator = std::find_if(dataSets->begin(), dataSets->end(), [](fileType ft){return ft == fileType::EnsembleData;});
      if (ftIterator != dataSets->end())
        dataSets->erase(ftIterator);
    }
  }

  if (*dataSets != oldDataSets)
    dirty = true;
  
  return;
}

void dataSelectDialog::configure(RWMode uiMode) {
  dirty = false;
  mode = uiMode;

  if (mode == RWMode::Read)
  {
    ui->title->setText("Please select the data sets to read");

    for(int i = 0; i < dataSets->size(); i += 1)
    {
      switch((*dataSets)[i])
      {
        case fileType::InputData:
          ui->inputDataCB->setEnabled(true);
          break;
        case fileType::InputWeights:
          ui->inputWeightCB->setEnabled(true);
          break;
        case fileType::InputBeam:
          ui->inputBeamCB->setEnabled(true);
          break;
        case fileType::InputFilter:
          ui->inputFilterCB->setEnabled(true);
          break;
        case fileType::InputNoise:
          ui->inputNoiseCB->setEnabled(true);
          break;
        case fileType::PixelizedData:
          ui->pixelDataCB->setEnabled(true);
          break;
        case fileType::PixelizedWeights:
          ui->pixelWeightsCB->setEnabled(true);
          break;
        case fileType::PixelizedBeam:
          ui->pixelBeamCB->setEnabled(true);
          break;
        case fileType::PixelizedFilter:
          ui->pixelFilterCB->setEnabled(true);
          break;
        case fileType::PixelizedNoise:
          ui->pixelNoiseCB->setEnabled(true);
          break;
        case fileType::TransformedData:
          ui->transDataCB->setEnabled(true);
          break;
        case fileType::TransformedWeights:
          ui->transWeightCB->setEnabled(true);
          break;
        case fileType::TransformedBeam:
          ui->transBeamCB->setEnabled(true);
          break;
        case fileType::TransformedFilter:
          ui->transFilterCB->setEnabled(true);
          break;
        case fileType::TransformedNoise:
          ui->transNoiseCB->setEnabled(true);
          break;
        case fileType::AlmData:
          ui->dataAlmCB->setEnabled(true);
          break;
        case fileType::AlmWeights:
          ui->weightAlmCB->setEnabled(true);
          break;
        case fileType::AlmBeam:
          ui->beamAlmCB->setEnabled(true);
          break;
        case fileType::AlmFilter:
          ui->filterAlmCB->setEnabled(true);
          break;
        case fileType::AlmNoise:
          ui->noiseAlmCB->setEnabled(true);
          break;
        case fileType::InverseData:
          ui->invDataCB->setEnabled(true);
          break;
        case fileType::InverseWeights:
          ui->invWeightsCB->setEnabled(true);
          break;
        case fileType::InverseBeam:
          ui->invBeamCB->setEnabled(true);
          break;
        case fileType::InverseFilter:
          ui->invFilterCB->setEnabled(true);
          break;
        case fileType::InverseNoise:
          ui->invNoiseCB->setEnabled(true);
          break;
        case fileType::BinCouplingMatrix:
          ui->binCB->setEnabled(true);
          ui->invBinCB->setEnabled(true);
          break;
        case fileType::ModeCouplingMatrix:
          ui->modeCB->setEnabled(true);
          ui->invModeCB->setEnabled(true);
          break;
        case fileType::SpectralData:
          ui->comboSpectrumCB->setEnabled(true);
          break;
        case fileType::EnsembleData:
          ui->ensembleCB->setEnabled(true);
          break;
        default:
          break;
      }
    }
  }
  else
  {
    ui->title->setText("Please select the data sets to save");

    if (dataMgr->inputData() == 0)
      ui->inputDataCB->setEnabled(false);
    else
      ui->inputDataCB->setEnabled(true);

    if (dataMgr->pixelizedData() == 0)
      ui->pixelDataCB->setEnabled(false);
    else
      ui->pixelDataCB->setEnabled(true);

    if (dataMgr->transformedData() == 0)
      ui->transDataCB->setEnabled(false);
    else
      ui->transDataCB->setEnabled(true);

    if (dataMgr->almData() == 0)
      ui->dataAlmCB->setEnabled(false);
    else
      ui->dataAlmCB->setEnabled(true);

    if (dataMgr->inverseData() == 0)
      ui->invDataCB->setEnabled(false);
    else
      ui->invDataCB->setEnabled(true);

    if (dataMgr->inputWeights() == 0)
      ui->inputWeightCB->setEnabled(false);
    else
      ui->inputWeightCB->setEnabled(true);

    if (dataMgr->pixelizedWeights() == 0)
      ui->pixelWeightsCB->setEnabled(false);
    else
      ui->pixelWeightsCB->setEnabled(true);

    if (dataMgr->transformedWeights() == 0)
      ui->transWeightCB->setEnabled(false);
    else
      ui->transWeightCB->setEnabled(true);

    if (dataMgr->almWeights() == 0)
      ui->weightAlmCB->setEnabled(false);
    else
      ui->weightAlmCB->setEnabled(true);

    if (dataMgr->inverseWeights() == 0)
      ui->invWeightsCB->setEnabled(false);
    else
      ui->invWeightsCB->setEnabled(true);

    if (dataMgr->inputNoise() == 0)
      ui->inputNoiseCB->setEnabled(false);
    else
      ui->inputNoiseCB->setEnabled(true);

    if (dataMgr->pixelizedNoise() == 0)
      ui->pixelNoiseCB->setEnabled(false);
    else
      ui->pixelNoiseCB->setEnabled(true);

    if (dataMgr->transformedNoise() == 0)
      ui->transNoiseCB->setEnabled(false);
    else
      ui->transNoiseCB->setEnabled(true);

    if (dataMgr->almNoise() == 0)
      ui->noiseAlmCB->setEnabled(false);
    else
      ui->noiseAlmCB->setEnabled(true);

    if (dataMgr->inverseNoise() == 0)
      ui->invNoiseCB->setEnabled(false);
    else
      ui->invNoiseCB->setEnabled(true);

    if (dataMgr->inputFilter() == 0)
      ui->inputFilterCB->setEnabled(false);
    else
      ui->inputFilterCB->setEnabled(true);

    if (dataMgr->pixelizedFilter() == 0)
      ui->pixelFilterCB->setEnabled(false);
    else
      ui->pixelFilterCB->setEnabled(true);

    if (dataMgr->transformedFilter() == 0)
      ui->transFilterCB->setEnabled(false);
    else
      ui->transFilterCB->setEnabled(true);

    if (dataMgr->almFilter() == 0)
      ui->filterAlmCB->setEnabled(false);
    else
      ui->filterAlmCB->setEnabled(true);

    if (dataMgr->inverseFilter() == 0)
      ui->invFilterCB->setEnabled(false);
    else
      ui->invFilterCB->setEnabled(true);

    if (dataMgr->inputBeam() == 0)
      ui->inputBeamCB->setEnabled(false);
    else
      ui->inputBeamCB->setEnabled(true);

    if (dataMgr->pixelizedBeam() == 0)
      ui->pixelBeamCB->setEnabled(false);
    else
      ui->pixelBeamCB->setEnabled(true);

    if (dataMgr->transformedBeam() == 0)
      ui->transBeamCB->setEnabled(false);
    else
      ui->transBeamCB->setEnabled(true);

    if (dataMgr->almBeam() == 0)
      ui->beamAlmCB->setEnabled(false);
    else
      ui->beamAlmCB->setEnabled(true);

    if (dataMgr->inverseBeam() == 0)
      ui->invBeamCB->setEnabled(false);
    else
      ui->invBeamCB->setEnabled(true);

    if (dataMgr->couplingMatrix() == 0)
    {
      ui->binCB->setEnabled(false);
      ui->modeCB->setEnabled(false);
    }
    else
    {
      ui->binCB->setEnabled(false);
      ui->modeCB->setEnabled(false);

      if (dataMgr->couplingMatrix()->format() == formats::Bin)
        ui->binCB->setEnabled(true);
      else
        ui->modeCB->setEnabled(true);
    }

    if (dataMgr->inverseMatrix() == 0)
    {
      ui->invBinCB->setEnabled(false);
      ui->invModeCB->setEnabled(false);
    }
    else
    {
      ui->invBinCB->setEnabled(false);
      ui->invModeCB->setEnabled(false);

      if (dataMgr->inverseMatrix()->format() == formats::Bin)
        ui->invBinCB->setEnabled(true);
      else
        ui->invModeCB->setEnabled(true);
    }

    if (dataMgr->spectrumData() == 0)
      ui->comboSpectrumCB->setEnabled(false);
    else
      ui->comboSpectrumCB->setEnabled(true);

    if (dataMgr->ensembleData() == 0)
      ui->ensembleCB->setEnabled(false);
    else
      ui->ensembleCB->setEnabled(true);
  }

  exec();
}

void dataSelectDialog::configure(FILETYPE* dataTypes, int* numTypes)
{
   dirty = false;

  if (mode == RWMode::Read)
  {
    ui->title->setText("Please select the data sets to read");

    for(int i = 0; i < *numTypes; i += 1)
    {
      switch(dataTypes[i])
      {
        case fileType::InputData:
          ui->inputDataCB->setEnabled(true);
          break;
        case fileType::InputWeights:
          ui->inputWeightCB->setEnabled(true);
          break;
        case fileType::InputBeam:
          ui->inputBeamCB->setEnabled(true);
          break;
        case fileType::InputFilter:
          ui->inputFilterCB->setEnabled(true);
          break;
        case fileType::InputNoise:
          ui->inputNoiseCB->setEnabled(true);
          break;
        case fileType::PixelizedData:
          ui->pixelDataCB->setEnabled(true);
          break;
        case fileType::PixelizedWeights:
          ui->pixelWeightsCB->setEnabled(true);
          break;
        case fileType::PixelizedBeam:
          ui->pixelBeamCB->setEnabled(true);
          break;
        case fileType::PixelizedFilter:
          ui->pixelFilterCB->setEnabled(true);
          break;
        case fileType::PixelizedNoise:
          ui->pixelNoiseCB->setEnabled(true);
          break;
        case fileType::TransformedData:
          ui->transDataCB->setEnabled(true);
          break;
        case fileType::TransformedWeights:
          ui->transWeightCB->setEnabled(true);
          break;
        case fileType::TransformedBeam:
          ui->transBeamCB->setEnabled(true);
          break;
        case fileType::TransformedFilter:
          ui->transFilterCB->setEnabled(true);
          break;
        case fileType::TransformedNoise:
          ui->transNoiseCB->setEnabled(true);
          break;
        case fileType::AlmData:
          ui->dataAlmCB->setEnabled(true);
          break;
        case fileType::AlmWeights:
          ui->weightAlmCB->setEnabled(true);
          break;
        case fileType::AlmBeam:
          ui->beamAlmCB->setEnabled(true);
          break;
        case fileType::AlmFilter:
          ui->filterAlmCB->setEnabled(true);
          break;
        case fileType::AlmNoise:
          ui->noiseAlmCB->setEnabled(true);
          break;
        case fileType::InverseData:
          ui->invDataCB->setEnabled(true);
          break;
        case fileType::InverseWeights:
          ui->invWeightsCB->setEnabled(true);
          break;
        case fileType::InverseBeam:
          ui->invBeamCB->setEnabled(true);
          break;
        case fileType::InverseFilter:
          ui->invFilterCB->setEnabled(true);
          break;
        case fileType::InverseNoise:
          ui->invNoiseCB->setEnabled(true);
          break;
        case fileType::BinCouplingMatrix:
          ui->binCB->setEnabled(true);
          ui->invBinCB->setEnabled(true);
          break;
        case fileType::ModeCouplingMatrix:
          ui->modeCB->setEnabled(true);
          ui->invModeCB->setEnabled(true);
          break;
        case fileType::SpectralData:
          ui->comboSpectrumCB->setEnabled(true);
          break;
        case fileType::EnsembleData:
          ui->ensembleCB->setEnabled(true);
          break;
        default:
          break;
      }
    }
  }
  else
  {
    ui->title->setText("Please select the data sets to save");

    if (dataMgr->inputData() == 0)
      ui->inputDataCB->setEnabled(false);
    else
      ui->inputDataCB->setEnabled(true);

    if (dataMgr->pixelizedData() == 0)
      ui->pixelDataCB->setEnabled(false);
    else
      ui->pixelDataCB->setEnabled(true);

    if (dataMgr->transformedData() == 0)
      ui->transDataCB->setEnabled(false);
    else
      ui->transDataCB->setEnabled(true);

    if (dataMgr->almData() == 0)
      ui->dataAlmCB->setEnabled(false);
    else
      ui->dataAlmCB->setEnabled(true);

    if (dataMgr->inverseData() == 0)
      ui->invDataCB->setEnabled(false);
    else
      ui->invDataCB->setEnabled(true);

    if (dataMgr->inputWeights() == 0)
      ui->inputWeightCB->setEnabled(false);
    else
      ui->inputWeightCB->setEnabled(true);

    if (dataMgr->pixelizedWeights() == 0)
      ui->pixelWeightsCB->setEnabled(false);
    else
      ui->pixelWeightsCB->setEnabled(true);

    if (dataMgr->transformedWeights() == 0)
      ui->transWeightCB->setEnabled(false);
    else
      ui->transWeightCB->setEnabled(true);

    if (dataMgr->almWeights() == 0)
      ui->weightAlmCB->setEnabled(false);
    else
      ui->weightAlmCB->setEnabled(true);

    if (dataMgr->inverseWeights() == 0)
      ui->invWeightsCB->setEnabled(false);
    else
      ui->invWeightsCB->setEnabled(true);

    if (dataMgr->inputNoise() == 0)
      ui->inputNoiseCB->setEnabled(false);
    else
      ui->inputNoiseCB->setEnabled(true);

    if (dataMgr->pixelizedNoise() == 0)
      ui->pixelNoiseCB->setEnabled(false);
    else
      ui->pixelNoiseCB->setEnabled(true);

    if (dataMgr->transformedNoise() == 0)
      ui->transNoiseCB->setEnabled(false);
    else
      ui->transNoiseCB->setEnabled(true);

    if (dataMgr->almNoise() == 0)
      ui->noiseAlmCB->setEnabled(false);
    else
      ui->noiseAlmCB->setEnabled(true);

    if (dataMgr->inverseNoise() == 0)
      ui->invNoiseCB->setEnabled(false);
    else
      ui->invNoiseCB->setEnabled(true);

    if (dataMgr->inputFilter() == 0)
      ui->inputFilterCB->setEnabled(false);
    else
      ui->inputFilterCB->setEnabled(true);

    if (dataMgr->pixelizedFilter() == 0)
      ui->pixelFilterCB->setEnabled(false);
    else
      ui->pixelFilterCB->setEnabled(true);

    if (dataMgr->transformedFilter() == 0)
      ui->transFilterCB->setEnabled(false);
    else
      ui->transFilterCB->setEnabled(true);

    if (dataMgr->almFilter() == 0)
      ui->filterAlmCB->setEnabled(false);
    else
      ui->filterAlmCB->setEnabled(true);

    if (dataMgr->inverseFilter() == 0)
      ui->invFilterCB->setEnabled(false);
    else
      ui->invFilterCB->setEnabled(true);

    if (dataMgr->inputBeam() == 0)
      ui->inputBeamCB->setEnabled(false);
    else
      ui->inputBeamCB->setEnabled(true);

    if (dataMgr->pixelizedBeam() == 0)
      ui->pixelBeamCB->setEnabled(false);
    else
      ui->pixelBeamCB->setEnabled(true);

    if (dataMgr->transformedBeam() == 0)
      ui->transBeamCB->setEnabled(false);
    else
      ui->transBeamCB->setEnabled(true);

    if (dataMgr->almBeam() == 0)
      ui->beamAlmCB->setEnabled(false);
    else
      ui->beamAlmCB->setEnabled(true);

    if (dataMgr->inverseBeam() == 0)
      ui->invBeamCB->setEnabled(false);
    else
      ui->invBeamCB->setEnabled(true);

    if (dataMgr->couplingMatrix() == 0)
    {
      ui->binCB->setEnabled(false);
      ui->modeCB->setEnabled(false);
    }
    else
    {
      ui->binCB->setEnabled(false);
      ui->modeCB->setEnabled(false);

      if (dataMgr->couplingMatrix()->format() == formats::Bin)
        ui->binCB->setEnabled(true);
      else
        ui->modeCB->setEnabled(true);
    }

    if (dataMgr->inverseMatrix() == 0)
    {
      ui->invBinCB->setEnabled(false);
      ui->invModeCB->setEnabled(false);
    }
    else
    {
      ui->invBinCB->setEnabled(false);
      ui->invModeCB->setEnabled(false);

      if (dataMgr->inverseMatrix()->format() == formats::Bin)
        ui->invBinCB->setEnabled(true);
      else
        ui->invModeCB->setEnabled(true);
    }

    if (dataMgr->spectrumData() == 0)
      ui->comboSpectrumCB->setEnabled(false);
    else
      ui->comboSpectrumCB->setEnabled(true);

    if (dataMgr->ensembleData() == 0)
      ui->ensembleCB->setEnabled(false);
    else
      ui->ensembleCB->setEnabled(true);
  }

  exec();
}

void dataSelectDialog::setData(FILETYPE* dataTypes, int numTypes)
{
  for(int i = 0; i < numTypes; i += 1)
  {
    dataSets->push_back(dataTypes[i]);
    /*
    switch(dataTypes[i])
    {
      case fileType::InputData:
        ui->inputDataCB->setEnabled(true);
        break;
      case fileType::InputWeights:
        ui->inputWeightCB->setEnabled(true);
        break;
      case fileType::InputBeam:
        ui->inputBeamCB->setEnabled(true);
        break;
      case fileType::InputFilter:
        ui->inputFilterCB->setEnabled(true);
        break;
      case fileType::InputNoise:
        ui->inputNoiseCB->setEnabled(true);
        break;
      case fileType::PixelizedData:
        ui->pixelDataCB->setEnabled(true);
        break;
      case fileType::PixelizedWeights:
        ui->pixelWeightsCB->setEnabled(true);
        break;
      case fileType::PixelizedBeam:
        ui->pixelBeamCB->setEnabled(true);
        break;
      case fileType::PixelizedFilter:
        ui->pixelFilterCB->setEnabled(true);
        break;
      case fileType::PixelizedNoise:
        ui->pixelNoiseCB->setEnabled(true);
        break;
      case fileType::TransformedData:
        ui->transDataCB->setEnabled(true);
        break;
      case fileType::TransformedWeights:
        ui->transWeightCB->setEnabled(true);
        break;
      case fileType::TransformedBeam:
        ui->transBeamCB->setEnabled(true);
        break;
      case fileType::TransformedFilter:
        ui->transFilterCB->setEnabled(true);
        break;
      case fileType::TransformedNoise:
        ui->transNoiseCB->setEnabled(true);
        break;
      case fileType::AlmData:
        ui->dataAlmCB->setEnabled(true);
        break;
      case fileType::AlmWeights:
        ui->weightAlmCB->setEnabled(true);
        break;
      case fileType::AlmBeam:
        ui->beamAlmCB->setEnabled(true);
        break;
      case fileType::AlmFilter:
        ui->filterAlmCB->setEnabled(true);
        break;
      case fileType::AlmNoise:
        ui->noiseAlmCB->setEnabled(true);
        break;
      case fileType::InverseData:
        ui->invDataCB->setEnabled(true);
        break;
      case fileType::InverseWeights:
        ui->invWeightsCB->setEnabled(true);
        break;
      case fileType::InverseBeam:
        ui->invBeamCB->setEnabled(true);
        break;
      case fileType::InverseFilter:
        ui->invFilterCB->setEnabled(true);
        break;
      case fileType::InverseNoise:
        ui->invNoiseCB->setEnabled(true);
        break;

      case fileType::BinCouplingMatrix:
        ui->inputDataCB->setEnabled(true);
        break;
      case fileType::ModeCouplingMatrix:
        ui->inputDataCB->setEnabled(true);
        break;

      case fileType::SpectralData:
        ui->comboSpectrumCB->setEnabled(true);
        break;
      case fileType::EnsembleData:
        ui->ensembleCB->setEnabled(true);
        break;
      default:
        break;
    }
    */
  }
}


void dataSelectDialog::reset() {
  dataSets->clear();
  ui->title->setText("Please select the data sets to load");
  ui->inputDataCB->setEnabled(true);
  ui->pixelDataCB->setEnabled(true);
  ui->transDataCB->setEnabled(true);
  ui->dataAlmCB->setEnabled(true);
  ui->invDataCB->setEnabled(true);
  ui->inputWeightCB->setEnabled(true);
  ui->pixelWeightsCB->setEnabled(true);
  ui->transWeightCB->setEnabled(true);
  ui->weightAlmCB->setEnabled(true);
  ui->invWeightsCB->setEnabled(true);
  ui->inputNoiseCB->setEnabled(true);
  ui->pixelNoiseCB->setEnabled(true);
  ui->transNoiseCB->setEnabled(true);
  ui->noiseAlmCB->setEnabled(true);
  ui->invNoiseCB->setEnabled(true);
  ui->inputFilterCB->setEnabled(true);
  ui->pixelFilterCB->setEnabled(true);
  ui->transFilterCB->setEnabled(true);
  ui->filterAlmCB->setEnabled(true);
  ui->invFilterCB->setEnabled(true);
  ui->inputBeamCB->setEnabled(true);
  ui->pixelBeamCB->setEnabled(true);
  ui->transBeamCB->setEnabled(true);
  ui->beamAlmCB->setEnabled(true);
  ui->invBeamCB->setEnabled(true);
  ui->binCB->setEnabled(true);
  ui->invBinCB->setEnabled(true);
  ui->modeCB->setEnabled(true);
  ui->invModeCB->setEnabled(true);
  ui->comboSpectrumCB->setEnabled(true);
  ui->ensembleCB->setEnabled(true);
  dirty = false;
}

void dataSelectDialog::finalize() {

  validate();
  Q_EMIT dataSelected(dataSets);
  accept();
}

void dataSelectDialog::cancel() {
  if (dirty)
    dirty = false;
  close();
}

void dataSelectDialog::help() {

}
