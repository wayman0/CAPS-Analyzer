/****************************************************************************
                              \spectrum.h
Description:\brief (put short description here)

Begin    : Fri Jul 1 2005
Copyright: (C) 2005 by Daniel Suson
email    : daniel.suson@tamuk.edu

-----------------------------------------------------------------------------
                                Change Log
Date       Name                Description

-----------------------------------------------------------------------------

This program was developed at Texas A&M University-Kingsville by Daniel Suson.
It is free software; you may redistribute and/or modify it under the terms
of the GNU General License as published by the Free Software Foundation;
either version 2 of the License. or (at your option) any later version.

This software evolved from work that was done by Eric Hivon at the
California Institute of Technology on the MASTER algorithm (Hivon, E.,
et al., ApJ, vol 567, p 2).  It adapts or interfaces with these packages:

HealPix         (http://www.eso.org/science/healpix/)
FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)

Any publications or presentations that use results generated by this program
must reference the fact that it was developed at Texas A&M
University-Kingsville by Daniel Suson
***************************************************************************/
#ifndef _SPECTRUM_H_
#define _SPECTRUM_H_

#include <gsl/gsl_matrix.h>
#include <gsl/gsl_vector.h>
#include <healpix_cxx/powspec.h>
#include "matrixdata.h"
#include "vectordata.h"
#include "association.h"

class Spectrum {
  public:
    Spectrum();
    Spectrum(Spectrum* from);
    ~Spectrum();

  public:
    /**
     * flag for determining if spectrum is configured
     */
    bool configured() {return m_configured;}
    void configured(bool flag) {m_configured = flag;}

    /**
     * flag for determining if spectrum is active
     */
    bool active() {return m_active;}
    void active(bool flag) {m_active = flag;}

    /**
     * flag for determining if spectrum stops at inverting coupling matrix or not
     */
    bool computeInverse() {return m_invert;}
    void computeInverse(bool flag) {m_invert = flag;}

    /**
     * access whether data is to be binned or not
     */
    bool binning() {return m_binning;}
    void binning(bool flag) {m_binning = flag;}

    /**
     * access number of indices per bin
     */
    int indices() {return m_indices;}
    void indices(int value) {m_indices = value;}

    /**
     * access index mask
     */
    int maskIndex() {return m_maskIndex;}
    void maskIndex(int value) {m_maskIndex = value;}

    int ensembleIterations() {return m_ensIter;}
    void ensembleIterations(int iter) {m_ensIter = iter;}

    /**
     * access invert flag
     */
    bool invert() {return m_invert;}
    void invert(bool flag) {m_invert = flag;}

    /**
     * access whether data is to be weighted or not
     */
    bool weight() {return m_weight;}
    void weight(bool flag) {m_weight = flag;}

    /**
     * power spectrum minimum and maximum index values
     */
    int minIndex() {return m_minIndex;}
    void minIndex(int value) {m_minIndex = value;}

    int maxIndex() {return m_maxIndex;}
    void maxIndex(int value) {m_maxIndex = value;}

    int calculateNumberBins()
    {
      if(m_maxIndex % m_lPerBin == 0)
        return m_maxIndex / m_lPerBin;

      return 0;
    }

    int numLPerBin() {return m_lPerBin;}
    void numLPerBin(int val) {m_lPerBin = val;}

    int numBins() {return m_numBins;}
    void numBins(int val) {m_numBins = val;}

    /**
     * power spectrum minimum and maximum bin indices
     */
    int minBin() {return m_minBin;}
    void minBin(int value) {m_minBin = value;}

    int maxBin() {return m_maxBin;}
    void maxBin(int value) {m_maxBin = value;}

    /**
     * bin to index and index to bin lowest l value
     */
    int lowBinL() {return m_lowBinL;}
    void lowBinL(int value) {m_lowBinL = value;}

    /**
     * initialize the arrays
     */
    void initialize();


    /**
     * copy our matrixData to a gsl_matrix
    */
    void loadIntoGslMatrix(association *asc, FILETYPE ft);
    /**
     * copy a gsl_matrix to our matrixData
    */
    void loadIntoMatrixData(association* asc, FILETYPE ft);

    // invert a matrix
    void invertMatrix(association* asc, FILETYPE ft);

    void createModeModeMatrix(association *asc);
    void calculateBinningMatrix(association* asc);
    void calculateUnbinningMatrix(association* asc);
    void calculateInstrumentEffectsMatrix(association* asc);
    void calculateBinnedInstrumentEffectsMatrix(association* asc);
    void calculateEnsembleAverage(association *asc, FILETYPE ft);
    void calculateBinnedSpectrum(association* asc);

    void clear();

  private:
    /**
     * math routines for calculating the wigner 3-j coefficients until gsl routines are fixed
     */
    double gammln(double xx);
    double factln(int n);
    double coupling_3j(int l1,int l2,int l3);

  private:
    bool          m_configured;
    bool          m_active;
    bool          m_binning;
    bool          m_weight;
    bool          m_invert;
    int           m_maskIndex;
    int           m_indices;
    int           m_ensIter;
    int           m_minIndex;
    int           m_maxIndex;
    int           m_lPerBin;
    int           m_numBins;
    int           m_minBin;
    int           m_maxBin;
    int           m_lowBinL;
    /*
    gsl_matrix   *m_mode_modeMatrix;
    gsl_matrix   *m_bin_binMatrix;
    gsl_matrix   *m_bin_indexMatrix;
    gsl_matrix   *m_index_binMatrix;
    gsl_matrix   *m_inverseModeMatrix;
    gsl_matrix   *m_inverseBinMatrix;
    */
    gsl_matrix   *m_ModeModeMatrix;
    gsl_matrix   *m_InstrumentEffectsMatrix;
    gsl_matrix   *m_BinningMatrix;
    gsl_matrix   *m_UnbinningMatrix;
    gsl_matrix   *m_BinnedInstrumentEffectsMatrix;

    gsl_matrix   *m_InverseModeModeMatrix;
    gsl_matrix   *m_InverseInstrumentEffectsMatrix;
    gsl_matrix   *m_InverseBinningMatrix;
    gsl_matrix   *m_InverseUnbinningMatrix;
    gsl_matrix   *m_InverseBinnedInstrumentMatrix;

    PowSpec      *m_healPIXPowerSpectrum;
};

#endif
