/***************************************************************************
 *   fitsmanager.cpp                                                       *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * This header provides the definitions for various enumerated lists used  *
 * by the data classes.                                                    *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#include <string.h>
#include <CCfits/HDU.h>

#include "fitsmanager.h"
#include "basedata.h"
#include "association.h"
#include "pixelizer.h"
#include "transformer.h"

#define STORE m_ptr->pHDU().addKey
#define LOAD  m_ptr->pHDU().readKey

fitsManager::fitsManager(association* dataMgr, const char *filename, FILETYPE dataType, CCfits::RWmode mode)
           : fileManager() {
  *fits_err = 0;
  s_association = dataMgr;

  if (!filename) {
    m_err = fileInvalidError;
    s_association->errorValue(m_err);
    throw m_err;
  }

  try {
    if(CCfits::RWmode::Read == mode)
      m_ptr = new CCfits::FITS(filename, mode);
    /*
    else
    {
      long naxes[4] = {m_cols,m_rows,m_slices,m_parts};
      if(FILETYPE::PixelOccupancy == dataType)
        m_ptr = new CCfits::FITS(filename, fitsInt32, m_dimensions, naxes);
      else
        m_ptr = new CCfits::FITS(filename, fitsDouble, m_dimensions, naxes);
    }
    */
  }
  catch (CCfits::FitsException& err) {
    m_err = fileFitsError;
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    throw m_err;
  }

  m_fileDataType = dataType;
  fileName(filename);
  m_fileFormat = Fits;
}

fitsManager::fitsManager(association* dataMgr, const char *filename, baseData *data)
           : fileManager() {
  *fits_err = 0;
  s_association = dataMgr;

  if (!data || !filename) {
    m_err = fileInvalidError;
    s_association->errorValue(m_err);
    throw m_err;
  }

  fileName(filename);
  m_fileDataType = data->dataType();
  m_fileFormat   = Fits;
  m_observatory  = Analyzer;
  m_cols         = data->cols();
  m_rows         = data->rows();
  m_slices       = data->slices();
/*
  switch (m_fileDataType) {
      case fileType::Null:
      m_err = fileInvalidError;
      s_association->errorValue(m_err);
      throw m_err;
    case fileType::InputData:
    case fileType::InputWeights:
    case fileType::WeightedData:
    case fileType::InputNoise:
    case fileType::InputFilter:
    case fileType::InputBeam:
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      m_dimensions = 2;
      m_parts = 1;
      m_fitsType = fitsDouble;
      if (!saveBase(filename)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " +  std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      if (!saveMatrixD((matrixData<double>*)data)) {
//      if (!saveMatrixD(m_fileDataType)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      break;
    case fileType::AlmData:
    case fileType::AlmWeights:
    case fileType::AlmNoise:
    case fileType::AlmFilter:
    case fileType::AlmBeam:
      m_dimensions = 4;
      m_parts = 2;
      m_fitsType = fitsDouble;
      if (!saveBase(filename)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      if (!saveCubeCD((cubeData<complex<double> >*)data)) {
//      if (!saveCubeCD(m_fileDataType)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      break;
    case fileType::PixelOccupancy:
      m_dimensions = 1;
      m_parts = 1;
      m_fitsType = fitsInt32;
      if (!saveBase(filename)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      if (!saveVectorI((vectorData<int>*)data)) {
//      if (!saveVectorI(m_fileDataType)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      break;
    default:
      m_dimensions = 1;
      m_parts = 1;
      m_fitsType = fitsDouble;
      if (!saveBase(filename)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      if (!saveVectorD((vectorData<double>*)data)) {
//      if (!saveVectorD(m_fileDataType)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      break;
  }
  */
}

fitsManager::fitsManager(fitsManager* from)
           // : fileManager(from)
{
  m_ptr =      from->filePtr();
  m_fitsType = from->fitsType();
}

fitsManager::~fitsManager() {
  if (m_ptr) {
    delete m_ptr;
    m_ptr = 0;
  }
}

bool fitsManager::saveBase(const char* filename, int* numTypes, FILETYPE* dataTypes)
{
  std::string text, comment = "Entity which generated data.";

  // basically create "garbage" values
  // to allow us to use this constructor
  m_fitsType = fitsDouble;
  m_dimensions = 1;
  long nDataSteps[] = {*numTypes};

  try
  {
    m_ptr = new CCfits::FITS(filename, m_fitsType, m_dimensions, nDataSteps);
  }
  catch (CCfits::FitsException& err) {
    m_err = fileFitsError;
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  /* All data saved will be tagged as "Analyzer" data. In memory
     data generated from other observatories will be noted as such in
     the FITS comment section... */

  if(m_observatory >= OBSERVATORY_LIMIT)
    m_observatory = Analyzer;

  if (m_observatory != Analyzer) {
    text = observatoryNames[(int)m_observatory];
    comment  = "Compiled from ";
    comment += text;
    comment += " data file.";
    m_observatory = Analyzer;
  }

  try {
    STORE("TELESCOP","Analyzer",comment);
    STORE("INSTRUME",text,"Type of data stored in file.");
    STORE("NUMTYPES", std::to_string(*numTypes), "Data steps stored in file.");
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  try
  {
    for(int step = 0; step < *numTypes; step += 1)
    {
      string name = "STEP:" + std::to_string(step);
      STORE(name, dataTypeNames[static_cast<int>(dataTypes[step])], "Data processing step.");
    }
  }
  catch (CCfits::FitsException& err)
  {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  return true;
}

void fitsManager::save(int* numTypes, FILETYPE* dataTypes)
{
  baseData *data = 0;
  *fits_err = 0;
  m_err = noErrors;
  m_fileFormat = Fits;
  m_observatory = Analyzer;
  m_fitsType = fitsDouble;

  for(int i = 0; i < *numTypes; i += 1)
  {
    if (s_association->exists(dataTypes[i]))
    {
      data = s_association->getData(dataTypes[i]);

      m_cols         = data->cols();
      m_rows         = data->rows();
      m_slices       = data->slices();

      m_fileDataType = dataTypes[i];

      switch (m_fileDataType)
      {
        case fileType::Null:
          m_err = fileInvalidError;
          s_association->errorValue(m_err);
          throw m_err;
        case fileType::InputData:
        case fileType::InputWeights:
        case fileType::WeightedData:
        case fileType::InputNoise:
        case fileType::InputFilter:
        case fileType::InputBeam:
        case fileType::BinCouplingMatrix:
        case fileType::ModeCouplingMatrix:
        case fileType::InverseBinMatrix:
        case fileType::InverseModeMatrix:
          m_dimensions = 2;
          m_parts = 1;
          m_fitsType = fitsDouble;
          if (!saveMatrixD((matrixData<double>*)data))
            throw m_err;
          break;
        case fileType::AlmData:
        case fileType::AlmWeights:
        case fileType::AlmNoise:
        case fileType::AlmFilter:
        case fileType::AlmBeam:
          m_dimensions = 4;
          m_parts = 2;
          m_fitsType = fitsDouble;
          if (!saveCubeCD((cubeData<complex<double> >*)data))
            throw m_err;
          break;
        case fileType::PixelOccupancy:
          m_dimensions = 1;
          m_parts = 1;
          m_fitsType = fitsInt32;
          if (!saveVectorI((vectorData<int>*)data))
            throw m_err;
          break;
        default:
          m_dimensions = 1;
          m_parts = 1;
          m_fitsType = fitsDouble;
          if (!saveVectorD((vectorData<double>*)data))
            throw m_err;
          break;
      }
    }
  }

  return;
}

void fitsManager::save(ASSOCIATEDMAP map)
{
}

void fitsManager::save(ASSOCIATEDSPECTRUM spect)
{
}

bool fitsManager::saveVectorI(vectorData<int> *v)
{
  std::valarray<int> fitsData;
  std::string layout, scheme;
  unsigned long long int numOps, updateUnit, currOp;
  std::string hduName = "";
  CCfits::ExtHDU* dataImage = 0;

  if (v->layout() == Ring)
    layout = std::string("Ring");
  else if (v->layout() == Nest)
    layout = std::string("Nest");
  else
    layout = std::string("Unordered");

  if (v->pixelScheme() == HealPIX)
    scheme = std::string("HealPIX");
  else
    scheme = std::string("NotPixelized");

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1)
    updateUnit = 1;
  currOp = 0;

  fitsData.resize(m_rows);
  for (int row = 0; row < m_rows; row++) {
    fitsData[row] = (*v)[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }

  hduName = "Pixel_OCCUPANCY";
  std::vector<long> naxes = {m_rows};
  try
  {
    dataImage = m_ptr->addImage(hduName, fitsInt32, naxes);

    dataImage->addKey("NSIDES",v->sides(),"Number of sides.");
    dataImage->addKey("PIXLAYOUT",layout, "Type of layout used to pixelize.");
    dataImage->addKey("PIXSCHEME",scheme, "Type of pixel scheme used to pixelize.");
    dataImage->addKey("MAXVALUE",v->maxValue(),"Maximum number of data points in a pixel.");
    dataImage->addKey("MINVALUE",v->minValue(),"Minimum number of data points in a pixel.");

    dataImage->write(1, fitsData.size(), fitsData);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  if (m_err != noErrors) {
    m_err = incompleteTableWrittenError;
    s_association->errorValue(m_err);
    return false;
  }

  return true;
}

bool fitsManager::saveVectorD(vectorData<double> *v)
{
  std::valarray<double> fitsData;
  std::string layout, scheme, trans;
  unsigned long long int numOps, updateUnit, currOp;
  std::string hduName = "";
  CCfits::ExtHDU* dataImage = 0;

  switch (m_fileDataType) {
    case fileType::PixelizedData:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "PIXEL_DATA";
      break;
    case fileType::PixelizedWeights:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "PIXEL_MASK";
      break;
    case fileType::PixelizedNoise:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "PIXEL_NOISE";
      break;
    case fileType::PixelizedFilter:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "PIXEL_FILTER";
      break;
    case fileType::PixelizedBeam:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "PIXEL_BEAM";
      break;
    case fileType::InverseData:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "INVERSE_DATA";
      break;
    case fileType::InverseWeights:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "INVERSE_MASK";
      break;
    case fileType::InverseNoise:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "INVERSE_NOISE";
      break;
    case fileType::InverseFilter:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "INVERSE_FILTER";
      break;
    case fileType::InverseBeam:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "INVERSE_BEAM";
      break;
    case fileType::TransformedData:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "TRANSFORMED_DATA";
      break;
    case fileType::TransformedWeights:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "TRANSFORMED_MASK";
      break;
    case fileType::TransformedNoise:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "TRANSFORMED_NOISE";
      break;
    case fileType::TransformedFilter:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "TRANSFORMED_FILTER";
      break;
    case fileType::TransformedBeam:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "TRANSFORMED_BEAM";
      break;
    case fileType::SpectralData:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "PSEUDO-SPECTRAL_DATA";
      break;
  }

  if (v->layout() == Ring)
    layout = std::string("Ring");
  else if (v->layout() == Nest)
    layout = std::string("Nest");
  else
    layout = std::string("Unordered");

  if (v->pixelScheme() == HealPIX)
    scheme = std::string("HealPIX");
  else
    scheme = std::string("NotPixelized");

  if (v->transformerScheme() == Rsht)
    trans = std::string("Rsht");
  else
    trans = std::string("NotTransformed");

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1)
    updateUnit = 1;
  currOp = 0;

  fitsData.resize(m_rows);
  for (int row = 0; row < m_rows; row++) {
    fitsData[row] = (*v)[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }
//  int nSides = 0;
  std::vector<long> naxes = {m_rows};
  try
  {
    dataImage = m_ptr->addImage(hduName, fitsDouble, naxes);

    switch (m_fileDataType) {
      case fileType::PixelizedData:
      case fileType::PixelizedWeights:
      case fileType::WeightedPixel:
      case fileType::PixelizedNoise:
      case fileType::PixelizedFilter:
      case fileType::PixelizedBeam:
      case fileType::InverseData:
      case fileType::InverseWeights:
      case fileType::InverseNoise:
      case fileType::InverseFilter:
      case fileType::InverseBeam:
        dataImage->addKey("NSIDES",v->sides(),"Number of sides.");
        dataImage->addKey("PIXLAYOUT",layout, "Type of layout used to pixelize.");
        dataImage->addKey("PIXSCHEME",scheme, "Type of pixel scheme used to pixelize.");
        break;
      case fileType::TransformedData:
      case fileType::TransformedWeights:
      case fileType::WeightedTransform:
      case fileType::TransformedNoise:
      case fileType::TransformedFilter:
      case fileType::TransformedBeam:
        dataImage->addKey("TRANSFORMERSCHEME",trans,"Type of transformer scheme");
        dataImage->addKey("MAXINDEX",v->maxYIndex(), "Maximum index");
        dataImage->addKey("MININDEX",v->minYIndex(), "Minimum index");
        break;
      case fileType::SpectralData:
        dataImage->addKey("MAXINDEX",v->maxYIndex(),"Maximum index");
        dataImage->addKey("MININDEX",v->minYIndex(),"Minimum index");
        dataImage->addKey("MAXVALUE",v->maxValue(),"Maximum value");
        dataImage->addKey("MINVALUE",v->minValue(),"Minimum value");
        dataImage->addKey("MASKINDEX",v->mask(),   "Mask index");
        break;
    }

    dataImage->write(1, fitsData.size(), fitsData);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  if (m_err != noErrors) {
    m_err = incompleteTableWrittenError;
    s_association->errorValue(m_err);
    return false;
  }

  return true;
}

bool fitsManager::saveMatrixD(matrixData<double> *m)
{
  std::valarray<double> fitsData;
  unsigned long long int numOps, updateUnit, currOp;
  std::string hduName = "";
  CCfits::ExtHDU* dataImage = 0;

  switch (m_fileDataType) {
    case fileType::InputData:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "RAW_DATA";
      break;
    case fileType::InputWeights:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "RAW_MASK";
      break;
    case fileType::InputNoise:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "RAW_NOISE";
      break;
    case fileType::InputFilter:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "RAW_FILTER";
      break;
    case fileType::InputBeam:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "RAW_BEAM";
      break;
    case fileType::BinCouplingMatrix:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "BIN_COUPLING_MATRIX";
      break;
    case fileType::ModeCouplingMatrix:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "MODE_COUPLING_MATRIX";
      break;
    case fileType::InverseBinMatrix:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "INVERSE_BIN_COUPLING_MATRIX";
      break;
    case fileType::InverseModeMatrix:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "INVERSE_MODE_COUPLING_MATRIX";
      break;
  }

  numOps = m_cols * m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1)
    updateUnit = 1;
  currOp = 0;

  fitsData.resize(m_rows * m_cols);
  for(int r = 0; r < m_rows; r += 1)
    for(int c = 0; c < m_cols; c += 1)
      fitsData[r*m_cols+c] = (*m)[c][r];

  std::vector<long> naxes = {m_cols, m_rows};
  try
  {
    dataImage = m_ptr->addImage(hduName, fitsDouble, naxes);

    dataImage->addKey("CDELT1",m->RARes(), "RaResolution of data stored in file.");
    dataImage->addKey("CDELT2",m->DecRes(),"DecResolution of data stored in file.");

    dataImage->write(1, fitsData.size(), fitsData);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }


  if (m_err != noErrors) {
    m_err = incompleteTableWrittenError;
    s_association->errorValue(m_err);
    return false;
  }

  return true;
}

bool fitsManager::saveCubeCD(cubeData<complex<double> > *c) {
  std::valarray<double> fitsDataReal;
  std::valarray<double> fitsDataImag;

  unsigned long long int numOps, updateUnit, currOp;
  std::string hduName = "";
  CCfits::ExtHDU* dataImage = 0;

  switch (m_fileDataType) {
    case fileType::AlmData:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "ALM_DATA";
      break;
    case fileType::AlmWeights:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "ALM_MASK";
      break;
    case fileType::AlmNoise:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "ALM_NOISE";
      break;
    case fileType::AlmFilter:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "ALM_FILTER";
      break;
    case fileType::AlmBeam:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "ALM_BEAM";
      break;
  }

  std::vector<std::vector<std::vector<complex<double> > > > data = c->roAccess();

  numOps = m_slices * m_rows * m_cols;
  updateUnit = numOps / 100;
  if(updateUnit < 1)
    updateUnit = 1;
  currOp = 0;

  //fitsDataReal.resize(m_cols * m_rows * m_slices);
  //fitsDataImag.resize(m_cols * m_rows * m_slices);
  std::valarray<double> fitsData(m_cols * m_rows * m_slices * 2);
  int offset = m_cols * m_rows * m_slices;
  for (int slice = 0; slice < m_slices; ++slice)
  {
    for (int col = 0; col < m_cols; ++col)
    {
      for (int row = 0; row < m_rows; ++row)
      {
        // which slice we are in times the size of the slice
        int index = (slice * m_cols * m_rows);
        // which row we are in times the size of a row aka how many columns
        index += (row * m_cols);
        // which column we are in
        index += col;

        //fitsDataReal[index] = data[slice][col][row].real();
        //fitsDataImag[index] = data[slice][col][row].imag();
        fitsData[index]        = data[slice][col][row].real();
        fitsData[index+offset] = data[slice][col][row].imag();
        currOp++;
//        if(m_showProgress && !(currOp % updateUnit))
//          informProgress(currOp / updateUnit);
      }
    }
  }

  // since we are splitting the data into its real and imag parts
  // fits recognizes that our data size is twice the size of
  // cols * rows * slices, so we will automatically make the
  // axis to account for this by doubling slices
  // then when we read in slices we divide by 2.
  std::vector<long> naxes = {m_cols, m_rows, m_slices*2};
  //std::vector<long> naxes = {m_cols, m_rows, m_slices};
  try
  {
    dataImage = m_ptr->addImage(hduName, fitsDouble, naxes);

    dataImage->addKey("POLARIZATION",c->polarization(),"Polarization of data.");
    dataImage->addKey("INDEX",c->index(),"Index of data stored in file.");

    //dataImage->write(1,                       fitsDataReal.size(), fitsDataReal);
    //dataImage->write(1 + fitsDataReal.size(), fitsDataImag.size(), fitsDataImag);
    dataImage->write(1, fitsData.size(), fitsData);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  if (m_err != noErrors) {
    m_err = incompleteTableWrittenError;
    s_association->errorValue(m_err);
    return false;
  }

  return true;
}

bool fitsManager::saveMap(dataMap* map)
{
  return true;
}

bool fitsManager::saveSpectrum(dataSpectrum* spect)
{
  return true;
}

void fitsManager::open()
{
  switch(m_observatory)
  {
    case Delve:
      currHeader = &(m_ptr->extension(1));
      m_fileDataType = fileType::InputData;
      break;
    case Egret:
      break;
    case Fermi:
      break;
    case Sloan:
      break;
    case Auger:
      break;
    case Kascade:
      break;
    case Telescope_Array:
      break;
  }

  if (!getDimensions())
    {
      m_err = fileFitsError;
      m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
      delete m_ptr;
      m_ptr = 0;
      throw m_err;
    }

    if (!getEnergy())
    {
      m_err = fileFitsError;
      m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
      delete m_ptr;
      m_ptr = 0;
      throw m_err;
    }

    data();
}

void fitsManager::open(int* numTypes, FILETYPE* dataTypes)
{
  *fits_err = 0;

  for(int i = 0; i < *numTypes; i += 1)
  {
      m_fileDataType = dataTypes[i];

      baseData* dataValue = data();

      dataValue->fileName(this->fileName());
      dataValue->fileFormat(Fits);
      dataValue->dataType(dataTypes[i]);

      s_association->addData(dataValue);
  }

  /*
  if(m_observatory == Analyzer)
  {
    for(int i = 0; i < *numTypes; i += 1)
    {
      m_fileDataType = dataTypes[i];

      baseData* dataValue = data();

      dataValue->fileName(this->fileName());
      dataValue->fileFormat(Fits);
      dataValue->dataType(dataTypes[i]);

      s_association->addData(dataValue);
    }
  }
  else
  {
    switch(m_observatory)
    {
      case Gadget:
      case Sloan:
      case Delve:
        m_ptr->extension(1).makeThisCurrent();
        currHeader = &m_ptr->extension(1);
        m_fileDataType = //fileType::PixelizedData;
                         dataTypes[0];
        break;
      case Egret:
      case Fermi:
        break;
      case Auger:
        break;
      case Kascade:
        break;
      case Telescope_Array:
        break;
    }

    if (!getDataType())
    {
      m_err = fileFitsError;
      m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
      delete m_ptr;
      m_ptr = 0;
      throw m_err;
    }


    //m_fileDataType = fileType::PixelizedWeights;
    //m_fileDataType = dataTypes[0];


    //if (!getDimensions())
    //{
    //  m_err = fileFitsError;
    //  m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    //  delete m_ptr;
    //  m_ptr = 0;
    //  throw m_err;
    //}
    //
    //if (!getEnergy())
    //{
    //  m_err = fileFitsError;
    //  m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    //  delete m_ptr;
    //  m_ptr = 0;
    //  throw m_err;
    //}

    baseData* dataValue = data();

    dataValue->dataType(m_fileDataType);
    //dataValue->dataType(dataTypes[0]);
    s_association->addData(dataValue);
  }
  */

  m_fileFormat = Fits;
}

bool fitsManager::getHeaders(int hdrNum)
{
  return false;
}

FILETYPE* fitsManager::getHeaders(int* numTypes)
{
  FILETYPE* dataTypes;
  std::string instrument = "";
  std::string telescope  = "";


   /* Next, we determine the "telescope" (really, the data generation device),
      and resolve what the file data represents... */
  /*
   try {
     LOAD("TELESCOP",telescope);
  }
  catch (CCfits::FitsException& err) {
     snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
     m_err = fileFitsError;
     m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
     s_association->errorValue(m_err);
     s_association->errorDetails(m_errDetail);
     return 0; //false;
  }

  OBSERVATORY obsType = Unknown;
  int obsValue = (int)Unknown;
  while (obsType < OBSERVATORY_LIMIT) {
    obsType = static_cast<OBSERVATORY>(obsValue);
    if (telescope == observatoryNames[obsValue])
      break;
    obsValue++;
  }

  m_observatory = obsType;
  m_fileDataType = fileType::InputData;
  */
  string nTypes = "";

  if (m_observatory == Analyzer)
  {
     try
     {
      LOAD("NUMTYPES", nTypes);
      *numTypes = atoi(nTypes.c_str());
      dataTypes = new FILETYPE[*numTypes];
      for(int dataIndex = 0; dataIndex < *numTypes; dataIndex += 1)
      {
        string stepIndex = "STEP:" + std::to_string(dataIndex);
        string step = "";
        LOAD(stepIndex, step);
        for(int nameIndex = 0; nameIndex < static_cast<int>(FILETYPE::FILETYPE_LIMIT); nameIndex += 1)
        {
          if(step == dataTypeNames[nameIndex])
            dataTypes[dataIndex] = static_cast<FILETYPE>(nameIndex);
        }
      }
    }
     catch (CCfits::FitsException& err) {
       snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
       m_err = fileFitsError;
       m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
       s_association->errorValue(m_err);
      s_association->errorDetails(m_errDetail);
       return 0;//false;
     }
  }
  else if(m_observatory == Egret || m_observatory == Fermi)
  {
      if(!getDimensions())
         throw m_err;

      if(!getEnergy())
        throw m_err;

    dataTypes = new FILETYPE[1];
    dataTypes[0] = fileType::InputData;
    *numTypes = 1;
  }
  else if(m_observatory == Sloan)
  {
    m_ptr->extension(1).makeThisCurrent();
    currHeader = &m_ptr->extension(1);

    getDimensions();

    dataTypes = new FILETYPE[1];
    dataTypes[0] = fileType::InputData;
    *numTypes = 1;
  }
  else if(m_observatory == Gadget)
  {
    m_ptr->extension(1).makeThisCurrent();
    currHeader = &m_ptr->extension(1);

    getDimensions();

    dataTypes = new FILETYPE[1];
    dataTypes[0] = fileType::PixelizedData;
    *numTypes = 1;
  }
  else if(m_observatory == Delve)
  {
    m_ptr->extension(1).makeThisCurrent();
    currHeader = &m_ptr->extension(1);

    getDimensions();

    if(m_cols > 1)
    {
      dataTypes = new FILETYPE[1];
      dataTypes[0] = fileType::InputData;
      *numTypes = 1;
    }
    else
    {
      dataTypes = new FILETYPE[1];
      dataTypes[0] = fileType::PixelizedData;
      *numTypes = 1;
    }
  }


   if (m_observatory == OBSERVATORY_LIMIT) {
     m_err = fileNoKeyError;
     m_errDetail = errorText[abs(m_err)] + ": Observatory not recognized";
     s_association->errorValue(m_err);
     s_association->errorDetails(m_errDetail);
     return 0; //false;
   }

   return dataTypes;
}

bool fitsManager::getDataType() {
  FILETYPE type = fileType::Null;
  std::string instrument = "";
  std::string telescope  = "";
  int tempType;

  try {
    // First, we find the file numerical representation type...
    LOAD("BITPIX",tempType);
    m_fitsType = (FITSTYPE)tempType;
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    return false;
  }

    /* Next, we determine the "telescope" (really, the data generation device),
       and resolve what the file data represents... */
    try {
      LOAD("TELESCOP",telescope);
    }
    catch (CCfits::FitsException& err) {
      snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
      m_err = fileFitsError;
      m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
      return false;
    }
    OBSERVATORY obsType = Unknown;
    int obsValue = (int)Unknown;
    while (obsType < OBSERVATORY_LIMIT) {
      obsType = static_cast<OBSERVATORY>(obsValue);
      if (telescope == observatoryNames[obsValue])
        break;
      obsValue++;
    }
    m_observatory = obsType;
    m_fileDataType = fileType::InputData;
    if (m_observatory == Analyzer) {
      try {
        LOAD("INSTRUME",instrument);
      }
      catch (CCfits::FitsException& err) {
        snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        return false;
      }
      for (int dataNamesList = 0; dataNamesList < (int)fileType::FILETYPE_LIMIT; ++ dataNamesList)
        if (dataTypeNames[dataNamesList] == instrument)
          type = static_cast<FILETYPE>(dataNamesList);
      if (type != fileType::FILETYPE_LIMIT)
        m_fileDataType = type;
    }

    if (m_observatory == OBSERVATORY_LIMIT) {
      m_err = fileNoKeyError;
      m_errDetail = errorText[abs(m_err)] + ": Observatory not recognized";
      s_association->errorValue(m_err);
      s_association->errorDetails(m_errDetail);
      return false;
    }

  return true;
}

bool fitsManager::getDimensions()
{
  m_dimensions = 0;
  m_rows       = 1;
  m_cols       = 1;
  m_slices     = 1;
  m_parts      = 1;
  m_minSlice   = 0;
  m_maxSlice   = 0;

  int  *dim[4]     = { &m_cols,  &m_rows,  &m_slices, &m_parts };
  //std::string keyname[4] = { "TFIELDS", "NAXIS2", "NAXIS3",  "NAXIS4" };
  //std::string keyname[4] = {"NAXIS1", "NAXIS2", "NAXIS3",  "NAXIS4" };
  std::string keyname[4];

  if(m_observatory == Delve || m_observatory == Gadget || m_observatory == Sloan)
  {
    keyname[0] = "TFIELDS";
    keyname[1] = "NAXIS2";
    keyname[2] = "NAXIS3";
    keyname[3] = "NAXIS4";
  }
  else if(m_observatory == Egret || m_observatory == Fermi)
  {
    m_ptr->pHDU().makeThisCurrent();
    currHeader = &m_ptr->pHDU();
    keyname[0] = "NAXIS1";
    keyname[1] = "NAXIS2";
    keyname[2] = "NAXIS3";
    keyname[3] = "NAXIS4";
  }

  // since data is in the first extension, have to be sure to get it from there
  try {
    //m_ptr->currentExtension().readKey("NAXIS",m_dimensions);
    currHeader->readKey("NAXIS", m_dimensions);
    //CCfits::ExtHDU& binTable = m_ptr->extension(1);
    //binTable.readKey("NAXIS",m_dimensions);

    if (m_dimensions > 4)
      return false;

    for (int i = 0; i < m_dimensions; i++)
      currHeader->readKey(keyname[i].c_str(), *dim[i]);
      //m_ptr->currentExtension().readKey(keyname[i].c_str(),*dim[i]);
//      binTable.readKey(keyname[i].c_str(),*dim[i]);
  }
  catch (CCfits::FitsException& err)
  {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    std::cout << err.message().c_str() << "\n";
    return false;
  }

  m_maxSlice = m_slices - 1;

  return true;
}

bool fitsManager::getEnergy() {
  int n=0;

  switch (m_observatory) {
    case Analyzer:
    case Delve:
    case Gadget:
    case Sloan:
      n = 0;
      m_minE[n] = 0.0;
      m_maxE[n] = 0.0;
      break;
    case Egret:
      try {
        n = 0;
        char scratchPad[80];

        while (n < m_slices)
        {
          sprintf(scratchPad,"%s%d","MAXENG", n+1);
          LOAD(scratchPad,m_maxE[n]);
          sprintf(scratchPad,"%s%d","MINENG", n+1);
          LOAD(scratchPad,m_minE[n]);
          n += 1;
        }
      }
      catch (CCfits::FitsException& err) {
        snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
        std::cout << err.message() << "\n";
        return false;
      }
      break;
    case Telescope_Array:
    case Auger:
    case Kascade:
    case Fermi:
      try {
        std::valarray<double> energyColumn;
        CCfits::ExtHDU& table = m_ptr->extension("EBOUNDS");

        table.column("E_MIN").read(energyColumn,1,m_slices);
        n = 0;
        while (n < m_slices) {
          m_minE[n] = energyColumn[n]/1000.0;
          n++;
        }

        table.column("E_MAX").read(energyColumn,1,m_slices);
        n = 0;
        while (n < m_slices) {
          m_maxE[n] = energyColumn[n]/1000.0;
          n++;
        }
      }
      catch (CCfits::FitsException& err)
      {
        snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
        if(err.message() == "FITS Error: Cannot read HDU in FITS file: No HDU with name EBOUNDS and version 1")
          return true;

        return false;
      }
      break;
    default:
      return false;
  }

  return true;
}

baseData *fitsManager::data() {
  if (!m_ptr)
    return 0;

  if(m_observatory == Fermi || m_observatory == Egret)
      return data(m_minSlice, m_maxSlice);
  else if(m_observatory == Delve || m_observatory == Gadget || m_observatory == Sloan)
    return delveData();
  //else if(m_observatory == Sloan)
  //  return sloanData();
  //else if(m_observatory == Kascade)
  //  return kascadeData();
  //else if(m_observatory == Auger)
  //  return augerData();
  //else if(m_observatory == Telescope_Array)
  //  return telescopeData();
  else
  {
    switch (m_fileDataType) {
      case fileType::Null:
        return 0;
      case fileType::InputData:
      case fileType::InputWeights:
      case fileType::InputNoise:
      case fileType::InputFilter:
      case fileType::InputBeam:
      case fileType::WeightedData:
      case fileType::BinCouplingMatrix:
      case fileType::ModeCouplingMatrix:
      case fileType::InverseBinMatrix:
      case fileType::InverseModeMatrix:
        return getMatrixD();
      case fileType::AlmData:
      case fileType::AlmWeights:
      case fileType::AlmNoise:
      case fileType::AlmFilter:
      case fileType::AlmBeam:
        return getCubeCD();
      case fileType::PixelOccupancy:
        return getVectorI();
      default:
        return getVectorD();
    }
  }

  return 0;
}

inputMatrixData *fitsManager::data(int slice_min, int slice_max)
{
  std::valarray<double> fitsData;
  inputMatrixData* in_mat;
  long span, n, begin;
  std::string hduName = "";
  std::vector<string> colName(m_cols,"");
  const std::string cols = "COLUMN-";
  double ra_res = 0, dec_res = 0;
  unsigned long long int numOps, updateUnit, currOp;

  if (!m_ptr) {
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": No CCfits pointer";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (!(m_observatory == Egret || m_observatory == Fermi)) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": No slices in file";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min < 0 || slice_max < 0) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": Minimum slice number or maximum slice number less than 0";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min > m_slices || slice_max > m_slices) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": Slice number is greater than the available slices";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min > slice_max) {
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": Minimum slice number greater than maximum slice number";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  span  = slice_max - slice_min + 1;
  n     = span * m_cols * m_rows;
  begin = slice_min * m_cols * m_rows + 1;

  // set appropriate hdu name to identify extension
  switch (m_fileDataType) {
    case fileType::InputData:
      hduName = "RAW_DATA";
      break;
    case fileType::InputWeights:
      hduName = "RAW_MASK";
      break;
    case fileType::WeightedData:
      hduName = "WEIGHTED_DATA";
      break;
    case fileType::InputNoise:
      hduName = "RAW_NOISE";
      break;
    case fileType::InputFilter:
      hduName = "RAW_FILTER";
      break;
    case fileType::InputBeam:
      hduName = "RAW_BEAM";
      break;
    case fileType::BinCouplingMatrix:
      hduName = "BIN_COUPLING_MATRIX";
      break;
    case fileType::ModeCouplingMatrix:
      hduName = "MODE_COUPLING_MATRIX";
      break;
    case fileType::InverseBinMatrix:
      hduName = "INVERSE_BIN_COUPLING_MATRIX";
      break;
    case fileType::InverseModeMatrix:
      hduName = "INVERSE_MODE_COUPLING_MATRIX";
      break;
  }

  // set column names
  for (int col = 0; col < m_cols; col++)
    colName[col] = cols + std::to_string(col);

  // create data structure for storage
  in_mat = new inputMatrixData(m_cols,m_rows,m_fileDataType);
  in_mat->initialize();

  numOps = m_rows * m_cols;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  // load data
  try {
    LOAD("CDELT1",ra_res);
    LOAD("CDELT2",dec_res);
    in_mat->RARes(abs(ra_res));
    in_mat->DecRes(abs(dec_res));

    if(m_observatory == Fermi)
    {
      std::cout << "AXIS(0): " << m_ptr->pHDU().axis(0) << "M_COLS: " << m_cols << "\n";
      std::cout << "AXIS(1): " << m_ptr->pHDU().axis(1) << "M_ROWS: " << m_rows << "\n";

      //std::valarray<double> tempData;
      //m_ptr->pHDU().read(tempData);
      //std::cout << tempData.size() << "\n";

      m_ptr->pHDU().read(fitsData);
      //CCfits::ExtHDU& binTable = m_ptr->extension(hduName);
      //CCfits::ExtHDU& binTable = m_ptr->extension("GTI");
      //CCfits::ExtHDU& binTable = (CCfits::BinTable*)m_ptr->pHDU();

      //binTable.readKey("TFIELDS", m_cols);
      //binTable.readKey("NAXIS2",  m_rows);
      //in_mat = new inputMatrixData(m_cols, m_rows, m_fileDataType);
      in_mat->initialize();

      //in_mat->dataType(fileType::InputData);
      for (int col = 0; col < m_cols; ++col)
      {
      //  m_ptr->column(1).read(fitsData,1,m_rows);
        for (int row = 0; row < m_rows; ++row)
        {
          //printf("%s: %4d\t%s: %4d\t%s:%7d\n", "Col", col, "Row", row, "Index", (row*m_cols + col));
          (*in_mat)[col][row] = fitsData[row * m_cols + col];
          currOp++;
  //        if(m_showProgress && !(currOp % updateUnit))
  //          informProgress(currOp / updateUnit);
        }
        //printf("\n");
      }
    }
    else if(m_observatory == Egret)
    {
      in_mat->dataType(fileType::InputData);
      std::valarray<double> fitsData;
      m_ptr->pHDU().read(fitsData);

      for(int s = slice_min; s <= slice_max; s += 1)
      {
        int offset = s * m_rows * m_cols;
        for(int r = 0; r < m_rows; r += 1)
        {
          for(int c = 0; c < m_cols; c += 1)
            //(*in_mat)[c][r] += fitsData[r*m_cols + c];
            (*in_mat)[c][r] += fitsData[offset + (r * m_cols + c)];
        }
      }
    }
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);

    std::cout << err.message() << "\n";
    delete in_mat;
    return 0;
  }

  return in_mat;
}

inputMatrixData *fitsManager::data(float e_min,float e_max)
{
  return NULL;
}

baseData *fitsManager::delveData()
{
  currHeader = &(m_ptr->extension(1));
  inputMatrixData* matrix; //= new matrixData<double>(cols, rows, m_fileDataType);
  vectorData<double>* vector;

  switch(m_fileDataType)
  {
    case fileType::InputData:
    case fileType::InputWeights:
    case fileType::InputBeam:
    case fileType::InputFilter:
    case fileType::InputNoise:
      // figure out rows and columns
      // then copy read data into
      // the matrix

      try
      {
        std::valarray<double> fitsData;
        CCfits::BinTable* table((CCfits::BinTable*)currHeader);

        std::string raName;
        std::string deName;
        std::string dataName;

        if(m_observatory == Delve)
        {
          raName = "RA";
          deName = "DEC";
          //dataName = "EBV_SFD98";
        }
        else if(m_observatory == Sloan)
        {
          raName = "ra";
          deName = "dec";
          //dataName = "z";
        }

        std::valarray<double> raData;
        std::valarray<double> deData;
        table->column(raName).read(raData, 1, m_rows);
        table->column(deName).read(deData, 1, m_rows); // the dec data is in latitudinal style so has negatives we need to convert to 0 to 180 style
        //table->column(dataName).read(fitsData, 1, m_rows);

        // one way to guess resolution is find the smallest decimal
        // then go one tenth smaller
        // ie min value decimal is .0345
        // then resolution is .0001
        // because every value is divisible by that resolution

        double minRA = INT_MAX, minDEC = INT_MAX;
        double resRA = 0, resDEC = 0;
        for(int i = 0; i < raData.size(); i += 1)
        {
          string raStr = std::to_string(raData[i]);
          string raDecim = raStr.substr(raStr.find("."));
          double raDecimal = std::stod(raDecim);

          if(raDecimal < minRA)
            minRA = raDecimal;

          //if(std::abs(raData[i]) < minRA)
          //  minRA = std::abs(raData[i]);

          deData[i] = 90 - deData[i];

          string decStr = std::to_string(deData[i]);
          string decDecim = decStr.substr(decStr.find("."));
          double decDecimal = std::stod(decDecim);

          if(decDecimal < minDEC)
            minDEC = decDecimal;

          //if(std::abs(deData[i]) < minDEC)
          //  minDEC = std::abs(deData[i]);
        }

        // convert the min to a string,
        // change every digit to 0,
        // then append a 1 to the end
        // make sure it is positive though
        // and less than one
        // otherwise we will have a huge waste of data
        string minRAStr = std::to_string(std::abs(minRA));
        if(std::abs(minRA) < 1)
        {
          minRAStr = std::to_string(std::abs(minRA));
          for(int i = 0; i < std::strlen(minRAStr.c_str()); i += 1)
          {
            char c = minRAStr[i];
            if(isdigit(c))
              minRAStr[i] = '0';
          }
        }

        string minDECStr = std::to_string(std::abs(minDEC));
        if(std::abs(minDEC) < 1)
        {
          minDECStr = std::to_string(std::abs(minDEC));
          for(int i = 0; i < std::strlen(minDECStr.c_str()); i += 1)
          {
            char c = minDECStr[i];
            if(isdigit(c))
              minDECStr[i] = '0';
          }
        }

        minRAStr[strlen(minRAStr.c_str())-1] = '1';
        minDECStr[strlen(minDECStr.c_str())-1] = '1';

        //m_cols = raData.size() / 1000; // phi   = cols = ra
        //m_rows = deData.size() / 1000; // theta = rows = dec
        //matrix = new matrixData<double>(m_cols, m_rows, m_fileDataType);
        resRA = std::stod(minRAStr);
        resDEC = std::stod(minDECStr);

        // my computer can't handle
        // any smaller a resolution
        if(resRA < .01)
          resRA = .01;

        if(resDEC < .01)
          resDEC = .01;

        matrix = new inputMatrixData(resRA, resDEC, m_fileDataType);
        matrix->initialize();

        m_cols = 360/resRA;
        m_rows = 180/resDEC;


        for (int row = 0; row < raData.size(); row += 1)
        {
            long r = deData[row] / resDEC;
            long c = raData[row] / resRA;
            // this throws sigsegv
            //matrix->angle2bin(deData[row], raData[row], r, c);

            (*matrix)[c][r] += 1; // fitsData[row];
        }
      }
      catch (CCfits::FitsException& err)
      {
        snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        return 0;
      }

      return matrix;
      break;
    case fileType::PixelizedData:
    case fileType::PixelizedWeights:
    case fileType::PixelizedBeam:
    case fileType::PixelizedFilter:
    case fileType::PixelizedNoise:
      // figure out data size
      // read all pixelizing comments
      // that are needed
      // then copy read data into
      // appropriate vector

      try
      {
        CCfits::BinTable* table((CCfits::BinTable*)currHeader);

        std::vector<std::valarray<double>> fitsData(m_rows);
        //std::vector<std::valarray<double>>* fitsData2 = new std::vector<std::valarray<double>>(m_rows);
        //std::vector<std::valarray<double>*>* fitsData3 = new std::vector<std::valarray<double>*>(m_rows);

        string layout, scheme, nsides, minIndex, maxIndex;
        currHeader->readKey("PIXTYPE", scheme);
        currHeader->readKey("ORDERING", layout);
        currHeader->readKey("NSIDE", nsides);
        currHeader->readKey("FIRSTPIX", minIndex);
        currHeader->readKey("LASTPIX", maxIndex);

        //vector = new vectorData<double>(m_rows, m_fileDataType);
        vector = new vectorData<double>(stoi(maxIndex), m_fileDataType);
        vector->initialize();
        vector->sides(stoi(nsides));
        vector->minYIndex(stoi(minIndex));
        vector->maxYIndex(stoi(maxIndex));

        //for(int i = 0; i < fitsData3->size(); i += 1)
        //  (*fitsData3)[i] = new valarray<double>(stoi(nsides));

        if (layout == "RING")
          vector->layout(Ring);
        else if (layout == "NEST")
          vector->layout(Nest);
        else
          vector->layout(Unordered);

        if (scheme == "HEALPIX")
        {
          vector->pixelScheme(HealPIX);
          vector->numberOfPixels(12 * stoi(nsides) * stoi(nsides));

          s_association->addEngine(dataEngines::Pixelization, PIXELSCHEME::HealPIX);
          s_association->pixelizationEngine()->pixelLayout(vector->layout());
          s_association->pixelizationEngine()->pixelizerScheme(vector->pixelScheme());
          s_association->pixelizationEngine()->scale(vector->sides());
        }
        else
        {
          vector->pixelScheme(NotPixelized);
          vector->numberOfPixels(0);
        }
        vector->transformerScheme(NotTransformed);

        table->column(1).readArrays(fitsData, 1, m_rows);
        //table->column(1).readArrays(*fitsData2, 1, m_rows);

        std::cout << "Number of vectors: " << fitsData.size() << "\n";
        std::cout << "Number of values in valarray: " << fitsData[0].size() << "\n";

        int index = 0;
        // throws random sigsegv even though nothing is improperly indexed
        for (int row = 0; row < fitsData.size(); row += 1)
        {
            for(int i = 0; i < fitsData[row].size(); i += 1)
            {
              if(index < vector->numberOfPixels())
              {
                (*vector)[index] = fitsData[row][i];
                index += 1;
              }
            }
            // reclaim the row since we don't need it anymore
            //fitsData[row].resize(0);
        }
      }
      catch (CCfits::FitsException& err)
      {
        std::cout << "ERROR\n";
        snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        return 0;
      }

      return vector;
      break;
  }

  return 0;
}

vectorData<int> *fitsManager::getVectorI() {
  vectorData<int> *i_vec;
  std::string layout = "", scheme = "";
  std::string hduName = "PIXEL_OCCUPANCY";
  std::valarray<int> fitsData;
  CCfits::ExtHDU* dataImage = 0;
  int sides = 0;
  double maxValue = 0, minValue = 0;
  unsigned long long int numOps, updateUnit, currOp;

  try
  {
    dataImage = &(m_ptr->extension(hduName));

    dataImage->readKey("NSIDES", sides);
    dataImage->readKey("PIXLAYOUT",layout);
    dataImage->readKey("PIXSCHEME",scheme);
    dataImage->readKey("MAXVALUE",maxValue);
    dataImage->readKey("MINVALUE",minValue);

    m_rows = dataImage->axis(0);

    dataImage->read(fitsData);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    return 0;
  }

  i_vec = new vectorData<int>(m_rows,m_fileDataType);
  i_vec->initialize();
  i_vec->sides(sides);
  i_vec->maxYIndex(maxValue);
  i_vec->minYIndex(minValue);

  if (layout == "Ring")
    i_vec->layout(Ring);
  else if (layout == "Nest")
    i_vec->layout(Nest);
  else
    i_vec->layout(Unordered);

  if (scheme == "HealPIX") {
    i_vec->pixelScheme(HealPIX);
    i_vec->numberOfPixels(12 * sides * sides);
  }
  else {
    i_vec->pixelScheme(NotPixelized);
    i_vec->numberOfPixels(0);
  }

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  for (int row = 0; row < m_rows; ++row) {
    (*i_vec)[row] = fitsData[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }

  return i_vec;
}

vectorData<double> *fitsManager::getVectorD()
{
  vectorData<double> *d_vec;
  std::string layout = "", scheme = "",trans  = "";
  std::string hduName = "";
  std::valarray<double> fitsData;
  CCfits::ExtHDU* dataImage = 0;
  int sides = 0, maxIndex = 0, minIndex = 0, mask = 0;
  double maxValue = 0, minValue = 0;
  unsigned long long int numOps, updateUnit, currOp;

  switch (m_fileDataType)
  {
    case fileType::PixelizedData:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "PIXEL_DATA";
      break;
    case fileType::PixelizedWeights:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "PIXEL_MASK";
      break;
    case fileType::WeightedPixel:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "PIXEL_WEIGHTED_DATA";
      break;
    case fileType::PixelizedNoise:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "PIXEL_NOISE";
      break;
    case fileType::PixelizedFilter:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "PIXEL_FILTER";
      break;
    case fileType::PixelizedBeam:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "PIXEL_BEAM";
      break;
    case fileType::InverseData:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "INVERSE_DATA";
      break;
    case fileType::InverseWeights:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "INVERSE_MASK";
      break;
    case fileType::InverseNoise:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "INVERSE_NOISE";
      break;
    case fileType::InverseFilter:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "INVERSE_FILTER";
      break;
    case fileType::InverseBeam:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "INVERSE_BEAM";
      break;
    case fileType::TransformedData:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "TRANSFORMED_DATA";
      break;
    case fileType::TransformedWeights:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "TRANSFORMED_MASK";
      break;
    case fileType::WeightedTransform:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "WEIGHTED_TRANSFORM";
      break;
    case fileType::TransformedNoise:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "TRANSFORMED_NOISE";
      break;
    case fileType::TransformedFilter:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "TRANSFORMED_FILTER";
      break;
    case fileType::TransformedBeam:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "TRANSFORMED_BEAM";
      break;
    case fileType::SpectralData:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "PSEUDO-SPECTRAL_DATA";
      break;
  }

  try
  {
    dataImage = &(m_ptr->extension(hduName));
    switch (m_fileDataType) {
      case fileType::PixelizedData:
      case fileType::PixelizedWeights:
      case fileType::WeightedPixel:
      case fileType::PixelizedNoise:
      case fileType::PixelizedFilter:
      case fileType::PixelizedBeam:
      case fileType::InverseData:
      case fileType::InverseWeights:
      case fileType::InverseNoise:
      case fileType::InverseFilter:
      case fileType::InverseBeam:
        dataImage->readKey("NSIDES",sides);
        dataImage->readKey("PIXLAYOUT",layout);
        dataImage->readKey("PIXSCHEME",scheme);
        break;
      case fileType::TransformedData:
      case fileType::TransformedWeights:
      case fileType::WeightedTransform:
      case fileType::TransformedNoise:
      case fileType::TransformedFilter:
      case fileType::TransformedBeam:
        dataImage->readKey("TRANSFORMERSCHEME",trans);
        dataImage->readKey("MAXINDEX",maxIndex);
        dataImage->readKey("MININDEX",minIndex);
        break;
      case fileType::SpectralData:
        dataImage->readKey("MAXINDEX",maxIndex);
        dataImage->readKey("MININDEX",minIndex);
        dataImage->readKey("MAXVALUE",maxValue);
        dataImage->readKey("MINVALUE",minValue);
        dataImage->readKey("MASKINDEX",mask);
        break;
    }

    m_rows = dataImage->axis(0);
    dataImage->read(fitsData);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    return 0;
  }

  d_vec = new vectorData<double>(m_rows,m_fileDataType);
  d_vec->initialize();
  d_vec->sides(sides);
  d_vec->maxYIndex(maxIndex);
  d_vec->minYIndex(minIndex);
  d_vec->maxValue(maxValue);
  d_vec->minValue(minValue);
  d_vec->mask(mask);


  if (layout == "Ring")
    d_vec->layout(Ring);
  else if (layout == "Nest")
    d_vec->layout(Nest);
  else
    d_vec->layout(Unordered);

  if (scheme == "HealPIX") {
    d_vec->pixelScheme(HealPIX);
    d_vec->numberOfPixels(12 * sides * sides);

    s_association->addEngine(dataEngines::Pixelization, PIXELSCHEME::HealPIX);
    s_association->pixelizationEngine()->pixelLayout(d_vec->layout());
    s_association->pixelizationEngine()->pixelizerScheme(d_vec->pixelScheme());
    s_association->pixelizationEngine()->scale(sides);
  }
  else {
    d_vec->pixelScheme(NotPixelized);
    d_vec->numberOfPixels(0);
  }

  if (trans == "Rsht")
  {
    d_vec->transformerScheme(Rsht);

    s_association->addEngine(dataEngines::Transformation, TRANSFORMERSCHEME::Rsht);
    s_association->transformationEngine()->transformerScheme(d_vec->transformerScheme());
    s_association->transformationEngine()->minIndex(d_vec->minYIndex());
    s_association->transformationEngine()->maxIndex(d_vec->maxYIndex());
  }
  else
    d_vec->transformerScheme(NotTransformed);

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  for (int row = 0; row < m_rows; ++row) {
    (*d_vec)[row] = fitsData[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }
  return d_vec;
}

matrixData<double> *fitsManager::getMatrixD() {
  matrixData<double> *d_mat;
  std::valarray<double> fitsData;
  std::string hduName = "";
  CCfits::ExtHDU* dataImage = 0;
  double ra_res = 0, dec_res = 0;
  unsigned long long int numOps, updateUnit, currOp;

  // set appropriate hdu name to identify extension
  switch (m_fileDataType) {
    case fileType::InputData:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "RAW_DATA";
      break;
    case fileType::InputWeights:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "RAW_MASK";
      break;
    case fileType::WeightedData:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "WEIGHTED_DATA";
      break;
    case fileType::InputNoise:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "RAW_NOISE";
      break;
    case fileType::InputFilter:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "RAW_FILTER";
      break;
    case fileType::InputBeam:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "RAW_BEAM";
      break;
    case fileType::BinCouplingMatrix:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "BIN_COUPLING_MATRIX";
      break;
    case fileType::ModeCouplingMatrix:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "MODE_COUPLING_MATRIX";
      break;
    case fileType::InverseBinMatrix:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "INVERSE_BIN_COUPLING_MATRIX";
      break;
    case fileType::InverseModeMatrix:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "INVERSE_MODE_COUPLING_MATRIX";
      break;
  }

  // load data
  try
  {
    //dataImage = currHeader;
    dataImage = &(m_ptr->extension(hduName));

    dataImage->readKey("CDELT1",ra_res);
    dataImage->readKey("CDELT2",dec_res);

    m_cols = dataImage->axis(0);
    m_rows = dataImage->axis(1);

    dataImage->read(fitsData);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    delete d_mat;
    return 0;
  }

  // create data structure for storage
  d_mat = new matrixData<double>(m_cols,m_rows,m_fileDataType);
  d_mat->initialize();

  numOps = m_rows * m_cols;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  d_mat->RARes(ra_res);
  d_mat->DecRes(dec_res);

  for(int r = 0; r < m_rows; r += 1)
    for(int c = 0; c < m_cols; c += 1)
      (*d_mat)[c][r] = fitsData[r*m_cols+c];

  return d_mat;
}

cubeData<std::complex<double> > *fitsManager::getCubeCD() {
  cubeData<std::complex<double> > *dc_cube;
  std::vector<std::vector<std::vector<std::complex<double> > > > data;
  std::valarray<double> fitsData;
  std::string hduName = "";
  CCfits::ExtHDU* dataImage = 0;
  int polarization, index; //, offset;
  unsigned long long int numOps, updateUnit, currOp;
  int slice = 0, col = 0, row = 0;
  int dataCols = 0, dataRows = 0, dataSlices = 0;

  switch (m_fileDataType) {
    case fileType::AlmData:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "ALM_DATA";
      break;
    case fileType::AlmWeights:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "ALM_MASK";
      break;
    case fileType::AlmNoise:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "ALM_NOISE";
      break;
    case fileType::AlmFilter:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "ALM_FILTER";
      break;
    case fileType::AlmBeam:
      hduName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //hduName = "ALM_BEAM";
      break;
  }

  try
  {
    dataImage = &(m_ptr->extension(hduName));

    /* These may not be necessary anymore (redundant with rows, slices)... */
    dataImage->readKey("POLARIZATION",polarization);
    dataImage->readKey("INDEX",index);

    m_cols   = dataImage->axis(0);
    m_rows   = dataImage->axis(1);
    // split slices in half because we double it
    // when writing the data to account for splitting
    // of the complex into real and imag
    m_slices = dataImage->axis(2)/2;

    dataImage->read(fitsData);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  dc_cube = new cubeData<std::complex<double> >(m_cols,m_rows,m_slices,m_fileDataType);
  dc_cube->initialize();

  dc_cube->polarization(polarization);
  dc_cube->index(index);

  data = dc_cube->rwAccess();

  numOps = m_slices;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  // make it double the size because we write all the real parts then all the imag parts
  int imagOffset = m_cols * m_rows * m_slices;

  for (int slice = 0; slice < m_slices; ++slice){
    for (int col = 0; col < m_cols; ++col){
      for (int row = 0; row < m_rows; ++row){
        // which slice we are in times the size of the slice
        int index = (slice * m_cols * m_rows);
        // which row we are in times the size of a row aka how many columns
        index = index + (row * m_cols);
        // which column we are in
        index = index + col;

        data[slice][col][row] = complex<double>(fitsData[index], fitsData[index + imagOffset]);
      }
    }
  }

  return dc_cube;
}

dataMap* fitsManager::getMap()
{
  return 0;
}

dataSpectrum* fitsManager::getSpectrum()
{
  return 0;
}
