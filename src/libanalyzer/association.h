/***************************************************************************
 *   association.h                                                         *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * The association class collects all of the various data objects together *
 * for easy checking of the data chain as well as the associated action    *
 * engines for generating additional steps.                                *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#ifndef _ASSOCIATION_H_
#define _ASSOCIATION_H_

#include <math.h>

#include "atypes.h"
#include "basedata.h"
#include "../libgraphics/progress.h"

template <typename _type> class vectorData;
template <typename _type> class matrixData;
template <typename _type> class cubeData;
class inputMatrixData;
class dataMap;
class fileManager;
class Mapper;
class Grapher;
class dataSpectrum;
class Transformer;
class Pixelizer;
class Spectrum;

typedef void (*updateFx)(void*, int);

class association {
public:
  association();
  association(association* from);
  ~association() {reset();}

  /**
   * set two associations equal to each other.
   */
  association& operator=(association& other);

  /**
   * merge two associations. If replace = false, only merge if target is null, otherwise
   * completely replace the association
   */
  association& merge(association& other, bool replace = true);

  /**
   * merge specific data elements or engines.
   */
  baseData& merge(FILETYPE dataType, baseData* other, bool replace = true);
  dataMap& merge(ASSOCIATEDMAP mapType, dataMap* other, bool replace = true);
  dataSpectrum& merge(ASSOCIATEDSPECTRUM graphType, dataSpectrum* other, bool replace = true);
  Mapper& merge(MAPTYPE mapType, Mapper* other, bool replace = true);
  Grapher& merge(Grapher*other, bool replace = true);
  fileManager& merge(FORMAT ext, fileManager* other, bool replace = true);
  Pixelizer& merge(PIXELSCHEME pixType, Pixelizer* other, bool replace = true);
  Transformer& merge(TRANSFORMERSCHEME transType, Transformer* other, bool replace = true);
  Spectrum& merge(Spectrum* other, bool replace = true);

public:

  /**
   * access data chain
   */
  matrixData<double>* inputData() const {return m_inputData;}
  vectorData<double>* pixelizedData() const {return m_pixelData;}
  vectorData<double>* transformedData() const {return m_transData;}
  cubeData<std::complex<double> >* almData() const {return m_almData;}
  vectorData<double>* inverseData() const {return m_invData;}

  /**
   * access weights chain
   */
  matrixData<double>* inputWeights() const {return m_inputWeights;}
  vectorData<double>* pixelizedWeights() const {return m_pixelWeights;}
  vectorData<double>* transformedWeights() const {return m_transWeights;}
  cubeData<std::complex<double> >* almWeights() const {return m_almWeights;}
  vectorData<double>* inverseWeights() const {return m_invWeights;}

  /**
   * access weighted data chain
   */
  matrixData<double>* weightedInput() const {return m_weightedInput;}
  vectorData<double>* weightedPixel() const {return m_weightedPixel;}
  vectorData<double>* weightedInverse() const {return m_weightedInverse;}
  vectorData<double>* weightedTransform() const {return m_weightedTransform;}
  cubeData<complex<double>>* weightedAlm() const {return m_weightedAlm;}

  /**
   * access noise data
   */
  matrixData<double>* inputNoise() const {return m_inputNoise;}
  vectorData<double>* pixelizedNoise() const {return m_pixelNoise;}
  vectorData<double>* transformedNoise() const {return m_transNoise;}
  cubeData<std::complex<double> >* almNoise() const {return m_almNoise;}
  vectorData<double>* inverseNoise() const {return m_invNoise;}

  /**
   * access weighted noise data chain
   */
  matrixData<double>* weightedInputNoise() const {return m_weightedNoise;}
  vectorData<double>* weightedPixelizedNoise() const {return m_pixelWeightedNoise;}
  vectorData<double>* weightedTransformedNoise() const {return m_transWeightedNoise;}
  cubeData<std::complex<double>>* weightedAlmNoise() const {return m_weightedNoiseAlm;}
  vectorData<double>* weightedInverseNoise() const {return m_invWeightedNoise;}

  /**
   * access filter data
   */
  matrixData<double>* inputFilter() const {return m_inputFilter;}
  vectorData<double>* pixelizedFilter() const {return m_pixelFilter;}
  vectorData<double>* transformedFilter() const {return m_transFilter;}
  cubeData<std::complex<double> >* almFilter() const {return m_almFilter;}
  vectorData<double>* inverseFilter() const {return m_invFilter;}

  /**
   * access beam data
   */
  matrixData<double>* inputBeam() const {return m_inputBeam;}
  vectorData<double>* pixelizedBeam() const {return m_pixelBeam;}
  vectorData<double>* transformedBeam() const {return m_transBeam;}
  cubeData<std::complex<double> >* almBeam() const {return m_almBeam;}
  vectorData<double>* inverseBeam() const {return m_invBeam;}

  /**
   * access spectrum data
   */
  vectorData<double>*  EnsembleAveragedNoise()           const {return m_ensembleAveragedNoise;}
  matrixData<double>*  EnsembleIterationNoise()          const {return m_ensembleIterationNoise;}
  vectorData<double>*  EnsembleAveragedSpectrum()        const {return m_ensembleAveragedSpectrum;}
  matrixData<double>*  EnsembleIterationSpectrum()       const {return m_ensembleIterationSpectrum;}
  vectorData<double>*  BinnedSpectrum()                  const {return m_binnedSpectrum;}
  vectorData<double>*  EnsembleAveragedBinnedSpectrum()  const {return m_ensembleAveragedBinnedSpectrum;}
  matrixData<double>*  EnsembleIterationBinnedSpectrum() const {return m_ensembleIterationBinnedSpectrum; }

  //vectorData<double>* spectrumData() const {return m_spectData;}
  //vectorData<double>* ensembleData() const {return m_ensembleSpectData;}

  /**
   * access pixel occupancy
   */
  vectorData<int>* pixelOccupancy() const {return m_pixelOccupancy;}


  /**
   * access coupling matrix data
   */
  //matrixData<double>* couplingMatrix() const {return m_couplingMatrix;}
  //matrixData<double>* inverseMatrix() const {return m_inverseMatrix;}
  matrixData<double>*  ModeModeMatrix()                const {return m_ModeModeMatrix;}
  matrixData<double>*  InstrumentEffectsMatrix()       const {return m_InstrumentEffectsMatrix;}
  matrixData<double>*  BinningMatrix()                 const {return m_BinningMatrix;}
  matrixData<double>*  UnbinningMatrix()               const {return m_UnbinningMatrix;}
  matrixData<double>*  BinnedInstrumentEffectsMatrix() const {return m_BinnedInstrumentEffectsMatrix;}
  matrixData<double>*  InverseBinnedInstrumentMatrix() const {return m_InverseBinnedInstrumentMatrix;}


  /**
   * access maps
   */
  dataMap* inputDataMap() const {return m_inputDataMap;}
  dataMap* inputWeightsMap() const {return m_inputWeightsMap;}

  dataMap* weightedInputMap() const {return m_weightedInputMap;}

  dataMap* inputMap() const {return m_inputMap;} // the weighted input map
  dataMap* inputNoiseMap() const {return m_inputNoiseMap;}
  dataMap* inputFilterMap() const {return m_inputFilterMap;}
  dataMap* inputBeamMap() const {return m_inputBeamMap;}
  dataMap* weightedNoiseMap() const {return m_weightedNoiseMap;}

  dataMap* pixelDataMap() const {return m_pixelDataMap;}
  dataMap* pixelWeightsMap() const {return m_pixelWeightsMap;}

  dataMap* weightedPixelMap() const {return m_weightedPixelMap;}

  dataMap* pixelMap() const {return m_pixelMap;} // the weighted pixel map
  dataMap* pixelOccupancyMap() const {return m_pixelOccupancyMap;}
  dataMap* pixelNoiseMap() const {return m_pixelNoiseMap;}
  dataMap* pixelFilterMap() const {return m_pixelFilterMap;}
  dataMap* pixelBeamMap() const {return m_pixelBeamMap;}
  dataMap* pixelWeightedNoiseMap() const {return m_pixelWeightedNoiseMap;}

  dataMap* invDataMap() const {return m_invDataMap;}
  dataMap* invWeightsMap() const {return m_invWeightsMap;}

  dataMap* weightedInverseMap() const {return m_weightedInverseMap;}

  dataMap* invMap() const {return m_invMap;} // the inverse weighted data map
  dataMap* invFilterMap() const {return m_invFilterMap;}
  dataMap* invBeamMap() const {return m_invBeamMap;}
  dataMap* invNoiseMap() const {return m_invNoiseMap;}
  dataMap* invWeightedNoiseMap() const {return m_invWeightedNoiseMap;}

  /**
   * access transformed data graphs
   */
  dataSpectrum* transDataGraph() const {return m_transDataGraph;}
  dataSpectrum* transWeightsGraph() const {return m_transWeightsGraph;}

  dataSpectrum* weightedTransformGraph() const {return m_weightedTransformGraph;}

  dataSpectrum* transGraph() const {return m_transGraph;} // the weighted transform aka pseudo spectrum
  dataSpectrum* transFilterGraph() const {return m_transFilterGraph;}
  dataSpectrum* transNoiseGraph() const {return m_transNoiseGraph;}
  dataSpectrum* transBeamGraph() const {return m_transBeamGraph;}
  dataSpectrum* transWeightedNoiseGraph() const {return m_transWeightedNoiseGraph;}
  //dataSpectrum* spectrumGraph() const {return m_spectDataGraph;}
  //dataSpectrum* ensembleGraph() const {return m_ensembleDataGraph;}
  dataSpectrum* EnsembleAveragedNoiseGraph()            const {return m_ensembleAveragedNoiseGraph;}
  dataSpectrum* EnsembleAveragedSpectrumGraph()         const {return m_ensembleAveragedSpectrumGraph;}
  dataSpectrum* BinnedSpectrumGraph()                   const {return m_binnedSpectrumGraph;}
  dataSpectrum* EnsembleAveragedBinnedSpectrumGraph()   const {return m_ensembleAveragedBinnedSpectrumGraph;}

  /**
   * access data engines
   */

  fileManager* fileIOEngine() const {return m_fileIOEngine;}
  FORMAT fileIOEngineType() const {return m_selectedIOEngine;}
  void fileIOEngineType(FORMAT engine) {m_selectedIOEngine = engine;}
  Mapper* mappingEngine() const {return m_mapEngine;}
  MAPTYPE mappingEngineType() const {return m_selectedMapEngine;}
  void mapEngineType(MAPTYPE engine) {m_selectedMapEngine = engine;}
  Grapher* graphingEngine() const {return m_graphEngine;}
  Pixelizer* pixelizationEngine() const {return m_pixelEngine;}
  PIXELSCHEME pixelizationEngineType() const {return m_selectedPixelEngine;}
  void pixelizationEngineType(PIXELSCHEME engine) {m_selectedPixelEngine = engine;}
  Transformer* transformationEngine() const {return m_transformEngine;}
  TRANSFORMERSCHEME transformationEngineType() const {return m_selectedTransformEngine;}
  void transformationEngineType(TRANSFORMERSCHEME engine) {m_selectedTransformEngine = engine;}
  Spectrum* powerSpectraEngine() const {return m_powSpectEngine;}

  /**
   * access generic class of objects
   */
  baseData* getData(FILETYPE ft);
  dataMap* getMap(ASSOCIATEDMAP mt);
  dataSpectrum* getGraph(ASSOCIATEDSPECTRUM st);
  void* getEngine(DATAENGINES de);

  /**
   * verify that a particular data set exists in the data chain
   */
  bool exists(FILETYPE ft);
  bool exists(ASSOCIATEDMAP mt);
  bool exists(ASSOCIATEDSPECTRUM st);
  bool exists(DATAENGINES de);

  /**
   * Track position in data chain
   */
  SEQUENCE maxDataSet(GENERICTYPE type);
  SEQUENCE maxDataChain(GENERICTYPE type);
  SEQUENCE sequenceStep() const {return m_sequence;}
  void sequenceStep(SEQUENCE completed) {m_sequence = completed;}

   /*
   * actions associated with moving through data chain
   */
  void addEngine(DATAENGINES de, ...);
  inputMatrixData* workSpace(double resRA, double resDec);
  inputMatrixData* workSpace(inputMatrixData *imd);
  void workSpaceTo(FILETYPE type, M_OP operation);

  void getResolution(FILETYPE dataType, double &RARes, double &decRes);
  void createEmptyDataSet(FILETYPE dataType, double RARes, double decRes);
  void createUniformSky(FILETYPE dataType, double level, M_OP operation);
  void createUniformPatch(FILETYPE dataType, double decMax, double decMin, double RAMin, double RAMax, double level, M_OP operation);
  void createDeltaFunction(FILETYPE dataType, double RAPeak, double decPeak, double level, M_OP operation);
  void createGaussian(FILETYPE dataType, double RAPeak, double decPeak, double width, double level, M_OP operation);
  void createCheckerboard(FILETYPE dataType, double RAStride, double decStride, double level, M_OP operation);
  void createHarmonic(FILETYPE dataType, int l, int m, double level, M_OP operation);
  void createShotNoise(vectorData<double>* vdd);
  void createWhiteNoise(vectorData<double>* vdd);

  void generateWeightedData(FILETYPE ft);

  void generatePixelData(Pixelizer *pixelizer, FILETYPE ft);
//  void updatePixelData();
  double pixelAverage() const {return m_pixelAverage;}
  double pixelVariance() const {return m_pixelVariance;}

  void generateMap(FILETYPE type);

  bool generateTransformedData(Transformer *transformer, FILETYPE ft);
  bool generateTransformedDataFromAlm(Transformer *transformer, FILETYPE ft);
  bool generatePowerSpectrumData(Spectrum *spect);
  bool generateEnsembleSpectrumData(Spectrum* spect);

  bool generateGraph(FILETYPE type);

  bool generateInverseData(Transformer *transformer, FILETYPE ft);

  void addData(baseData *item);

  /**
   * reset data chain
   */
  void discardRelation(FILETYPE type);
  void reset();
  void reset(ALLTYPES id);
  void resetData();
  void resetMaps();
  void resetGraphs();
  void resetEngines();
  void resetSpectral();

  /**
   * progress function information
   */
//  progress* progressMonitor() {return m_progress;}
//  void progressMonitor(progress* monitor) {m_progress = monitor;}
//  void setProgressFunc(void* uiObject,void (*func)(void*,int)); // This is called by the GUI
//  void informProgress(double progress) { if(m_updateFunc) m_updateFunc(m_uiObject, progress);} //  This is called by data
//  void showProgress(bool show) { m_showProgress = show;}
//  bool  showProgress() const {return m_showProgress;}
//  void* userInterface() const {return m_uiObject;}
//  updateFx updateFunction() const {return m_updateFunc;}

  ERRORCODES  errorValue() const {return m_error;}
  void errorValue(ERRORCODES errNo) {m_error = errNo;}
  std::string errorDetails() const {return m_errorDescription;}
  std::string errorDetails(int errNo) const {return errorText[abs(errNo)];}
  void errorDetails(std::string errMsg) {m_errorDescription = errMsg;}

  std::string dataNames(int id) const {return dataTypeNames[id];}

private:
  void addEmpty(FILETYPE type, int x, int y = 1, int z = 1);
  void matrixTransfer(matrixData<double>* from, matrixData<double>* to, M_OP operation);
  dataMap* configureMap(FILETYPE type);
  dataSpectrum* configureGraph(FILETYPE type);

  bool                             m_showProgress;
  void*                            m_uiObject;
  updateFx                         m_updateFunc;
  progress                         *m_progress;

  double                           m_pixelAverage;
  double                           m_pixelVariance;

  inputMatrixData                  *m_workSpace;
  inputMatrixData                  *m_tmpSpace;

  matrixData<double>               *m_inputData;
  vectorData<double>               *m_pixelData;
  vectorData<double>               *m_transData;
  cubeData<std::complex<double> >  *m_almData;
  vectorData<double>               *m_invData;

  matrixData<double>               *m_inputWeights;
  vectorData<double>               *m_pixelWeights;
  vectorData<double>               *m_transWeights;
  cubeData<std::complex<double> >  *m_almWeights;
  vectorData<double>               *m_invWeights;

  matrixData<double>               *m_inputFilter;
  vectorData<double>               *m_pixelFilter;
  vectorData<double>               *m_transFilter;
  cubeData<std::complex<double> >  *m_almFilter;
  vectorData<double>               *m_invFilter;

  matrixData<double>               *m_inputNoise;
  vectorData<double>               *m_pixelNoise;
  vectorData<double>               *m_transNoise;
  cubeData<std::complex<double> >  *m_almNoise;
  vectorData<double>               *m_invNoise;

  matrixData<double>               *m_inputBeam;
  vectorData<double>               *m_pixelBeam;
  vectorData<double>               *m_transBeam;
  cubeData<std::complex<double> >  *m_almBeam;
  vectorData<double>               *m_invBeam;

  // the weighted data structures
  matrixData<double>               *m_weightedInput;
  vectorData<double>               *m_weightedPixel;
  vectorData<double>               *m_weightedTransform;
  vectorData<double>               *m_weightedInverse;
  cubeData<complex<double>>        *m_weightedAlm;

  matrixData<double>               *m_weightedNoise;
  vectorData<double>               *m_pixelWeightedNoise;
  vectorData<double>               *m_transWeightedNoise;
  vectorData<double>               *m_invWeightedNoise;
  cubeData<std::complex<double>>   *m_weightedNoiseAlm;

  vectorData<int>                  *m_pixelOccupancy;
  //matrixData<double>               *m_couplingMatrix;
  //matrixData<double>               *m_inverseMatrix;
  //vectorData<double>               *m_spectData;
  //vectorData<double>               *m_ensembleSpectData;
  vectorData<double>               *m_ensembleAveragedNoise;         // <Nl> in the paper with a tilde
  matrixData<double>               *m_ensembleIterationNoise;
  vectorData<double>               *m_spectrum;                      // Cl in the paper with a tilde
  vectorData<double>               *m_ensembleAveragedSpectrum;       // <Cl> in the paper with a tilde
  matrixData<double>               *m_ensembleIterationSpectrum;
  vectorData<double>               *m_binnedSpectrum;                // Cb in the paper with a tilde
  vectorData<double>               *m_ensembleAveragedBinnedSpectrum; // <Cb> in the paper with a tilde
  matrixData<double>               *m_ensembleIterationBinnedSpectrum;
  matrixData<double>               *m_ModeModeMatrix; // Mll in the paper
  matrixData<double>               *m_InstrumentEffectsMatrix; // Kll
  matrixData<double>               *m_BinningMatrix; // Pbl in the paper
  matrixData<double>               *m_UnbinningMatrix; // Qlb in the paper
  matrixData<double>               *m_BinnedInstrumentEffectsMatrix; // Kbb  in the paper
  matrixData<double>               *m_InverseBinnedInstrumentMatrix; //Kbb^-1 in the paper

  dataMap                          *m_inputDataMap;
  dataMap                          *m_inputWeightsMap;
  dataMap                          *m_inputMap;
  dataMap                          *m_inputNoiseMap;
  dataMap                          *m_inputFilterMap;
  dataMap                          *m_inputBeamMap;
  dataMap                          *m_weightedNoiseMap;
  
  dataMap                          *m_pixelDataMap;
  dataMap                          *m_pixelWeightsMap;
  dataMap                          *m_pixelMap;
  dataMap                          *m_pixelOccupancyMap;
  dataMap                          *m_pixelNoiseMap;
  dataMap                          *m_pixelFilterMap;
  dataMap                          *m_pixelBeamMap;
  dataMap                          *m_pixelWeightedNoiseMap;

  dataMap                          *m_invDataMap;
  dataMap                          *m_invWeightsMap;
  dataMap                          *m_invMap;
  dataMap                          *m_invNoiseMap;
  dataMap                          *m_invFilterMap;
  dataMap                          *m_invBeamMap;
  dataMap                          *m_invWeightedNoiseMap;
  
  dataMap                          *m_weightedInputMap;
  dataMap                          *m_weightedPixelMap;
  dataMap                          *m_weightedInverseMap;

  dataSpectrum                     *m_transDataGraph;
  dataSpectrum                     *m_transWeightsGraph;
  dataSpectrum                     *m_transGraph;
  dataSpectrum                     *m_spectDataGraph;
  dataSpectrum                     *m_ensembleDataGraph;
  dataSpectrum                     *m_transFilterGraph;
  dataSpectrum                     *m_transNoiseGraph;
  dataSpectrum                     *m_transBeamGraph;
  dataSpectrum                     *m_transWeightedNoiseGraph;

  dataSpectrum                     *m_ensembleAveragedNoiseGraph;
  dataSpectrum                     *m_ensembleAveragedSpectrumGraph;
  dataSpectrum                     *m_binnedSpectrumGraph;
  dataSpectrum                     *m_ensembleAveragedBinnedSpectrumGraph;
  dataSpectrum                     *m_weightedTransformGraph;


  fileManager                      *m_fileIOEngine;
  Mapper                           *m_mapEngine;
  Grapher                          *m_graphEngine;
  Pixelizer                        *m_pixelEngine;
  Transformer                      *m_transformEngine;
  Spectrum                         *m_powSpectEngine;

  SEQUENCE                         m_sequence;
  FORMAT                           m_selectedIOEngine;
  MAPTYPE                          m_selectedMapEngine;
  PIXELSCHEME                      m_selectedPixelEngine;
  TRANSFORMERSCHEME                m_selectedTransformEngine;


//  std::map<ALLTYPES, std::string>  m_allTypes;
  ERRORCODES                       m_error;
  std::string                      m_errorDescription;
};

#endif
