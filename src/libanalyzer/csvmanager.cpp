/***************************************************************************
 *   csvmanager.cpp                                                        *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * This header provides the definitions for various enumerated lists used  *
 * by the data classes.                                                    *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#include "csvmanager.h"
#include "basedata.h"
#include <string.h>
#include <algorithm>
#include "pixelizer.h"
#include "transformer.h"

csvManager::csvManager(association *dataMgr, const char *filename, FILETYPE dataType, RWMode mode)
          : fileManager() {
  m_err = noErrors;
  s_association = dataMgr;

  if (!filename) {
    m_err = fileInvalidError;
    s_association->errorValue(m_err);
    throw m_err;
  }

  try {
    if (mode == Read)
      m_ptr = new std::fstream(filename, std::fstream::in);
    else
      m_ptr = new std::fstream(filename, std::fstream::out);
  }
  catch (const char* str) {
    m_err = fileCsvError;
    snprintf(csv_err,CSV_ERR_LEN,"%s",str);
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(csv_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    throw m_err;
  }

  m_fileDataType = dataType;
  fileName(filename);
  m_fileFormat = CSV;
}

csvManager::csvManager(association *dataMgr, const char *filename,baseData *data)
          : fileManager() {
  m_err     = noErrors;
  s_association = dataMgr;

  if (!data || !filename) {
    m_err = fileInvalidError;
    s_association->errorValue(m_err);
    throw m_err;
  }

  fileName(filename);
  m_fileDataType = data->dataType();
  m_fileFormat   = CSV;
  m_observatory  = Analyzer;
  m_cols         = data->cols();
  m_rows         = data->rows();
  m_slices       = data->slices();

  /*
  switch (m_fileDataType) {
      case fileType::Null:
      m_err = fileInvalidError;
      s_association->errorValue(m_err);
      throw m_err;
    case fileType::InputData:
    case fileType::InputWeights:
    case fileType::WeightedData:
    case fileType::InputNoise:
    case fileType::InputFilter:
    case fileType::InputBeam:
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      m_dimensions = 2;
      m_parts = 1;
      if (!saveBase(filename)) {
        m_err = fileCreateError;
        throw m_err;
      }
      if (!saveMatrixD((matrixData<double>*)data)) {
        m_err = fileWriteError;
        s_association->errorValue(m_err);
        throw m_err;
      }
      break;
    case fileType::AlmData:
    case fileType::AlmWeights:
    case fileType::AlmNoise:
    case fileType::AlmFilter:
    case fileType::AlmBeam:
      m_dimensions = 4;
      m_parts = 2;
      if (!saveBase(filename)) {
        m_err = fileCreateError;
        s_association->errorValue(m_err);
        throw m_err;
      }
      if (!saveCubeCD((cubeData<complex<double> >*)data)) {
        m_err = fileWriteError;
        s_association->errorValue(m_err);
        throw m_err;
      }
      break;
    case fileType::PixelOccupancy:
      m_dimensions = 1;
      m_parts = 1;
      if (!saveBase(filename)) {
        m_err = fileCreateError;
        s_association->errorValue(m_err);
        throw m_err;
      }
      if (!saveVectorI((vectorData<int>*)data)) {
        m_err = fileWriteError;
        s_association->errorValue(m_err);
        throw m_err;
      }
      break;
    default:
      m_dimensions = 1;
      m_parts = 1;
      if (!saveBase(filename)) {
        m_err = fileCreateError;
        s_association->errorValue(m_err);
        throw m_err;
      }
      if (!saveVectorD((vectorData<double>*)data)) {
        m_err = fileWriteError;
        s_association->errorValue(m_err);
        throw m_err;
      }
      break;
  }
  */
}

csvManager::csvManager(csvManager* from)
          : fileManager(from) {
  m_ptr         = from->filePtr();
  m_headerData  = from->headerData();
}

csvManager::~csvManager() {
  if (m_ptr) {
    m_ptr->close();
    delete m_ptr;
    m_ptr = 0;
  }
}

bool csvManager::saveBase(const char* filename, int* numTypes, FILETYPE* dataTypes)
{
  std::string text, comment;

  if (!filename)
  {
    m_err = fileInvalidError;
    m_errDetail = errorText[abs(m_err)];
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  if (m_ptr == 0)
  {
    try {
      m_ptr = new std::fstream(filename, std::fstream::out);
    }
    catch (const char* str) {
      m_err = fileCsvError;
      snprintf(csv_err,CSV_ERR_LEN,"%s",str);
      m_errDetail = errorText[abs(m_err)] + ": " + std::string(csv_err);
      s_association->errorValue(m_err);
      s_association->errorDetails(m_errDetail);
      throw m_err;
    }

    if (!m_ptr)
    {
      m_err = fileCreateError;
      m_errDetail = errorText[abs(m_err)];
      s_association->errorValue(m_err);
      s_association->errorDetails(m_errDetail);
      return false;
    }
  }

  /* All data saved will be tagged as "Analyzer" data. In memory
     data generated from other observatories will be noted as such in
     a comment */
  if(m_observatory >= OBSERVATORY_LIMIT)
    m_observatory = Analyzer;

  if (m_observatory != Analyzer)
  {
    text = observatoryNames[(int)m_observatory];
    comment  = "# Compiled from ";
    comment += text;
    comment += " data file.";
    m_observatory = Analyzer;
  }

  *m_ptr << "[TELESCOPE] == Analyzer\n";
  if (comment.length() > 0)
    *m_ptr << comment << "\n";

  text = std::to_string(*numTypes);
  *m_ptr << "[NUMTYPES] == " << text << '\n';

  for(int i = 0; i < *numTypes; i += 1)
  {
    int typeIndex = static_cast<int>(dataTypes[i]);
    text = dataTypeNames[typeIndex];
    //std::string step = "[STEP" + std::to_string(static_cast<int>(dataTypes[i])) + "] == ";
    //std::string step = "[STEP" + std::to_string(typeIndex) + "] == ";
    std::string step = "[STEP" + std::to_string(i) + "] == ";

    *m_ptr << step << text << "\n";
  }

  *m_ptr << "\n";

  return true;
}

void csvManager::save(int* numTypes, FILETYPE* dataTypes)
{
  baseData *data = 0;
  m_err     = noErrors;

  for(int i = 0; i < *numTypes; i += 1)
  {
    data = s_association->getData(dataTypes[i]);

    m_fileDataType = data->dataType();
    m_fileFormat   = CSV;
    m_observatory  = Analyzer;
    m_cols         = data->cols();
    m_rows         = data->rows();
    m_slices       = data->slices();

    switch (m_fileDataType) {
        case fileType::Null:
        m_err = fileInvalidError;
        s_association->errorValue(m_err);
        throw m_err;
      case fileType::InputData:
      case fileType::InputWeights:
      case fileType::WeightedData:
      case fileType::InputNoise:
      case fileType::InputFilter:
      case fileType::InputBeam:
      case fileType::BinCouplingMatrix:
      case fileType::ModeCouplingMatrix:
      case fileType::InverseBinMatrix:
      case fileType::InverseModeMatrix:
        m_dimensions = 2;
        m_parts = 1;
        if (!saveMatrixD((matrixData<double>*)data))
          throw m_err;
        break;
      case fileType::AlmData:
      case fileType::AlmWeights:
      case fileType::AlmNoise:
      case fileType::AlmFilter:
      case fileType::AlmBeam:
        m_dimensions = 4;
        m_parts = 2;
        if (!saveCubeCD((cubeData<complex<double> >*)data))
          throw m_err;
        break;
      case fileType::PixelOccupancy:
        m_dimensions = 1;
        m_parts = 1;
        if (!saveVectorI((vectorData<int>*)data))
          throw m_err;
        break;
      default:
        m_dimensions = 1;
        m_parts = 1;
        if (!saveVectorD((vectorData<double>*)data))
          throw m_err;
        break;
    }
  }

  m_ptr->close();
  return;
}

void csvManager::save(ASSOCIATEDMAP map)
{
}

void csvManager::save(ASSOCIATEDSPECTRUM spect)
{
}

bool csvManager::saveVectorI(vectorData<int> *v)
{
  std::string layout, scheme;
  unsigned long long int numOps, updateUnit, currOp;

  if (v->layout() == Ring)
    layout = std::string("Ring");
  else if (v->layout() == Nest)
    layout = std::string("Nest");
  else
    layout = std::string("Unordered");

  if (v->pixelScheme() == HealPIX)
    scheme = std::string("HealPIX");
  else
    scheme = std::string("NotPixelized");

  *m_ptr << "[DATANAME] == " << dataTypeNames[static_cast<int>(FILETYPE::PixelOccupancy)];
  // save the dimensionality
  *m_ptr << "[NAXIS] == " << m_dimensions <<'\n';
  *m_ptr << "[NAXIS1] == " << m_cols << '\n';

  if (m_dimensions > 1)
    *m_ptr << "[NAXIS2] == " << m_rows <<'\n';
  if (m_dimensions > 2)
    *m_ptr << "[NAXIS3] == " << m_slices << '\n';
  if (m_dimensions > 3)
    *m_ptr << "[NAXIS4] == " << m_parts << '\n';

  *m_ptr << "[NSIDES] == " << v->sides() << '\n';
  *m_ptr << "[PIXLAYOUT] == " << layout << '\n';
  *m_ptr << "[PIXSCHEME] == " << scheme << '\n';

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  int row = 0;
  for (row = 0; row < m_rows; ++row) {
    *m_ptr << (*v)[row];
    if (row < m_rows - 1)
      *m_ptr << ',';
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }
  *m_ptr << '\n';


  return true;
}

bool csvManager::saveVectorD(vectorData<double> *v)
{
  std::string layout, scheme, trans;
  unsigned long long int numOps, updateUnit, currOp;

  std::string dataName;

  switch (m_fileDataType) {
    case fileType::PixelizedData:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "PIXEL_DATA";
      break;
    case fileType::PixelizedWeights:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "PIXEL_MASK";
      break;
    case fileType::PixelizedNoise:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "PIXEL_NOISE";
      break;
    case fileType::PixelizedFilter:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "PIXEL_FILTER";
      break;
    case fileType::PixelizedBeam:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "PIXEL_BEAM";
      break;
    case fileType::InverseData:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "INVERSE_DATA";
      break;
    case fileType::InverseWeights:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "INVERSE_MASK";
      break;
    case fileType::InverseNoise:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "INVERSE_NOISE";
      break;
    case fileType::InverseFilter:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "INVERSE_FILTER";
      break;
    case fileType::InverseBeam:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "INVERSE_BEAM";
      break;
    case fileType::TransformedData:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "TRANSFORMED_DATA";
      break;
    case fileType::TransformedWeights:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "TRANSFORMED_MASK";
      break;
    case fileType::TransformedNoise:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "TRANSFORMED_NOISE";
      break;
    case fileType::TransformedFilter:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "TRANSFORMED_FILTER";
      break;
    case fileType::TransformedBeam:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "TRANSFORMED_BEAM";
      break;
    case fileType::SpectralData:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "PSEUDO-SPECTRAL_DATA";
      break;
    case fileType::EnsembleData:
      dataName = dataTypeNames[(int)(m_fileDataType)];
  }

   *m_ptr << "[DATANAME] == " << dataName << "\n";
  // save the dimensionality
  *m_ptr << "[NAXIS] == " << m_dimensions <<'\n';
  *m_ptr << "[NAXIS1] == " << m_rows << '\n';

  if (m_dimensions > 1)
    *m_ptr << "[NAXIS2] == " << m_cols <<'\n';
  if (m_dimensions > 2)
    *m_ptr << "[NAXIS3] == " << m_slices << '\n';
  if (m_dimensions > 3)
    *m_ptr << "[NAXIS4] == " << m_parts << '\n';

  if (v->layout() == Ring)
    layout = std::string("Ring");
  else if (v->layout() == Nest)
    layout = std::string("Nest");
  else
    layout = std::string("Unordered");

  if (v->pixelScheme() == HealPIX)
    scheme = std::string("HealPIX");
  else
    scheme = std::string("NotPixelized");

  if (v->transformerScheme() == Rsht)
    trans = std::string("Rsht");
  else
    trans = std::string("NotTransformed");

  switch (m_fileDataType) {
    case fileType::PixelizedData:
    case fileType::PixelizedWeights:
    case fileType::WeightedPixel:
    case fileType::InverseData:
    case fileType::InverseWeights:
      *m_ptr << "[NSIDES] == " << v->sides() << '\n';
      *m_ptr << "[PIXLAYOUT] == " << layout <<'\n';
      * m_ptr << "[PIXSCHEME] == " << scheme <<'\n';
      break;
    case fileType::TransformedData:
    case fileType::TransformedWeights:
      *m_ptr << "[MAXINDEX] == " << v->maxYIndex() << '\n';
      *m_ptr << "[MININDEX] == " << v->minYIndex() << '\n';
      *m_ptr << "[TRANSFORMERSCHEME] == " << trans << '\n';
      break;
    case fileType::SpectralData:
      *m_ptr << "[MAXINDEX] == " << v->maxYIndex() << '\n';
      *m_ptr << "[MININDEX] == " << v->minYIndex() << '\n';
      *m_ptr << "[MAXVALUE] == " << v->maxValue() << '\n';
      *m_ptr << "[MINVALUE] == " << v->minValue() << '\n';
      *m_ptr << "[MASKINDEX] == " << v->mask() << '\n';
      break;
    default:
      break;
    }

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  int row = 0;
  for (row = 0; row < m_rows; ++row) {
    *m_ptr << (*v)[row];
    if (row < m_rows - 1)
      *m_ptr << ',';
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }
  *m_ptr << '\n';

  return true;
}

bool csvManager::saveMatrixD(matrixData<double> *m)
{
  unsigned long long int numOps, updateUnit, currOp;

  std::string dataName;

  switch (m_fileDataType) {
    case fileType::InputData:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "RAW_DATA";
      break;
    case fileType::InputWeights:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "RAW_MASK";
      break;
    case fileType::InputNoise:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "RAW_NOISE";
      break;
    case fileType::InputFilter:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "RAW_FILTER";
      break;
    case fileType::InputBeam:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "RAW_BEAM";
      break;
    case fileType::BinCouplingMatrix:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "BIN_COUPLING_MATRIX";
      break;
    case fileType::ModeCouplingMatrix:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "MODE_COUPLING_MATRIX";
      break;
    case fileType::InverseBinMatrix:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "INVERSE_BIN_COUPLING_MATRIX";
      break;
    case fileType::InverseModeMatrix:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "INVERSE_MODE_COUPLING_MATRIX";
      break;
  }

  *m_ptr << "[DATANAME] == " << dataName << "\n";
  // save the dimensionality
  *m_ptr << "[NAXIS] == " << m_dimensions <<'\n';
  *m_ptr << "[NAXIS1] == " << m_cols << '\n';
  if (m_dimensions > 1)
    *m_ptr << "[NAXIS2] == " << m_rows <<'\n';
  if (m_dimensions > 2)
    *m_ptr << "[NAXIS3] == " << m_slices << '\n';
  if (m_dimensions > 3)
    *m_ptr << "[NAXIS4] == " << m_parts << '\n';

  *m_ptr << "[RA_RES] == " << m->RARes() << '\n';
  *m_ptr << "[DEC_RES] == " << m->DecRes() << '\n';

  numOps = m_cols * m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  int col = 0, row = 0;
  for (col = 0; col < m_cols; ++col) {
    for (row = 0; row < m_rows; ++row) {
      *m_ptr << (*m)[col][row];
      if (row < m_rows - 1)
        *m_ptr << ',';
    }
    *m_ptr << '\n';
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }



  return true;
}

bool csvManager::saveCubeCD(cubeData<complex<double> > *c)
{
  std::vector<std::vector<std::vector<complex<double> > > > data = c->roAccess();
  unsigned long long int numOps, updateUnit, currOp;

  std::string dataName;
  switch (m_fileDataType)
  {
    case fileType::AlmData:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "ALM_DATA";
      break;
    case fileType::AlmWeights:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "ALM_MASK";
      break;
    case fileType::AlmNoise:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "ALM_NOISE";
      break;
    case fileType::AlmFilter:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "ALM_FILTER";
      break;
    case fileType::AlmBeam:
      dataName = dataTypeNames[static_cast<int>(m_fileDataType)];
      //dataName = "ALM_BEAM";
      break;
  }

   *m_ptr << "[DATANAME] == " << dataName << "\n";
  // save the dimensionality
  *m_ptr << "[NAXIS] == " << m_dimensions <<'\n';
  *m_ptr << "[NAXIS1] == " << m_cols << '\n';

  if (m_dimensions > 1)
    *m_ptr << "[NAXIS2] == " << m_rows <<'\n';
  if (m_dimensions > 2)
    *m_ptr << "[NAXIS3] == " << m_slices << '\n';
  if (m_dimensions > 3)
    *m_ptr << "[NAXIS4] == " << m_parts << '\n';

  *m_ptr << "[POLARIZATION] == " << c->polarization() <<'\n';
  *m_ptr << "[INDEX] == " << c->index() << '\n';

  numOps = m_slices * m_cols * m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  int slice = 0, col = 0, row = 0;

  for (slice = 0; slice < m_slices; ++slice)
  {
    for (col = 0; col < m_cols; ++col)
    {
      for (row = 0; row < m_rows; ++row)
      {
        *m_ptr << data[slice][col][row].real() << ',' << data[slice][col][row].imag();
        if (row < m_rows - 1)
          *m_ptr << ',';
      }
      *m_ptr << '\n';
    }
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }



  return true;
}

bool csvManager::saveMap(dataMap* map)
{
  return true;
}

bool csvManager::saveSpectrum(dataSpectrum* spect)
{
  return true;
}

void csvManager::open()
{
  return;
}

void csvManager::open(int* numTypes, FILETYPE* dataTypes)
{

  if(m_observatory == Analyzer)
  {
    for(int i = 0; i < *numTypes; i += 1)
    {
      m_fileDataType = dataTypes[i];
      baseData* dataValue = data();

      dataValue->fileName(this->fileName());
      dataValue->fileFormat(CSV);


      s_association->addData(dataValue);
    }
  }
  else if(m_observatory == Kascade)
  {
    if(!getDimensions())
      return;

    if(!getDataType())
      return;

    if(!getEnergy())
      return;

    baseData* dataValue = data();

    s_association->addData(dataValue);
  }

}

bool csvManager::getHeaders(int hdrNum)
{
  std::string headerStr, key, value;
  std::string delimiter = "] == ";
  int count = 0;

  int linePos = m_ptr->tellg();  // store current position in file
  std::getline(*m_ptr, headerStr);
  headerStr = convertString(headerStr);

  while (headerStr[0] == '[' || headerStr[0] == '#') {
    if (headerStr[0] == '[') {
      key = headerStr.substr(1,headerStr.find(delimiter)-1);
      value = headerStr.substr(headerStr.find(delimiter) + delimiter.length(),headerStr.length());
      m_headerData[key] = value;
      count++;
    }
    linePos = m_ptr->tellg();  // get new position in file
    std::getline(*m_ptr,headerStr);
    headerStr = convertString(headerStr);
  }
  m_ptr->seekg(linePos);  // return to start of previous line since it's not a header line

  if (count > 0)
    return true;
  else
    return false;
}

FILETYPE* csvManager::getHeaders(int* numTypes)
{
  std::string headerStr, key, value;
  std::string delimiter = "] == ";
  int count = 0;

  int linePos = m_ptr->tellg();  // store current position in file
  std::getline(*m_ptr, headerStr);
  headerStr = convertString(headerStr);

  *numTypes = 0;

  while (headerStr[0] == '[' || headerStr[0] == '#')
  {
    if (headerStr[0] == '[') {
      key = headerStr.substr(1,headerStr.find(delimiter)-1);
      value = headerStr.substr(headerStr.find(delimiter) + delimiter.length(),headerStr.length());
      m_headerData[key] = value;
      count++;
    }
    linePos = m_ptr->tellg();  // get new position in file
    std::getline(*m_ptr,headerStr);
    headerStr = convertString(headerStr);
  }

  string obs = m_headerData["TELESCOPE"];
  if(obs == "Analyzer")
  {
    m_observatory = Analyzer;
    *numTypes = atoi(m_headerData["NUMTYPES"].c_str());
    FILETYPE* dataTypes = new FILETYPE[*numTypes];
    for(int dataIndex = 0; dataIndex < *numTypes; dataIndex += 1)
    {
      string step = m_headerData["STEP" + std::to_string(dataIndex)];
      for(int nameIndex = 0; nameIndex < static_cast<int>(FILETYPE::FILETYPE_LIMIT); nameIndex += 1)
      {
        if(step == dataTypeNames[nameIndex])
          dataTypes[dataIndex] = static_cast<FILETYPE>(nameIndex);
      }
    }

    if (count > 0)
      return dataTypes;
  }
  else if(obs == "KASCADE")
  {
    m_observatory = Kascade;
    m_ptr->seekg(linePos);

    getDataType();
    getDimensions();
    getEnergy();

    *numTypes = 1;
    FILETYPE* dataTypes = new FILETYPE[1];
    dataTypes[0] = m_fileDataType;

    return dataTypes;
  }
  else
  {
    m_err = fileNoKeyError;
    snprintf(csv_err,CSV_ERR_LEN,"%s", ("INVALID OBSERVATORY: " + obs).c_str());
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(csv_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    throw m_err;
  }

  return 0;
}

bool csvManager::getDimensions()
{
  m_dimensions = 0;
  m_rows       = 1;
  m_cols       = 1;
  m_slices     = 1;
  m_parts      = 1;
  m_minSlice  = 0;
  m_maxSlice  = 0;

  int          *dim[4]     = {&m_cols, &m_rows, &m_slices, &m_parts};
  std::string  keyname[4] = {"NAXIS1", "NAXIS2", "NAXIS3", "NAXIS4"};

  if (m_headerData.find("NAXIS") == m_headerData.end()) {
    m_err = fileNoKeyError;
    return false;
  }
  else
    m_dimensions = std::stoi(m_headerData["NAXIS"]);

  if (m_dimensions > 4)
    return false;

  for (int i = 0; i < m_dimensions; i++) {
    if (m_headerData.find(keyname[i]) == m_headerData.end()) {
      m_err = fileNoKeyError;
      return false;
    }
    else
      *dim[i] = std::stoi(m_headerData[keyname[i]]);
  }

  m_maxSlice = m_slices - 1;

  return true;
}

bool csvManager::getDataType()
{
  FILETYPE type = fileType::Null;
  std::string instrument = "";
  std::string telescope  = "";

  telescope = m_headerData["TELESCOPE"];
  std::transform(telescope.begin(),telescope.end(),telescope.begin(),::toupper);

  OBSERVATORY obsType = Unknown;
  int obsValue = (int)Unknown;
  while (obsType < OBSERVATORY_LIMIT) {
    obsType = static_cast<OBSERVATORY>(obsValue);
    std::string ucObsName = observatoryNames[obsValue];
    std::transform(ucObsName.begin(),ucObsName.end(),ucObsName.begin(),::toupper);
    if (telescope == ucObsName)
      break;
    obsValue++;
  }
  m_observatory = obsType;
  m_fileDataType = fileType::InputData;
  if (m_observatory == Analyzer) {
    instrument = m_headerData["INSTRUMENT"];
    for (int dataNamesList = 0; dataNamesList < (int)fileType::FILETYPE_LIMIT; ++ dataNamesList)
      if (dataTypeNames[dataNamesList] == instrument)
        type = static_cast<FILETYPE>(dataNamesList);
    if (type != fileType::FILETYPE_LIMIT)
      m_fileDataType = type;
  }
  else if(m_observatory == Kascade)
  {
    string dataType = m_headerData["DATATYPE"];
    for(int i = 0; i < static_cast<int>(fileType::FILETYPE_LIMIT); i += 1)
    {
      if(dataTypeNames[i] == dataType)
        m_fileDataType = static_cast<FILETYPE>(i);
    }
  }

  if (m_observatory == OBSERVATORY_LIMIT) {
    m_err = fileNoKeyError;
    m_errDetail = errorText[abs(m_err)] + ": Observatory not recognized";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  return true;
}

bool csvManager::getEnergy() {
  int n;
  std::string maxE, minE;

  switch (m_observatory) {
    case Egret:
      n = 0;

      while (n < m_slices) {
        maxE = "MAXENG" + std::to_string(n);
        minE = "MINENG" + std::to_string(n);
        if (m_headerData.find(maxE) == m_headerData.end()) {
          m_err = fileNoKeyError;
          return false;
        }
        else
          m_maxE[n] = std::stoi(m_headerData[maxE]);
        if (m_headerData.find(minE) == m_headerData.end()) {
          m_err = fileNoKeyError;
          return false;
        }
        else
          m_minE[n] = std::stoi(m_headerData[minE]);
        n++;
      }
      break;
    case Fermi:
      n = 0;

      while (n < m_slices) {
        maxE = "E_MAX" + std::to_string(n);
        minE = "E_MIN" + std::to_string(n);
        if (m_headerData.find(maxE) == m_headerData.end()) {
          m_err = fileNoKeyError;
          return false;
        }
        else
          m_maxE[n] = std::stof(m_headerData[maxE]);
        if (m_headerData.find(minE) == m_headerData.end()) {
          m_err = fileNoKeyError;
          return false;
        }
        else
          m_minE[n] = std::stof(m_headerData[minE]);
        n++;
      }
      break;
    case Telescope_Array:
    case Auger:
    case Kascade:
      n = 0;
      if (m_headerData.find("E_MAX") == m_headerData.end()) {
        m_err = fileNoKeyError;
        return false;
      }
      else
        m_maxE[n] = std::stof(m_headerData["E_MAX"]);
      if (m_headerData.find("E_MIN") == m_headerData.end()) {
        m_err = fileNoKeyError;
        return false;
      }
      else
        m_minE[n] = std::stof(m_headerData["E_MIN"]);
    case Analyzer:
      n = 0;
      m_minE[n] = 0.0;
      m_maxE[n] = 0.0;
      break;
    default:
      return false;
  }

  return true;
}

baseData *csvManager::data() {
  if (!m_ptr)
    return 0;

  switch (m_fileDataType)
  {
      case fileType::Null:
      return 0;
    case fileType::InputData:
    case fileType::InputWeights:
    case fileType::InputBeam:
    case fileType::InputFilter:
    case fileType::InputNoise:
      if (m_observatory == Egret || m_observatory == Fermi)
//      if (m_observatory != Analyzer && m_observatory != Telescope_Array && m_observatory != Auger && m_observatory != Kascade)
        return data(m_minSlice,m_maxSlice);
      if (m_observatory == Telescope_Array || m_observatory == Auger || m_observatory == Kascade)
        return data(m_minE[0],m_maxE[0]);
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      return getMatrixD();
    case fileType::AlmData:
    case fileType::AlmWeights:
    case fileType::AlmBeam:
    case fileType::AlmFilter:
    case fileType::AlmNoise:
      return getCubeCD();
    case fileType::PixelOccupancy:
      return getVectorI();
    default:
      return getVectorD();
  }

  return 0;
}

inputMatrixData *csvManager::data(int slice_min, int slice_max) {
  inputMatrixData* in_mat = 0;
  long span, begin;
  unsigned long long int numOps, updateUnit, currOp;

  if (!m_ptr) {
    m_err = noFileError;
    m_errDetail = errorText[abs(m_err)] + ": No file stream pointer";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (!(m_observatory == Egret || m_observatory == Fermi)) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": No slices in file";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min < 0 || slice_max < 0) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": Minimum slice number or maximum slice number less than 0";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min > m_slices || slice_max > m_slices) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": Slice number is greater than the available slices";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min > slice_max) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": Minimum slice number greater than maximum slice number";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  span  = slice_max - slice_min + 1;
  begin = slice_min * m_rows;
  numOps = span * m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  std::string dataStr, colDescriptor, colName, field;
  long x, y;
  int EnergyNo = -1, decNo = -1, RANo = -1, ValueNo = -1;
  std::vector<double> colData;

  // go to start of slice in data
  int slice = 0;
  for (slice = 0; slice < begin; ++slice)
    std::getline(*m_ptr,dataStr);

  in_mat = new inputMatrixData(m_cols,m_rows,m_fileDataType);
  in_mat->initialize();

  int col = 0;
  while (col < m_cols) {
    colDescriptor = "COL" + std::to_string(col);
    if (m_headerData.find(colDescriptor) == m_headerData.end()) {
      m_err = fileNoKeyError;
      delete in_mat;
      in_mat = 0;
      return 0;
    }
    else {
      colName = m_headerData[colDescriptor];
      std::transform(colName.begin(),colName.end(),colName.begin(),::toupper);
      if (colName == "ENERGY")
        EnergyNo = col;
      else if (colName == "DEC" || colName == "LAT")
        decNo = col;
      else if (colName == "RA" || colName == "LONG")
        RANo = col;
      else if (colName == "VALUE")
        ValueNo = col;
      else {
        m_err = fileNoKeyError;
        return 0;
      }
    }
    col++;
  }
  if (decNo == -1 || RANo == -1) {
    m_err = fileNoKeyError;
    delete in_mat;
    in_mat = 0;
    return 0;
  }

  while (currOp < numOps) {
    std::getline(*m_ptr,dataStr);
    std::stringstream line(dataStr);
    while (line.good()) {
      std::getline(line,field, ',');
      colData.push_back(std::stod(field));
    }

    in_mat->angle2bin(colData[decNo],colData[RANo],x,y);
    if (ValueNo >= 0)
      (*in_mat)[x][y] += colData[ValueNo];
    else
      (*in_mat)[x][y] += colData[EnergyNo];

    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
    colData.clear();
  }

  return in_mat;
}

inputMatrixData *csvManager::data(float minE, float maxE) {
  inputMatrixData* in_mat = 0;
  double ra_res = 0, dec_res = 0;
  unsigned long long int numOps, updateUnit, currOp;

  if (!m_ptr) {
    m_err = noFileError;
    return 0;
  }
  if (minE < 0 || maxE < 0) {
    m_err = fileEnergyError;
    return 0;
  }
  if (minE > maxE) {
    m_err = fileEnergyError;
    return 0;
  }

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  std::string dataStr, colDescriptor, colName, field;
  long x, y;
  int EnergyNo = -1, decNo = -1, RANo = -1, ValueNo = -1;
  std::vector<std::string> colData;

  if (m_headerData.find("RA_RES") != m_headerData.end())
    ra_res = std::stod(m_headerData["RA_RES"]);
  else if (m_cols > 0)
    ra_res = 360.0/(double)m_cols;
  else {
    m_err = fileResError;
    return 0;
  }

  if (m_headerData.find("DEC_RES") != m_headerData.end())
    dec_res = std::stod(m_headerData["DEC_RES"]);
  else if (m_rows > 0)
    dec_res = 180.0/(double)m_rows;
  else {
    m_err = fileResError;
    return 0;
  }

  in_mat = new inputMatrixData((int)(360.0/ra_res),(int)(180.0/dec_res),m_fileDataType);
  in_mat->initialize();

  int col = 0;
  while (col < m_cols) {
    colDescriptor = "COL" + std::to_string(col+1);
    if (m_headerData.find(colDescriptor) == m_headerData.end()) {
      m_err = fileNoKeyError;
      delete in_mat;
      in_mat = 0;
      return 0;
    }
    else {
      colName = m_headerData[colDescriptor];
      std::transform(colName.begin(),colName.end(),colName.begin(),::toupper);
      if (colName == "ENERGY")
        EnergyNo = col;
      else if (colName == "DEC" || colName == "LAT")
        decNo = col;
      else if (colName == "RA" || colName == "LONG")
        RANo = col;
      else if (colName == "VALUE")
        ValueNo = col;
    }
    col++;
  }
  if (decNo == -1 || RANo == -1 || (EnergyNo == -1 && ValueNo == -1)) {
    m_err = fileNoKeyError;
    delete in_mat;
    in_mat = 0;
    return 0;
  }

  while (currOp < numOps)
  {
    std::getline(*m_ptr,dataStr);
    dataStr = convertString(dataStr);
    std::stringstream line(dataStr);
    while (line.good())
    {
      std::getline(line,field, ',');
      colData.push_back(field);

    }

    if(std::stof(colData[EnergyNo]) >= minE && std::stof(colData[EnergyNo]) <= maxE)
    {
      if (std::stod(m_headerData["MIN_RA"]) == 0.0)
        in_mat->angle2bin(std::stod(colData[decNo]),std::stod(colData[RANo])-180.0,x,y);
      else
        in_mat->angle2bin(std::stod(colData[decNo]),std::stod(colData[RANo]),x,y);
      if (ValueNo >= 0)
        (*in_mat)[x][y] += std::stod(colData[ValueNo]);
      else
        (*in_mat)[x][y] += std::stod(colData[EnergyNo]);
    }
    else
    {
      if (std::stod(m_headerData["MIN_RA"]) == 0.0)
        in_mat->angle2bin(std::stod(colData[decNo]),std::stod(colData[RANo])-180.0,x,y);
      else
        in_mat->angle2bin(std::stod(colData[decNo]),std::stod(colData[RANo]),x,y);

      if (ValueNo >= 0)
        (*in_mat)[x][y] += std::stod(colData[ValueNo]);
      else
        (*in_mat)[x][y] += std::stod(colData[EnergyNo]);
    }

    if(currOp % 1000000 == 0)
      std::cout << currOp << " elements read\n";

    currOp++;
    if (!(currOp % updateUnit))
      updateProgress((currOp*100)/numOps);
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
    colData.clear();
  }

  return in_mat;
}

vectorData<int> *csvManager::getVectorI()
{
  vectorData<int> *i_vec = 0;
  std::string layout = "";
  std::string scheme = "";
  int sides = 0;
  unsigned long long int numOps, updateUnit, currOp;
  m_err = noErrors;

  if (m_headerData.find("NSIDES") == m_headerData.end())
      m_err = fileNoKeyError;
  else
      sides = std::stoi(m_headerData["NSIDES"]);
  if (m_headerData.find("PIXLAYOUT") == m_headerData.end())
      m_err = fileNoKeyError;
  else
      layout = m_headerData["PIXLAYOUT"];
  if (m_headerData.find("PIXSCHEME") == m_headerData.end())
      m_err = fileNoKeyError;
  else
      scheme = m_headerData["PIXSCHEME"];

  if (m_err != noErrors) {
    m_errDetail = errorText[abs(m_err)];
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  std::string dataStr, field;
  std::vector<int> colData;
  int row = 0;

  std::string name, numDims, dims;

  std::getline(*m_ptr, name);
  std::getline(*m_ptr, numDims);
  std::getline(*m_ptr, dims);

  FILETYPE dataType = fileType::Null;
  for(int i = 0; i < static_cast<int>(FILETYPE::FILETYPE_LIMIT); i += 1)
    if(name == dataTypeNames[i])
      dataType = static_cast<FILETYPE>(i);

  std::getline(*m_ptr,dataStr);
  dataStr = convertString(dataStr);
  std::stringstream line(dataStr);
  while (line.good()) {
    std::getline(line,field, ',');
    colData.push_back(std::stoi(field));
  }

  i_vec = new vectorData<int>(m_rows,m_fileDataType);

  i_vec->dataType(dataType);
  m_dimensions = stoi(numDims);
  m_cols = stoi(dims);

  i_vec->sides(sides);

  if (layout == "Ring")
    i_vec->layout(Ring);
  else if (layout == "Nest")
    i_vec->layout(Nest);
  else
    i_vec->layout(Unordered);

  if (scheme == "HealPIX") {
    i_vec->pixelScheme(HealPIX);
    i_vec->numberOfPixels(12 * sides * sides);
  }
  else {
    i_vec->pixelScheme(NotPixelized);
    i_vec->numberOfPixels(0);
  }

  for (row = 0; row < m_rows; ++row) {
    (*i_vec)[row] = colData[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }

  return i_vec;
}

vectorData<double> *csvManager::getVectorD()
{
  vectorData<double> *d_vec = 0;
  std::string layout = "", scheme = "",trans  = "";
  int sides = 0, maxIndex = 0, minIndex = 0, mask = 0;
  double maxValue = 0, minValue = 0;
  unsigned long long int numOps, updateUnit, currOp;
  m_err = noErrors;

  std::string currLine = "";
  std::vector<string> currHeader;
  std::vector<string> currData;
  std::vector<string> currName;

  int index = 0;
  int linePos = m_ptr->tellg();
  std::getline(*m_ptr, currLine);

  while(currLine[0] == '[')
  {
    currHeader.push_back(currLine);
    linePos = m_ptr->tellg();
    std::getline(*m_ptr, currLine);
  }

  m_ptr->seekg(linePos);

  string key, val;
  string delim = "] == ";

  for(int i = 0; i < currHeader.size(); i += 1)
  {
      key = currHeader[i].substr(1,currHeader[i].find(delim)-1);
      val = currHeader[i].substr(  currHeader[i].find(delim) + delim.length(), currHeader[i].length());
      currName.push_back(key);
      currData.push_back(val);
  }

  for(int i = 0; i < static_cast<int>(FILETYPE::FILETYPE_LIMIT); i += 1)
  {
    if(currData[0] == dataTypeNames[i])
      m_fileDataType = static_cast<FILETYPE>(i);
  }


  m_dimensions = std::stoi(currData[1]);
  m_rows = std::stoi(currData[2]);

  switch (m_fileDataType)
  {
    case fileType::PixelizedData:
    case fileType::PixelizedWeights:
    case fileType::WeightedPixel:
    case fileType::InverseData:
    case fileType::InverseWeights:
    {
    /*
      if (m_headerData.find("NSIDES") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        sides = std::stoi(m_headerData["NSIDES"]);

      if (m_headerData.find("PIXLAYOUT") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        layout = (m_headerData["PIXLAYOUT"]);

    if (m_headerData.find("PIXSCHEME") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        scheme = m_headerData["PIXSCHEME"];
    */
    if(currName[3] == "NSIDES")
      sides = std::stoi(currData[3]);
    else
      m_err = fileNoKeyError;

    if(currName[4] == "PIXLAYOUT")
      layout = currData[4]; //std::stoi(currData[4]);
    else
      m_err = fileNoKeyError;

    if(currName[5] == "PIXSCHEME")
      scheme = currData[5]; //std::stoi(currData[5]);
    else
      m_err = fileNoKeyError;

    break;
    }
    case fileType::TransformedData:
    case fileType::TransformedWeights:
      /*
      if (m_headerData.find("MAXINDEX") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        maxIndex = std::stoi(m_headerData["MAXINDEX"]);

      if (m_headerData.find("MININDEX") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        minIndex = std::stoi(m_headerData["MININDEX"]);

      if (m_headerData.find("TRANSFORMERSCHEME") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        trans = m_headerData["TRANSFORMERSCHEME"];
      */
      if(currName[3] == "MAXINDEX")
        maxIndex = std::stoi(currData[3]);
      else
        m_err = fileNoKeyError;

      if(currName[4] == "MININDEX")
        minIndex = std::stoi(currData[4]);
      else
        m_err = fileNoKeyError;

      if(currName[5] == "TRANSFORMERSCHEME")
        trans = currData[5]; //std::stoi(currData[5]);
      else
        m_err = fileNoKeyError;

      break;
    case fileType::SpectralData:
      /*
      if (m_headerData.find("MAXINDEX") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        maxIndex = std::stoi(m_headerData["MAXINDEX"]);
      if (m_headerData.find("MININDEX") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        minIndex = std::stoi(m_headerData["MININDEX"]);
      if (m_headerData.find("MAXVALUE") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        maxValue = std::stod(m_headerData["MAXVALUE"]);
      if (m_headerData.find("MINVALUE") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        minValue = std::stod(m_headerData["MINVALUE"]);
      if (m_headerData.find("MASKINDEX") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        mask = std::stoi(m_headerData["MASKINDEX"]);
    */
      if(currName[3] == "MAXINDEX")
        maxIndex = std::stoi(currData[3]);
      else
        m_err = fileNoKeyError;

      if(currName[4] == "MININDEX")
        minIndex = std::stoi(currData[4]);
      else
        m_err = fileNoKeyError;

      if(currName[5] == "MAXVALUE")
        maxValue = std::stod(currData[5]);
      else
        m_err = fileNoKeyError;

      if(currName[6] == "MINVALUE")
        minValue = std::stod(currData[6]);
      else
        m_err = fileNoKeyError;

      if(currName[7] == "MASKINDEX")
        mask = std::stoi(currData[7]);
      else
        m_err = fileNoKeyError;

      break;
    default:
      break;
  }

  if (m_err != noErrors) {
    m_errDetail = errorText[abs(m_err)];
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  d_vec = new vectorData<double>(m_rows,m_fileDataType);
  d_vec->initialize();
  d_vec->dataType(m_fileDataType);
  d_vec->sides(sides);
  d_vec->maxYIndex(maxIndex);
  d_vec->minYIndex(minIndex);
  d_vec->maxValue(maxValue);
  d_vec->minValue(minValue);
  d_vec->mask(mask);

  if (layout == "Ring")
    d_vec->layout(Ring);
  else if (layout == "Nest")
    d_vec->layout(Nest);
  else
    d_vec->layout(Unordered);

  if (scheme == "HealPIX") {
    d_vec->pixelScheme(HealPIX);
    d_vec->numberOfPixels(12 * sides * sides);

    s_association->addEngine(dataEngines::Pixelization, PIXELSCHEME::HealPIX);
    s_association->pixelizationEngine()->pixelLayout(d_vec->layout());
    s_association->pixelizationEngine()->pixelizerScheme(d_vec->pixelScheme());
    s_association->pixelizationEngine()->scale(sides);
  }
  else {
    d_vec->pixelScheme(NotPixelized);
    d_vec->numberOfPixels(0);
  }

  if (trans == "Rsht")
  {
    d_vec->transformerScheme(Rsht);

    s_association->addEngine(dataEngines::Transformation, TRANSFORMERSCHEME::Rsht);
    s_association->transformationEngine()->transformerScheme(d_vec->transformerScheme());
    s_association->transformationEngine()->minIndex(d_vec->minYIndex());
    s_association->transformationEngine()->maxIndex(d_vec->maxYIndex());
  }
  else
    d_vec->transformerScheme(NotTransformed);

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  std::string dataStr, field;
  std::vector<double> colData;
  int row = 0;

  std::getline(*m_ptr,dataStr);
  dataStr = convertString(dataStr);
  std::stringstream line(dataStr);
  while (line.good()) {
    std::getline(line,field, ',');
    colData.push_back(std::stod(field));
  }

  for (row = 0; row < m_rows; ++row) {
    (*d_vec)[row] = colData[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }

  return d_vec;
}

matrixData<double> *csvManager::getMatrixD()
{
  matrixData<double> *d_mat = 0;
  double ra_res = 0, dec_res = 0;
  unsigned long long int numOps, updateUnit, currOp;
  m_err = noErrors;

  string currHeader[6];
  string currData[6];

  for(int i = 0; i < 6; i += 1)
    std::getline(*m_ptr, currHeader[i]);

  string key, val;
  string delimiter = "]  == ";
  for(int i = 0; i < 6; i += 1)
  {
    if (currHeader[i][0] == '[')
    {
      key = currHeader[i].substr(1, currHeader[i].find("] == ")-1);
      val = currHeader[i].substr(currHeader[i].find("] == ") + 5, currHeader[i].length());

      currData[i] = val;
    }
  }

  FILETYPE dataType = fileType::Null;
  for(int i = 0; i < static_cast<int>(FILETYPE::FILETYPE_LIMIT); i += 1)
    if(currData[0] == dataTypeNames[i])
      dataType = static_cast<FILETYPE>(i);

  m_fileDataType = dataType;
  m_dimensions = std::stoi(currData[1]);
  m_cols       = std::stoi(currData[2]);
  m_rows       = std::stoi(currData[3]);
  ra_res       = std::stod(currData[4]);
  dec_res      = std::stod(currData[5]);

  /*
  if (m_headerData.find("RA_RES") != m_headerData.end())
    ra_res = std::stod(m_headerData["RA_RES"]);
  else if (m_cols > 0)
    ra_res = 360.0/(double)m_cols;
  else
    m_err = fileResError;

  if (m_headerData.find("DEC_RES") != m_headerData.end())
    dec_res = std::stod(m_headerData["DEC_RES"]);
  else if (m_rows > 0)
    dec_res = 180.0/(double)m_rows;
  else
    m_err = fileResError;

  if (m_err != noErrors) {
    m_errDetail = errorText[abs(m_err)];
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  */

  //d_mat = new matrixData<double>((int)(360.0/ra_res),(int)(180.0/dec_res),m_fileDataType);
  d_mat = new matrixData<double>(m_cols, m_rows, m_fileDataType);
  d_mat->initialize();
  d_mat->RARes(ra_res);
  d_mat->DecRes(dec_res);

  /* assume that the data is a flat matrix where the rows are dec/lat,
   * the columns are RA/long, and the contents is the value at that point
   */

  numOps = m_cols * m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  std::string dataStr, field;
  std::vector<double> colData;
  int col = 0, row = 0;

  while (col < m_cols) {
    std::getline(*m_ptr,dataStr);
    dataStr = convertString(dataStr);
    std::stringstream line(dataStr);
    while (line.good()) {
      std::getline(line,field, ',');
      colData.push_back(std::stod(field));
    }

    for (int row = 0; row < m_rows; ++row) {
      (*d_mat)[col][row] = colData[row];
      currOp++;
//      if(m_showProgress && !(currOp % updateUnit))
//        informProgress(currOp / updateUnit);
    }
    col++;
    colData.clear();
  }

  return d_mat;
}

cubeData<complex<double>> *csvManager::getCubeCD() {
  cubeData<std::complex<double> > *dc_cube = 0;
  std::vector<std::vector<std::vector<std::complex<double> > > > data;
  int polarization = 0, index = 0, offset;
  unsigned long long int numOps, updateUnit, currOp;
  m_err = noErrors;

  std::vector<string> currHeader;
  std::vector<string> currData;

  int linePos = m_ptr->tellg();
  string currLine;
  std::getline(*m_ptr, currLine);

  while(currLine[0] == '[')
  {
    currHeader.push_back(currLine);
    linePos = m_ptr->tellg();
    std::getline(*m_ptr, currLine);
  }

  m_ptr->seekg(linePos);

  string key, val;
  string delim = "] == ";

  for(int i = 0; i < currHeader.size(); i += 1)
  {
      key = currHeader[i].substr(1,currHeader[i].find(delim)-1);
      val = currHeader[i].substr(  currHeader[i].find(delim) + delim.length(), currHeader[i].length());
      currData.push_back(val);
  }

  for(int i = 0; i < static_cast<int>(FILETYPE::FILETYPE_LIMIT); i += 1)
  {
    if(currData[0] == dataTypeNames[i])
      m_fileDataType = static_cast<FILETYPE>(i);
  }


  m_dimensions = std::stoi(currData[1]);
  m_rows = std::stoi(currData[2]);
  m_cols = std::stoi(currData[3]);
  m_slices = std::stoi(currData[4]);

  if(m_dimensions == 4)
  {
    m_parts = std::stoi(currData[5]);
    polarization = std::stoi(currData[6]);
    index = std::stoi(currData[7]);
  }
  else
  {
    polarization = std::stoi(currData[5]);
    index = std::stoi(currData[6]);
  }


  dc_cube = new cubeData<std::complex<double> >(m_cols,m_rows,m_slices,m_fileDataType);
  dc_cube->initialize();
  data    = dc_cube->rwAccess();
  dc_cube->polarization(polarization);
  dc_cube->index(index);

  numOps = m_slices * m_cols * m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  std::string dataStr, field;
  std::vector<double> colData;
  std::complex<double> value;
  int slice = 0, col = 0, row = 0;

  while (slice < m_slices)
  {
    while (col < m_cols)
    {
      std::getline(*m_ptr,dataStr);
      dataStr = convertString(dataStr);
      std::stringstream line(dataStr);
      while (line.good())
      {
        std::getline(line,field, ',');
        colData.push_back(std::stod(field));
      }

      for (int row = 0; row < m_rows; ++row) {
        value = complex<double>(colData[2*row], colData[2*row+1]);
        (*dc_cube)[slice][col][row] = value;
        currOp++;
//        if(m_showProgress && !(currOp % updateUnit))
//          informProgress(currOp / updateUnit);
      }
      col++;
      colData.clear();
    }
    slice++;
  }

  return dc_cube;
}

dataMap* csvManager::getMap()
{
  return 0;
}

dataSpectrum* csvManager::getSpectrum()
{
  return 0;
}

std::string csvManager::convertString(std::string inString)
{
  std::string unixString, cr = "\r";

  // check for windows-style crlf and convert to unix-style lf
  if (inString.find(cr))
    unixString = inString.substr(0,inString.find(cr));
  else
    unixString = inString;

  return unixString;
}
