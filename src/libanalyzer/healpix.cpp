/****************************************************************************
                              \healpix.cpp
Description:\brief (put short description here)

Begin    : Mon Jun 6 2005
Copyright: (C) 2005 by Daniel Suson
email    : daniel.suson@tamuk.edu

-----------------------------------------------------------------------------
                                Change Log
Date       Name                Description

-----------------------------------------------------------------------------

This program was developed at Texas A&M University-Kingsville by Daniel Suson.
It is free software; you may redistribute and/or modify it under the terms
of the GNU General License as published by the Free Software Foundation;
either version 2 of the License. or (at your option) any later version.

This software evolved from work that was done by Eric Hivon at the
California Institute of Technology on the MASTER algorithm (Hivon, E.,
et al., ApJ, vol 567, p 2).  It adapts or interfaces with these packages:

HealPix         (http://www.eso.org/science/healpix/)
FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)

Any publications or presentations that use results generated by this program
must reference the fact that it was developed at Texas A&M
University-Kingsville by Daniel Suson
***************************************************************************/
#include <math.h>
#include <stdio.h>
#include <istream>
#include <fstream>
#include <healpix_cxx/healpix_base.h>
#include <healpix_cxx/alm_healpix_tools.h>
// extern "C" {
// #include <chealpix.h>
// }

#include "basedata.h"
#include "inputmatrixdata.h"
#include "healpix.h"
HealPIXPixelizer::HealPIXPixelizer()
                : Pixelizer() {
  m_name = "HealPIX";
  m_scheme = HealPIX;
  m_sides = 1;
  m_layout = Ring;
//  m_maxSides = 1024;
  m_pixels = 12 * m_sides * m_sides;
  m_scratch = 0;

}

HealPIXPixelizer::HealPIXPixelizer(HealPIXPixelizer* from)
                : Pixelizer((Pixelizer*) from) {
  m_name     = from->name();
  m_scheme   = from->pixelizerScheme();
  m_sides    = from->scale();
  m_layout   = from->pixelLayout();
//  m_maxSides = from->maxScale();
  m_pixels   = 12 * m_sides * m_sides;
  m_scratch  = 0;
}

HealPIXPixelizer::~HealPIXPixelizer() {
  if (m_scratch)
    delete m_scratch;
}

void HealPIXPixelizer::initialize() {
  bool initialize = true;
  m_pixels = 12 * m_sides * m_sides; // total number of pixels in HealPix scheme
}

int HealPIXPixelizer::pixelize(association* dataClasses, long x, long y, int range, FILETYPE type) {
  int count = 0;
  int pixelNumber = 0;
  double phi = 0, theta = 0;
  double angle2rads = M_PI / 180.0;
  double maxValue = 0.0, minValue = 0.0;
  int maxCount = 0, minCount = 0;
  matrixData<double> *input = 0;
  vectorData<double> *pixout = 0;
  vectorData<int>* pixOccupancy = 0;

  /* Do input variable checks */
  if (type == fileType::Null)
    return 0;

  if (!dataClasses)
    return 0;

  switch (type) {
    case fileType::InputData:
      input = dataClasses->inputData();
      pixout = dataClasses->pixelizedData();
      pixOccupancy = dataClasses->pixelOccupancy();
      break;
    case fileType::InputWeights:
      input = dataClasses->inputWeights();
      pixout = dataClasses->pixelizedWeights();
      pixOccupancy = dataClasses->pixelOccupancy();
      break;
    case fileType::InputFilter:
      input = dataClasses->inputFilter();
      pixout = dataClasses->pixelizedFilter();
      pixOccupancy = dataClasses->pixelOccupancy();
      break;
    case fileType::InputBeam:
      input = dataClasses->inputBeam();
      pixout = dataClasses->pixelizedBeam();
      pixOccupancy = dataClasses->pixelOccupancy();
      break;
    case fileType::InputNoise:
      input = dataClasses->inputNoise();
      pixout = dataClasses->pixelizedNoise();
      pixOccupancy = dataClasses->pixelOccupancy();
      break;
    default:
      return 0;
  }

  if (range <= 0)
    range = input->size();
  
  // translate to healpix structure and get pixel number
  Healpix_Base* healpix = new Healpix_Base();
  healpix->SetNside((const int)m_sides,(Healpix_Ordering_Scheme)(m_layout-1));
  long i = x, j = y;

  for (count = 0;count < range;++count) {
    // update progress bar
//    dataClasses->informProgress((double)count / (double)range);

    input->bin2angle(i,j,theta,phi);  // convert bin coordinates to angular coordinates
    theta = (90.0 - theta) * angle2rads; // convert theta to 0-180 range and then to radians
    phi *= angle2rads; // convert phi to radians
    pixelNumber = healpix->ang2pix(pointing(theta,phi));

    (*pixout)[pixelNumber] += (*input)[i][j];

    //if (type == fileType::InputData)
    if(pixOccupancy)
    {
      (*pixOccupancy)[pixelNumber]++;

      if ((*pixOccupancy)[pixelNumber] > maxCount)
        maxCount = (*pixOccupancy)[pixelNumber];

      if ((*pixOccupancy)[pixelNumber] < minCount)
        minCount = (*pixOccupancy)[pixelNumber];
    }

    if ((*pixout)[pixelNumber] > maxValue)
      maxValue = (*pixout)[pixelNumber];

    if ((*pixout)[pixelNumber] < minValue)
      minValue = (*pixout)[pixelNumber];

    ++j;
    if (j == input->rows()) {
      ++i;
      j = 0;
    }
  }

  /*
  // store the old unaveraged pixel data
  vectorData<double>* oldPixel(pixout);
  // reset the max and min to account for the new average data
  minValue = maxValue; // set to be the highest to allow finding of min
  maxValue = 0.0;

  // divide by occupancy and store max and mins
  for(pixelNumber = 0; pixelNumber < pixout->rows(); pixelNumber += 1)
  {
    // if there is an occupancy at this pixel
    // divide the value by the pixel
    if((*pixOccupancy)[pixelNumber])
    {
      (*pixout)[pixelNumber] = (*pixout)[pixelNumber]/(*pixOccupancy)[pixelNumber];

      // find if this is min or max
      if((*pixout)[pixelNumber] > maxValue)
        maxValue = (*pixout)[pixelNumber];

      if((*pixout)[pixelNumber] < minValue)
        minValue = (*pixout)[pixelNumber];
    }
  }
  */

  // check min and max value for pixel data vector
  if (pixout->maxValue() != maxValue)
    pixout->maxValue(maxValue);
  if (pixout->minValue() != minValue)
    pixout->minValue(minValue);
  // check sides and min/max indices for pixel data vector
  if (pixout->sides() != m_sides)
    pixout->sides(m_sides);
  if (pixout->minYIndex() != 0)
    pixout->minYIndex(0);
  int pixCount = 12 * m_sides * m_sides;
  if (m_pixels != pixCount)
    m_pixels = pixCount;
  if (pixout->maxYIndex() != m_pixels)
    pixout->maxYIndex(m_pixels);

  // repeat for pixel occuplancy vector
  if (pixOccupancy) {
    if (pixOccupancy->maxValue() != maxValue)
      pixOccupancy->maxValue(maxValue);
    if (pixOccupancy->minValue() != minValue)
      pixOccupancy->minValue(minValue);
    // check sides and min/max indices for pixel data vector
    if (pixOccupancy->sides() != m_sides)
      pixOccupancy->sides(m_sides);
    if (pixOccupancy->minYIndex() != 0)//;
      pixOccupancy->minYIndex(0);
    if (pixOccupancy->maxYIndex() != m_pixels)
      pixOccupancy->maxYIndex(m_pixels);
  }

  return (count);
}

double HealPIXPixelizer::calculateAverage(FILETYPE dataType, association* assoc) {
  double globalAve = 0.0;
  int numberDataPoints = 0;
  vectorData<int> *hits = 0;
  vectorData<double> *data = 0;
  vectorData<double> *weights = 0;

  // load requisite data sets
  if (assoc->exists(fileType::PixelOccupancy))
    hits = assoc->pixelOccupancy();
  else
    throw incompleteDatasetError;

  if (dataType >= fileType::PixelizedData && dataType <= fileType::PixelizedBeam) // this is the error causing line
  {
    if (assoc->exists(fileType::PixelizedWeights))
      weights = new vectorData<double>(assoc->pixelizedWeights());

    switch (dataType) {
      case fileType::PixelizedData:
        if (assoc->exists(fileType::PixelizedData))
          data = new vectorData<double>(assoc->pixelizedData());
        break;
      case fileType::PixelizedWeights:
        if (assoc->exists(fileType::PixelizedWeights))
          data = new vectorData<double>(assoc->pixelizedWeights());
        break;
      case fileType::PixelizedNoise:
        if (assoc->exists(fileType::PixelizedNoise))
          data = new vectorData<double>(assoc->pixelizedNoise());
        break;
      case fileType::PixelizedFilter:
        if (assoc->exists(fileType::PixelizedFilter))
          data = new vectorData<double>(assoc->pixelizedFilter());
        break;
      case fileType::PixelizedBeam:
        if (assoc->exists(fileType::PixelizedBeam))
          data = new vectorData<double>(assoc->pixelizedBeam());
        break;
    }
  }
  else
    throw incompleteDatasetError;

  // check to make sure everything loaded correctly
  if (dataType != fileType::PixelOccupancy) {
    if (!(hits && (data || weights)))
      throw incompleteDatasetError;
    if (weights) {
      if (data->rows() != weights->rows() || data->rows() != hits->rows() || weights->rows() != hits->rows())
        throw dataMismatchError;
    }
    else {
      if (data->rows() != hits->rows())
        throw dataMismatchError;
    }
  }
  else {
    if (!(hits && weights))
      throw incompleteDatasetError;
    if (weights->rows() != hits->rows())
      throw dataMismatchError;
  }

  // In general, calculate average by summing the (weighted) data and number of data points across all pixels
  // then the two. Have to treat the occupancy average different, however, as that would be the sum of the occupancy
  // divided by the number of pixels
  long nPixels = hits->rows();
  for (int row = 0;row < nPixels;++row)
  {
    if (dataType == fileType::PixelOccupancy && weights)
      numberDataPoints += (*hits)[row] * (*weights)[row];
    else
    {
      numberDataPoints += (*hits)[row];
      if(data && dataType != fileType::PixelizedWeights)
      {
        //double dataValue = (*data)[row] * (*hits)[row];
        if(weights)
          //globalAve += dataValue * (*weights)[row];
          globalAve += (*data)[row] * (*weights)[row];
        else
          //globalAve += dataValue;
          globalAve += (*data)[row];
      }
      else if (weights)
        globalAve += (*weights)[row];
      else
        throw incompleteDatasetError;
    }
  }

  if (dataType == fileType::PixelOccupancy)
    globalAve = numberDataPoints / nPixels;
  else
    globalAve /= numberDataPoints;

  if (data)
    delete data;
  if (weights)
    delete weights;
  return globalAve;
}

double HealPIXPixelizer::calculateVariance(FILETYPE dataType, association* assoc) {
  double variance = 0.0;
  int totalHits = 0;
  vectorData<int> *hits = 0;
  vectorData<double> *data = 0;

  // load requisite data sets
  if (assoc->exists(fileType::PixelOccupancy))
    hits = assoc->pixelOccupancy();
  else
    throw incompleteDatasetError;
  if (dataType >= fileType::PixelizedData && dataType <= fileType::PixelizedBeam) {
    switch (dataType) {
      case fileType::PixelizedData:
        if (assoc->exists(fileType::PixelizedData))
          data = assoc->pixelizedData();
        break;
      case fileType::PixelizedWeights:
        if (assoc->exists(fileType::PixelizedWeights))
          data = assoc->pixelizedWeights();
        break;
      case fileType::PixelizedNoise:
        if (assoc->exists(fileType::PixelizedNoise))
          data = assoc->pixelizedNoise();
        break;
      case fileType::PixelizedFilter:
        if (assoc->exists(fileType::PixelizedFilter))
          data = assoc->pixelizedFilter();
        break;
      case fileType::PixelizedBeam:
        if (assoc->exists(fileType::PixelizedBeam))
          data = assoc->pixelizedBeam();
        break;
    }
  }
  else
    throw incompleteDatasetError;

  // check to make sure everything loaded correctly
  if (dataType != fileType::PixelOccupancy) {
    if (!(hits && data))
      throw incompleteDatasetError;
    if (data->rows() != hits->rows())
      throw dataMismatchError;
  }
  else
    if (!hits)
      throw incompleteDatasetError;

  // calculate variance as the sum of the squared difference between the value in the pixel and the average,
  // then divide the sum by either the total number of pixels (pixelOccupancy) or data points (all others), minus 1
  long nPixels = hits->rows();
  double average = calculateAverage(dataType, assoc);
  for (int row = 0;row < nPixels;++row)
  {
    if (dataType == fileType::PixelOccupancy)
      variance += ((*hits)[row] - average) * ((*hits)[row] - average);
    else
    {
      //double dataValue = (*data)[row] * (*hits)[row];
      //variance += (dataValue - average) * (dataValue - average);
      variance += ((*data)[row] - average) * ((*data)[row] - average);
      totalHits += (*hits)[row];
    }
  }

  if (dataType == fileType::PixelOccupancy)
    variance /= (nPixels - 1);
  else
    variance /= (totalHits - 1);

  return variance;
}

vectorData<double>* HealPIXPixelizer::meanNormalize(FILETYPE dataType, association* assoc, bool useMean)
{
  vectorData<int> *hits = 0;
  vectorData<double> *data = 0;

  // load requisite data sets
  if (assoc->exists(fileType::PixelOccupancy))
    hits = assoc->pixelOccupancy();
  else
    throw incompleteDatasetError;

  if (dataType >= fileType::PixelizedData && dataType <= fileType::PixelizedBeam)
  {
    switch (dataType) {
      case fileType::PixelizedData:
        if (assoc->exists(fileType::PixelizedData))
          data = assoc->pixelizedData();
        break;
      case fileType::PixelizedWeights:
        if (assoc->exists(fileType::PixelizedWeights))
          data = assoc->pixelizedWeights();
        break;
      case fileType::PixelizedNoise:
        if (assoc->exists(fileType::PixelizedNoise))
          data = assoc->pixelizedNoise();
        break;
      case fileType::PixelizedFilter:
        if (assoc->exists(fileType::PixelizedFilter))
          data = assoc->pixelizedFilter();
        break;
      case fileType::PixelizedBeam:
        if (assoc->exists(fileType::PixelizedBeam))
          data = assoc->pixelizedBeam();
        break;
    }
  }
  else
    throw incompleteDatasetError;

  // check to make sure everything loaded correctly
  if (dataType != fileType::PixelOccupancy)
  {
    if (!(hits && data))
      throw incompleteDatasetError;

    if (data->rows() != hits->rows())
      throw dataMismatchError;
  }
  else
    if (!hits)
      throw incompleteDatasetError;

  // store the old data before overwriting
  vectorData<double> *oldPixel(data);

  // store the max and min values
  double maxValue = 0.0;
  double minValue = 0.0;

  double average = assoc->pixelAverage();
  double denom = assoc->pixelVariance();
  const double scale = 1.0;

  if(useMean)
    denom = average;

  for(int pixelIndex = 0; pixelIndex < data->rows(); pixelIndex += 1)
  {
    (*data)[pixelIndex] = (((*data)[pixelIndex] - average) / denom) * scale;

    if((*data)[pixelIndex] > maxValue)
      maxValue = (*data)[pixelIndex];

    if((*data)[pixelIndex] < minValue)
      minValue = (*data)[pixelIndex];
  }

  if(data->maxValue() != maxValue)
      data->maxValue(maxValue);

  if(data->minValue() != minValue)
      data->minValue(minValue);

  return oldPixel;
}

vectorData<double>* HealPIXPixelizer::minmaxNormalize(FILETYPE dataType, association* assoc, double newMin, double newMax)
{
  vectorData<int> *hits = 0;
  vectorData<double> *data = 0;

  // load requisite data sets
  if (assoc->exists(fileType::PixelOccupancy))
    hits = assoc->pixelOccupancy();
  else
    throw incompleteDatasetError;

  if (dataType >= fileType::PixelizedData && dataType <= fileType::PixelizedBeam)
  {
    switch (dataType) {
      case fileType::PixelizedData:
        if (assoc->exists(fileType::PixelizedData))
          data = assoc->pixelizedData();
        break;
      case fileType::PixelizedWeights:
        if (assoc->exists(fileType::PixelizedWeights))
          data = assoc->pixelizedWeights();
        break;
      case fileType::PixelizedNoise:
        if (assoc->exists(fileType::PixelizedNoise))
          data = assoc->pixelizedNoise();
        break;
      case fileType::PixelizedFilter:
        if (assoc->exists(fileType::PixelizedFilter))
          data = assoc->pixelizedFilter();
        break;
      case fileType::PixelizedBeam:
        if (assoc->exists(fileType::PixelizedBeam))
          data = assoc->pixelizedBeam();
        break;
    }
  }
  else
    throw incompleteDatasetError;

  // check to make sure everything loaded correctly
  if (dataType != fileType::PixelOccupancy)
  {
    if (!(hits && data))
      throw incompleteDatasetError;

    if (data->rows() != hits->rows())
      throw dataMismatchError;
  }
  else
    if (!hits)
      throw incompleteDatasetError;

  // store the old data before overwriting
  vectorData<double> *oldPixel(data);

  // store the max and min values
  double maxValue = data->maxValue();
  double minValue = data->minValue();
  double dataMax = 0;
  double dataMin = 100;

  for(int pixelIndex = 0; pixelIndex < data->rows(); pixelIndex += 1)
  {
    double numerator = (*data)[pixelIndex] - minValue;
    double denom     = maxValue - minValue;
    double rescale   = newMax - newMin;
    (*data)[pixelIndex] = (numerator/denom) * rescale + newMin;

    if((*data)[pixelIndex] > dataMax)
      dataMax = (*data)[pixelIndex];

    if((*data)[pixelIndex] < dataMin)
      dataMin = (*data)[pixelIndex];
  }

  data->maxValue(dataMax);
  data->minValue(dataMin);

  return oldPixel;
}

baseData* HealPIXPixelizer::calculateAverageVector(FILETYPE dataType, association* assoc) {
  vectorData<double>* oldData = 0;
  vectorData<int>* oldOcc = 0;
  vectorData<int> *hits = 0;
  vectorData<double> *data = 0;
  vectorData<double> *weights = 0;

  // load requisite data sets
  if (assoc->exists(fileType::PixelOccupancy))
    hits = assoc->pixelOccupancy();
  else
    throw incompleteDatasetError;

  if (dataType >= fileType::PixelizedData && dataType <= fileType::PixelizedBeam)
  {
    if (assoc->exists(fileType::PixelizedWeights))
      weights = assoc->pixelizedWeights();
      //weights = new vectorData<double>(assoc->pixelizedWeights());
    switch (dataType)
    {
      case fileType::PixelizedData:
        if (assoc->exists(fileType::PixelizedData))
          data = assoc->pixelizedData();
          //data = new vectorData<double>(assoc->pixelizedData());
        break;
      case fileType::PixelizedWeights:
        if (assoc->exists(fileType::PixelizedWeights))
          data = assoc->pixelizedWeights();
          //data = new vectorData<double>(assoc->pixelizedWeights());
        break;
      case fileType::PixelizedNoise:
        if (assoc->exists(fileType::PixelizedNoise))
          data = assoc->pixelizedNoise();
          //data = new vectorData<double>(assoc->pixelizedNoise());
        break;
      case fileType::PixelizedFilter:
        if (assoc->exists(fileType::PixelizedFilter))
          data = assoc->pixelizedFilter();
          //data = new vectorData<double>(assoc->pixelizedFilter());
        break;
      case fileType::PixelizedBeam:
        if (assoc->exists(fileType::PixelizedBeam))
          data = assoc->pixelizedBeam();
          //data = new vectorData<double>(assoc->pixelizedBeam());
        break;
    }
  }
  else
    throw incompleteDatasetError;

  if (dataType == fileType::PixelOccupancy)
    oldOcc = new vectorData<int>(hits->rows());
  else
    oldData = new vectorData<double>(hits->rows());

  // check to make sure everything loaded correctly
  if (dataType != fileType::PixelOccupancy) {
    if (!(hits && (data || weights)))
      throw incompleteDatasetError;
    if (weights) {
      if (data->rows() != weights->rows() || data->rows() != hits->rows() || weights->rows() != hits->rows())
        throw dataMismatchError;
    }
    else
    {
      if (data->rows() != hits->rows())
        throw dataMismatchError;
    }
  }
  else
  {
    if (!(hits && weights))
      throw incompleteDatasetError;

    if (weights->rows() != hits->rows())
      throw dataMismatchError;
  }

  // In general, calculate average by dividing the (weighted) data and number of data points per pixel
  // then the two. Have to treat the occupancy average different, however, as that would be the sum of the occupancy
  // divided by the number of pixels
  /*
   *original no division so how is this calculating an average?
  long nPixels = hits->rows();
  for (int row = 0;row < nPixels;++row) {
    if (dataType == fileType::PixelOccupancy) {
      if (weights)
        (*occAverage)[row] += (*hits)[row] * (*weights)[row];
      else
        (*occAverage)[row] += (*hits)[row];
    }
    else {
      if(data) {
        if(weights)
          (*dataAverage)[row] += (*data)[row] * (*weights)[row];
        else
          (*dataAverage)[row] += (*data)[row];
      }
      else if (weights)
        (*dataAverage)[row] += (*weights)[row];
      else
        throw incompleteDatasetError;
    }
  }
  */

  int maxValue = 0;
  int minValue = 100;

  long nPixels = hits->rows();
  for (int row = 0; row < nPixels; row += 1)
  {
    if (dataType == fileType::PixelOccupancy) // pixel average should be divided by how many pixels there are
    {
      if (weights)
        //(*occAverage)[row] += ((*hits)[row] * (*weights)[row]) / nPixels;
        //(*hits)[row] += ((*hits)[row] * (*weights)[row]) / nPixels;
        (*hits)[row] = ((*hits)[row] * (*weights)[row]) / nPixels;
      else
        //(*oldOcc)[row] += (*hits)[row] / nPixels;
        //(*hits)[row] += (*hits)[row] / nPixels;
        (*hits)[row] = (*hits)[row] / nPixels;

      if((*hits)[row] > maxValue) // if((oldOcc)[row] > maxValue) maxValue = (*oldOcc)[row];
        maxValue = (*hits)[row];

      if((*hits)[row] < minValue) // if((oldOcc)[row] < minValue) minValue = (*oldOcc)[row];
        minValue = (*hits)[row];
    }
    else
    {
      if(data && dataType != fileType::PixelizedWeights) // data average should be divided by how many items got mapped to it
      {
        int denom = (*hits)[row];
        if(!denom)
          denom = 1;

        if(weights)
          //(*oldData)[row] += ((*data)[row] * (*weights)[row]) / denom;
          //(*data)[row] += ((*data)[row] * (*weights)[row]) / denom;
          (*data)[row] = ((*data)[row] * (*weights)[row]) / denom;
        else
          //(*oldData)[row] += (*data)[row] / denom;
          //(*data)[row] += (*data)[row] / denom;
          (*data)[row] = (*data)[row] / denom;

        // if((*oldData)[row] > maxValue) maxValue = (*oldData)[row];
        if((*data)[row] > maxValue)
          maxValue = (*data)[row];

        // if((*oldData)[row] < minValue) minValue = (*oldData)[row];
        if((*data)[row] < minValue)
          minValue = (*data)[row];
      }
      else if(data && dataType == fileType::PixelizedWeights)
      {
        int denom = (*hits)[row];
        if(!denom)
          denom = 1;

        //(*oldData)[row] += (*weights)[row] / denom;
        //(*data)[row] += (*weights)[row] / denom;
        (*data)[row] = (*data)[row] / denom;

        //if((*oldData)[row] > maxValue) maxValue = (*oldData)[row];
        if((*data)[row] > maxValue)
          maxValue = (*data)[row];

        //if((*oldData)[row] < minValue) minValue = (*oldData)[row];
        if((*data)[row] < minValue)
          minValue = (*data)[row];
      }
      else if (weights)
      {
        int denom = (*hits)[row];
        if(!denom)
          denom = 1;

        //(*oldData)[row] += (*weights)[row] / denom;
        //(*data)[row] += (*weights)[row] / denom;
        (*data)[row] = (*weights)[row] / denom;

        //if((*oldData)[row] > maxValue) maxValue = (*oldData)[row];
        if((*data)[row] > maxValue)
          maxValue = (*data)[row];

        //if((*oldData)[row] < minValue) minValue = (*oldData)[row];
        if((*data)[row] < minValue)
          minValue = (*data)[row];

      }
      else
        throw incompleteDatasetError;
    }
  }

  if (dataType == fileType::PixelOccupancy)
  {
    if(hits->maxValue() != maxValue)
      hits->maxValue(maxValue);

    if(hits->minValue() != minValue)
      hits->minValue(minValue);

    return (baseData*)oldOcc;
  }
  else
  {
    if(data->maxValue() != maxValue)
      data->maxValue(maxValue);

    if(data->minValue() != minValue)
      data->minValue(minValue);

    return (baseData*)oldData;
  }
}

baseData* HealPIXPixelizer::calculateDevianceVector(FILETYPE dataType, association* assoc)
{
vectorData<double>* oldData = 0;
  vectorData<int>* oldOcc = 0;
  vectorData<int> *hits = 0;
  vectorData<double> *data = 0;
  vectorData<double> *weights = 0;

  // load requisite data sets
  if (assoc->exists(fileType::PixelOccupancy))
    hits = assoc->pixelOccupancy();
  else
    throw incompleteDatasetError;

  if (dataType >= fileType::PixelizedData && dataType <= fileType::PixelizedBeam)
  {
    if (assoc->exists(fileType::PixelizedWeights))
      weights = assoc->pixelizedWeights();
      //weights = new vectorData<double>(assoc->pixelizedWeights());
    switch (dataType)
    {
      case fileType::PixelizedData:
        if (assoc->exists(fileType::PixelizedData))
          data = assoc->pixelizedData();
          //data = new vectorData<double>(assoc->pixelizedData());
        break;
      case fileType::PixelizedWeights:
        if (assoc->exists(fileType::PixelizedWeights))
          data = assoc->pixelizedWeights();
          //data = new vectorData<double>(assoc->pixelizedWeights());
        break;
      case fileType::PixelizedNoise:
        if (assoc->exists(fileType::PixelizedNoise))
          data = assoc->pixelizedNoise();
          //data = new vectorData<double>(assoc->pixelizedNoise());
        break;
      case fileType::PixelizedFilter:
        if (assoc->exists(fileType::PixelizedFilter))
          data = assoc->pixelizedFilter();
          //data = new vectorData<double>(assoc->pixelizedFilter());
        break;
      case fileType::PixelizedBeam:
        if (assoc->exists(fileType::PixelizedBeam))
          data = assoc->pixelizedBeam();
          //data = new vectorData<double>(assoc->pixelizedBeam());
        break;
    }
  }
  else
    throw incompleteDatasetError;

  if (dataType == fileType::PixelOccupancy)
    oldOcc = new vectorData<int>(hits->rows());
  else
    oldData = new vectorData<double>(hits->rows());

  // check to make sure everything loaded correctly
  if (dataType != fileType::PixelOccupancy) {
    if (!(hits && (data || weights)))
      throw incompleteDatasetError;
    if (weights) {
      if (data->rows() != weights->rows() || data->rows() != hits->rows() || weights->rows() != hits->rows())
        throw dataMismatchError;
    }
    else
    {
      if (data->rows() != hits->rows())
        throw dataMismatchError;
    }
  }
  else
  {
    if (!(hits && weights))
      throw incompleteDatasetError;

    if (weights->rows() != hits->rows())
      throw dataMismatchError;
  }

  // In general, calculate average by dividing the (weighted) data and number of data points per pixel
  // then the two. Have to treat the occupancy average different, however, as that would be the sum of the occupancy
  // divided by the number of pixels
  /*
   *original no division so how is this calculating an average?
  long nPixels = hits->rows();
  for (int row = 0;row < nPixels;++row) {
    if (dataType == fileType::PixelOccupancy) {
      if (weights)
        (*occAverage)[row] += (*hits)[row] * (*weights)[row];
      else
        (*occAverage)[row] += (*hits)[row];
    }
    else {
      if(data) {
        if(weights)
          (*dataAverage)[row] += (*data)[row] * (*weights)[row];
        else
          (*dataAverage)[row] += (*data)[row];
      }
      else if (weights)
        (*dataAverage)[row] += (*weights)[row];
      else
        throw incompleteDatasetError;
    }
  }
  */

  int maxValue = 0;
  int minValue = 100;

  double average = calculateAverage(dataType, assoc);
  long nPixels = hits->rows();
  for (int row = 0; row < nPixels; row += 1)
  {
    if (dataType == fileType::PixelOccupancy) // pixel average should be divided by how many pixels there are
    {
      if (weights)
        //(*occAverage)[row] += ((*hits)[row] * (*weights)[row]) - average;
        //(*hits)[row] += ((*hits)[row] * (*weights)[row]) - average;
        (*hits)[row] = ((*hits)[row] * (*weights)[row]) - average;
      else
        //(*oldOcc)[row] += (*hits)[row] - average;
        //(*hits)[row] += (*hits)[row] - average;
        (*hits)[row] = (*hits)[row] - average;

      if((*hits)[row] > maxValue) // if((oldOcc)[row] > maxValue) maxValue = (*oldOcc)[row];
        maxValue = (*hits)[row];

      if((*hits)[row] < minValue) // if((oldOcc)[row] < minValue) minValue = (*oldOcc)[row];
        minValue = (*hits)[row];
    }
    else
    {
      if(data && dataType != fileType::PixelizedWeights) // data average should be divided by how many items got mapped to it
      {
        int denom = (*hits)[row];
        if(!denom)
          denom = 1;

        if(weights)
          //(*oldData)[row] += ((*data)[row] * (*weights)[row]) - average;
          //(*data)[row] += ((*data)[row] * (*weights)[row]) - average;
          (*data)[row] = ((*data)[row] * (*weights)[row]) - average;
        else
          //(*oldData)[row] += (*data)[row] - average;
          //(*data)[row] += (*data)[row] - average;
          (*data)[row] = (*data)[row] - average;

        // if((*oldData)[row] > maxValue) maxValue = (*oldData)[row];
        if((*data)[row] > maxValue)
          maxValue = (*data)[row];

        // if((*oldData)[row] < minValue) minValue = (*oldData)[row];
        if((*data)[row] < minValue)
          minValue = (*data)[row];
      }
      else if(data && dataType == fileType::PixelizedWeights)
      {
        int denom = (*hits)[row];
        if(!denom)
          denom = 1;

        //(*oldData)[row] += (*weights)[row] - average;
        //(*data)[row] += (*weights)[row] - average;
        (*data)[row] = (*data)[row] - average;

        //if((*oldData)[row] > maxValue) maxValue = (*oldData)[row];
        if((*data)[row] > maxValue)
          maxValue = (*data)[row];

        //if((*oldData)[row] < minValue) minValue = (*oldData)[row];
        if((*data)[row] < minValue)
          minValue = (*data)[row];
      }
      else if (weights)
      {
        int denom = (*hits)[row];
        if(!denom)
          denom = 1;

        //(*oldData)[row] += (*weights)[row] - average;
        //(*data)[row] += (*weights)[row] - average;
        (*data)[row] = (*weights)[row] - average;

        //if((*oldData)[row] > maxValue) maxValue = (*oldData)[row];
        if((*data)[row] > maxValue)
          maxValue = (*data)[row];

        //if((*oldData)[row] < minValue) minValue = (*oldData)[row];
        if((*data)[row] < minValue)
          minValue = (*data)[row];

      }
      else
        throw incompleteDatasetError;
    }
  }

  if (dataType == fileType::PixelOccupancy)
  {
    if(hits->maxValue() != maxValue)
      hits->maxValue(maxValue);

    if(hits->minValue() != minValue)
      hits->minValue(minValue);

    return (baseData*)oldOcc;
  }
  else
  {
    if(data->maxValue() != maxValue)
      data->maxValue(maxValue);

    if(data->minValue() != minValue)
      data->minValue(minValue);

    return (baseData*)oldData;
  }
}

baseData* HealPIXPixelizer::calculateVarianceVector(FILETYPE dataType, association* assoc) {
  vectorData<int> *hits = 0;
  vectorData<double> *data = 0;

  // load requisite data sets
  if (assoc->exists(fileType::PixelOccupancy))
    hits = assoc->pixelOccupancy();
  else
    throw incompleteDatasetError;

  if (dataType >= fileType::PixelizedData && dataType <= fileType::PixelizedBeam)
  {
    switch (dataType)
    {
     case fileType::PixelizedData:
       if (assoc->exists(fileType::PixelizedData))
         data = assoc->pixelizedData();
       break;
     case fileType::PixelizedWeights:
       if (assoc->exists(fileType::PixelizedWeights))
         data = assoc->pixelizedWeights();
       break;
     case fileType::PixelizedNoise:
       if (assoc->exists(fileType::PixelizedNoise))
         data = assoc->pixelizedNoise();
       break;
     case fileType::PixelizedFilter:
       if (assoc->exists(fileType::PixelizedFilter))
         data = assoc->pixelizedFilter();
       break;
     case fileType::PixelizedBeam:
       if (assoc->exists(fileType::PixelizedBeam))
         data = assoc->pixelizedBeam();
       break;
    }
  }

  // check to make sure everything loaded correctly
  if (dataType != fileType::PixelOccupancy) {
    if (!(hits && data))
      throw incompleteDatasetError;
    if (data->rows() != hits->rows())
      throw dataMismatchError;
  }
  else
    if (!hits)
      throw incompleteDatasetError;

  // calculate variance as the sum of the squared difference between the value in the pixel and the average,
  // then divide the sum by either the total number of pixels (pixelOccupancy) or data points (all others), minus 1
  long nPixels = hits->rows();
  double average = calculateAverage(dataType, assoc);

  vectorData<double>* oldData(data);
  vectorData<int>*    oldOcc(hits);

  int maxValue = 0.0;
  int minValue = 100;
  for (int row = 0;row < nPixels;++row)
  {
    if (dataType == fileType::PixelOccupancy)
    {
      //(*oldOcc)[row] = sqrt((((*hits)[row] - average) * ((*hits)[row] - average)) / (nPixels - 1));
      (*hits)[row] = sqrt((((*hits)[row] - average) * ((*hits)[row] - average)) / (nPixels -1));

      //if( (*oldOCc)[row] > maxValue) maxValue = (*oldOcc)[row];
      if((*hits)[row] > maxValue)
        maxValue = (*hits)[row];

      //if((*oldOcc)[row] < minValue) minValue = (*oldOcc)[row];
      if((*hits)[row] < minValue)
        minValue = (*hits)[row];
    }
    else
    {
      int denom = (*hits)[row]-1;
      if(denom < 1)
        denom = 1;

      //(*dataVariance)[row] = sqrt((((*data)[row] - average) * ((*data)[row] - average)) / denom);
      (*data)[row] = sqrt((((*data)[row] - average) * ((*data)[row] - average)) / denom);

      //if( (*oldData)[row] > maxValue) maxValue = (*oldData)[row];
      if((*data)[row] > maxValue)
        maxValue = (*data)[row];

      //if((*oldData)[row] < minValue) minValue = (*oldData)[row];
      if((*data)[row] < minValue)
        minValue = (*data)[row];
    }
  }

  if(dataType == FILETYPE::PixelOccupancy)
  {
    //if(oldOcc->maxValue() != maxValue) oldOcc->maxValue(maxValue);
    if(hits->maxValue() != maxValue)
      hits->maxValue(maxValue);

    //if(oldOcc->minValue() != minValue) oldOcc->minValue(minValue);
    if(hits->minValue() != minValue)
      hits->minValue(minValue);

    return (baseData*)oldOcc;
  }
  else
  {
    //if(oldData->maxValue() != maxValue) oldData->maxValue(maxValue);
    if(data->maxValue() != maxValue)
      data->maxValue(maxValue);

    //if(oldData->minValue() != minValue) oldData->minValue(minValue);
    if(data->minValue() != minValue)
      data->minValue(minValue);

    return (baseData*)oldData;
  }
}

double HealPIXPixelizer::resolution(int sides) {
  double result = 360.0 / (sides * sqrt(12.0*M_PI));
  return(result);
}

int HealPIXPixelizer::psuedoSides(double resolution) {
  int result = (int)(360.0 / (resolution * sqrt(12.0*M_PI)));
  return result;
}

double HealPIXPixelizer::pixelArea(bool radFlag) {
      double area = 4 * M_PI / (12 * m_sides * m_sides);
      if (radFlag)
        return area;
      else
        return area * (M_PI / 180.0) * (M_PI / 180.0);
}

