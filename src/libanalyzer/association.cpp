/***************************************************************************
 *   association.cpp                                                       *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * The association class collects all of the various data objects together *
 * for easy checking of the data chain as well as the associated action    *
 * engines for generating additional steps.                                *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#include <cstdarg>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>

#include "atypes.h"
#include "association.h"
#include "vectordata.h"
#include "matrixdata.h"
#include "inputmatrixdata.h"
#include "cubedata.h"
#include "pixelizer.h"
#include "healpix.h"
#include "transformer.h"
#include "rsht.h"
#include "spectrum.h"
#include "filemanager.h"
#include "fitsmanager.h"
#include "/mnt/research/software/CAPS-Analyzer/src/libanalyzer/hdf5manager.h"
#include "csvmanager.h"
#include "../libgraphics/dataspectrum.h"
#include "../libgraphics/datamap.h"
#include "../libgraphics/mapper.h"
#include "../libgraphics/mollweide.h"
#include "../libgraphics/grapher.h"

association::association() {
  m_uiObject = 0;
  m_updateFunc = 0;
  m_showProgress = false;

  m_pixelAverage = 0;
  m_pixelVariance = 0;

  m_workSpace = 0;
  m_tmpSpace = 0;
  m_inputData = 0;
  m_inputWeights = 0;
  m_weightedInput = 0;
  m_inputFilter = 0;
  m_inputBeam = 0;
  m_inputNoise = 0;
  m_weightedNoise = 0;

  m_pixelData = 0;
  m_pixelWeights = 0;
  m_weightedPixel = 0;
  m_pixelOccupancy = 0;
  m_pixelFilter = 0;
  m_pixelBeam = 0;
  m_pixelNoise = 0;
  m_pixelWeightedNoise = 0;

  m_invData = 0;
  m_invWeights = 0;
  m_weightedInverse = 0;
  m_invFilter = 0;
  m_invBeam = 0;
  m_invNoise = 0;
  m_invWeightedNoise = 0;

  m_transData = 0;
  m_transWeights = 0;
  m_transFilter = 0;
  m_transNoise = 0;
  m_transBeam = 0;
  m_weightedTransform = 0;
  m_transWeightedNoise = 0;

  m_ensembleAveragedNoise = 0;
  m_ensembleIterationNoise = 0;
  m_ensembleAveragedSpectrum = 0;
  m_ensembleIterationSpectrum = 0;
  m_binnedSpectrum = 0;
  m_ensembleAveragedBinnedSpectrum = 0;
  m_ensembleIterationBinnedSpectrum = 0;

  //m_spectData = 0;
  //m_ensembleSpectData = 0;

  m_almData = 0;
  m_almWeights = 0;
  m_weightedAlm = 0;
  m_almFilter = 0;
  m_almBeam = 0;
  m_almNoise = 0;
  m_weightedNoiseAlm = 0;

  //m_couplingMatrix = 0;
  //m_inverseMatrix = 0;
  m_ModeModeMatrix = 0;
  m_InstrumentEffectsMatrix = 0;
  m_BinningMatrix = 0;
  m_UnbinningMatrix = 0;
  m_BinnedInstrumentEffectsMatrix = 0;
  m_InverseBinnedInstrumentMatrix = 0;

  m_inputDataMap = 0;
  m_inputWeightsMap = 0;
  m_weightedInputMap = 0;
  m_inputMap = 0;
  m_inputNoiseMap = 0;
  m_inputFilterMap = 0;
  m_inputBeamMap = 0;
  m_weightedNoiseMap = 0;

  m_pixelDataMap = 0;
  m_pixelWeightsMap = 0;
  m_weightedPixelMap = 0;
  m_pixelMap = 0;
  m_pixelOccupancyMap = 0;
  m_pixelNoiseMap = 0;
  m_pixelFilterMap = 0;
  m_pixelBeamMap = 0;
  m_pixelWeightedNoiseMap = 0;

  m_invDataMap = 0;
  m_invWeightsMap = 0;
  m_weightedInverseMap = 0;
  m_invMap = 0;
  m_invNoiseMap = 0;
  m_invFilterMap = 0;
  m_invBeamMap = 0;
  m_invWeightedNoiseMap = 0;
  
  m_transDataGraph = 0;
  m_transWeightsGraph = 0;
  m_weightedTransformGraph = 0;
  m_transGraph = 0;
  m_spectDataGraph = 0;
  m_ensembleDataGraph = 0;
  m_transFilterGraph = 0;
  m_transNoiseGraph = 0;
  m_transBeamGraph = 0;
  m_transWeightedNoiseGraph = 0;
  m_ensembleAveragedNoiseGraph = 0;
  m_ensembleAveragedSpectrumGraph = 0;
  m_binnedSpectrumGraph = 0;
  m_ensembleAveragedBinnedSpectrumGraph = 0;

  m_fileIOEngine = 0;
  m_mapEngine = 0;
  m_graphEngine = 0;
  m_pixelEngine = 0;
  m_transformEngine = 0;
  m_powSpectEngine = 0;

  m_selectedIOEngine = None;
  m_selectedMapEngine = Blank;
  m_selectedPixelEngine = NotPixelized;
  m_selectedTransformEngine = NotTransformed;
  m_sequence = noSky;
}

association::association(association* from) {
  m_inputData         = new matrixData<double>(from->inputData());
  m_inputWeights      = new matrixData<double>(from->inputWeights());
  m_weightedInput     = new matrixData<double>(from->weightedInput());
  m_inputFilter       = new matrixData<double>(from->inputFilter());
  m_inputNoise        = new matrixData<double>(from->inputNoise());
  m_inputBeam         = new matrixData<double>(from->inputBeam());
  m_weightedNoise     = new matrixData<double>(from->weightedInputNoise());

  m_pixelData         = new vectorData<double>(from->pixelizedData());
  m_pixelWeights      = new vectorData<double>(from->pixelizedWeights());
  m_weightedPixel     = new vectorData<double>(from->weightedPixel());
  m_pixelOccupancy    = new vectorData<int>(from->pixelOccupancy());
  m_pixelFilter       = new vectorData<double>(from->pixelizedFilter());
  m_pixelNoise        = new vectorData<double>(from->pixelizedNoise());
  m_pixelBeam         = new vectorData<double>(from->pixelizedBeam());
  m_pixelWeightedNoise= new vectorData<double>(from->weightedPixelizedNoise());

  m_invData           = new vectorData<double>(from->inverseData());
  m_invWeights        = new vectorData<double>(from->inverseWeights());
  m_weightedInverse   = new vectorData<double>(from->weightedInverse());
  m_invNoise          = new vectorData<double>(from->inverseNoise());
  m_invFilter         = new vectorData<double>(from->inverseFilter());
  m_invBeam           = new vectorData<double>(from->inverseBeam());
  m_invWeightedNoise  = new vectorData<double>(from->weightedInverseNoise());

  m_transData         = new vectorData<double>(from->transformedData());
  m_transWeights      = new vectorData<double>(from->transformedWeights());
  m_weightedTransform = new vectorData<double>(from->weightedTransform());
  m_transFilter       = new vectorData<double>(from->transformedFilter());
  m_transNoise        = new vectorData<double>(from->transformedNoise());
  m_transBeam         = new vectorData<double>(from->transformedBeam());
  m_transWeightedNoise= new vectorData<double>(from->weightedTransformedNoise());

  m_ensembleAveragedNoise           = new vectorData<double>(from->EnsembleAveragedNoise());
  m_ensembleIterationNoise          = new matrixData<double>(from->EnsembleIterationNoise());
  m_ensembleAveragedSpectrum        = new vectorData<double>(from->EnsembleAveragedSpectrum());
  m_ensembleIterationSpectrum       = new matrixData<double>(from->EnsembleIterationSpectrum());
  m_binnedSpectrum                  = new vectorData<double>(from->BinnedSpectrum());
  m_ensembleAveragedBinnedSpectrum  = new vectorData<double>(from->EnsembleAveragedBinnedSpectrum());
  m_ensembleIterationBinnedSpectrum = new matrixData<double>(from->EnsembleIterationBinnedSpectrum());
  m_ModeModeMatrix                  = new matrixData<double>(from->ModeModeMatrix());
  m_InstrumentEffectsMatrix         = new matrixData<double>(from->InstrumentEffectsMatrix());
  m_BinningMatrix                   = new matrixData<double>(from->BinningMatrix());
  m_UnbinningMatrix                 = new matrixData<double>(from->UnbinningMatrix());
  m_BinnedInstrumentEffectsMatrix   = new matrixData<double>(from->BinnedInstrumentEffectsMatrix());
  m_InverseBinnedInstrumentMatrix   = new matrixData<double>(from->InverseBinnedInstrumentMatrix());

  //m_spectData         = new vectorData<double>(from->spectrumData());
  //m_ensembleSpectData = new vectorData<double>(from->ensembleData());
  //m_couplingMatrix  = new matrixData<double>(from->couplingMatrix());
  //m_inverseMatrix   = new matrixData<double>(from->inverseMatrix());
  m_almData         = new cubeData<std::complex<double> >(from->almData());
  m_almWeights      = new cubeData<std::complex<double> >(from->almWeights());
  m_weightedAlm     = new cubeData<std::complex<double> >(from->weightedAlm());
  m_almNoise        = new cubeData<std::complex<double> >(from->almNoise());
  m_almFilter       = new cubeData<std::complex<double> >(from->almFilter());
  m_almBeam         = new cubeData<std::complex<double> >(from->almBeam());
  m_weightedNoiseAlm= new cubeData<std::complex<double> >(from->weightedAlmNoise());

  m_inputDataMap      = new dataMap(from->inputDataMap());
  m_inputWeightsMap   = new dataMap(from->inputWeightsMap());
  m_weightedInputMap  = new dataMap(from->weightedInputMap());
  m_inputMap          = new dataMap(from->inputMap());
  m_inputNoiseMap     = new dataMap(from->inputNoiseMap());
  m_inputFilterMap    = new dataMap(from->inputFilterMap());
  m_inputBeamMap      = new dataMap(from->inputBeamMap());
  m_weightedNoiseMap  = new dataMap(from->weightedNoiseMap());

  m_pixelDataMap          = new dataMap(from->pixelDataMap());
  m_pixelWeightsMap       = new dataMap(from->pixelWeightsMap());
  m_weightedPixelMap      = new dataMap(from->weightedPixelMap());
  m_pixelMap              = new dataMap(from->pixelMap());
  m_pixelOccupancyMap     = new dataMap(from->pixelOccupancyMap());
  m_pixelNoiseMap         = new dataMap(from->pixelNoiseMap());
  m_pixelFilterMap        = new dataMap(from->pixelFilterMap());
  m_pixelBeamMap          = new dataMap(from->pixelBeamMap());
  m_pixelWeightedNoiseMap = new dataMap(from->pixelWeightedNoiseMap());

  m_invDataMap          = new dataMap(from->invDataMap());
  m_invWeightsMap       = new dataMap(from->invWeightsMap());
  m_weightedInverseMap  = new dataMap(from->weightedInverseMap());
  m_invMap              = new dataMap(from->invMap());
  m_invNoiseMap         = new dataMap(from->invNoiseMap());
  m_invFilterMap        = new dataMap(from->invFilterMap());
  m_invBeamMap          = new dataMap(from->invBeamMap());
  m_invWeightedNoiseMap = new dataMap(from->invWeightedNoiseMap());

  
  m_transDataGraph         = new dataSpectrum(from->transDataGraph());
  m_transWeightsGraph      = new dataSpectrum(from->transWeightsGraph());
  m_weightedTransformGraph = new dataSpectrum(from->weightedTransformGraph());
  m_transGraph             = new dataSpectrum(from->transGraph());
  //m_spectDataGraph         = new dataSpectrum(from->spectrumGraph());
  //m_ensembleDataGraph      = new dataSpectrum(from->ensembleGraph());
  m_transFilterGraph       = new dataSpectrum(from->transFilterGraph());
  m_transNoiseGraph        = new dataSpectrum(from->transNoiseGraph());
  m_transBeamGraph         = new dataSpectrum(from->transBeamGraph());
  m_transWeightedNoiseGraph= new dataSpectrum(from->transWeightedNoiseGraph());

  m_ensembleAveragedNoiseGraph          = new dataSpectrum(from->EnsembleAveragedNoiseGraph());
  m_ensembleAveragedSpectrumGraph       = new dataSpectrum(from->EnsembleAveragedSpectrumGraph());
  m_binnedSpectrumGraph                 = new dataSpectrum(from->BinnedSpectrumGraph());
  m_ensembleAveragedBinnedSpectrumGraph = new dataSpectrum(from->EnsembleAveragedBinnedSpectrumGraph());

  m_selectedIOEngine        = from->fileIOEngineType();
  m_selectedMapEngine       = from->mappingEngineType();
  m_selectedPixelEngine     = from->pixelizationEngineType();
  m_selectedTransformEngine = from->transformationEngineType();
  m_sequence                = from->sequenceStep();

  if (from->fileIOEngine()->fileFormat() == CSV)
    m_fileIOEngine    = new csvManager((csvManager*)(from->fileIOEngine()));
  else if (from->fileIOEngine()->fileFormat() == Fits)
    m_fileIOEngine    = new fitsManager((fitsManager*)(from->fileIOEngine()));
  else
    m_fileIOEngine    = 0;

  if (from->mappingEngine()->layout() == Mollweide)
    m_mapEngine         = new MollweideMapper((MollweideMapper*)(from->mappingEngine()));
  else
    m_mapEngine         = 0;

  m_graphEngine = from->graphingEngine();
  if (from->pixelizationEngine()->pixelizerScheme() == HealPIX)
    m_pixelEngine      = new HealPIXPixelizer((HealPIXPixelizer*)(from->pixelizationEngine()));
  else
    m_pixelEngine      = 0;

  if (from->transformationEngine()->transformerScheme() == Rsht)
    m_transformEngine  = new RshtTransformer((RshtTransformer*)(from->transformationEngine()));
  else
    m_transformEngine  = 0;

  m_powSpectEngine     = new Spectrum(from->powerSpectraEngine());

//  m_uiObject     = from->userInterface();
//  m_updateFunc   = from->updateFunction();
//  m_showProgress = from->showProgress();
}

association& association::operator=(association& other) {
  *m_inputData         = *other.inputData();
  *m_inputWeights      = *other.inputWeights();
  *m_weightedInput     = *other.weightedInput();
  *m_inputNoise        = *other.inputNoise();
  *m_inputFilter       = *other.inputFilter();
  *m_inputBeam         = *other.inputBeam();
  *m_weightedNoise     = *other.weightedInputNoise();

  *m_pixelData         = *other.pixelizedData();
  *m_pixelWeights      = *other.pixelizedWeights();
  *m_weightedPixel     = *other.weightedPixel();
  *m_pixelOccupancy    = *other.pixelOccupancy();
  *m_pixelFilter       = *other.pixelizedFilter();
  *m_pixelNoise        = *other.pixelizedNoise();
  *m_pixelBeam         = *other.pixelizedBeam();
  *m_pixelWeightedNoise= *other.weightedPixelizedNoise();

  *m_invData           = *other.inverseData();
  *m_invWeights        = *other.inverseWeights();
  *m_weightedInverse   = *other.weightedInverse();
  *m_invNoise          = *other.inverseNoise();
  *m_invFilter         = *other.inverseFilter();
  *m_invBeam           = *other.inverseBeam();
  *m_invWeightedNoise  = *other.weightedInverseNoise();

  *m_transData         = *other.transformedData();
  *m_transWeights      = *other.transformedWeights();
  *m_weightedTransform = *other.weightedTransform();
  *m_transFilter       = *other.transformedFilter();
  *m_transNoise        = *other.transformedNoise();
  *m_transBeam         = *other.transformedBeam();
  *m_transWeightedNoise= *other.weightedTransformedNoise();

  *m_ensembleAveragedNoise           = *other.EnsembleAveragedNoise();
  *m_ensembleIterationNoise          = *other.EnsembleIterationNoise();
  *m_ensembleAveragedSpectrum        = *other.EnsembleAveragedSpectrum();
  *m_ensembleIterationSpectrum       = *other.EnsembleIterationSpectrum();
  *m_binnedSpectrum                  = *other.BinnedSpectrum();
  *m_ensembleAveragedBinnedSpectrum  = *other.EnsembleAveragedBinnedSpectrum();
  *m_ensembleIterationBinnedSpectrum = *other.EnsembleIterationBinnedSpectrum();
  *m_ModeModeMatrix                  = *other.ModeModeMatrix();
  *m_InstrumentEffectsMatrix         = *other.InstrumentEffectsMatrix();
  *m_BinningMatrix                   = *other.BinningMatrix();
  *m_UnbinningMatrix                 = *other.UnbinningMatrix();
  *m_BinnedInstrumentEffectsMatrix   = *other.BinnedInstrumentEffectsMatrix();
  *m_InverseBinnedInstrumentMatrix   = *other.InverseBinnedInstrumentMatrix();

  //*m_spectData         = *other.spectrumData();
  //*m_ensembleSpectData = *other.ensembleData();
  //*m_couplingMatrix    = *other.couplingMatrix();
  //*m_inverseMatrix     = *other.inverseMatrix();
  *m_almData           = *other.almData();
  *m_almWeights        = *other.almWeights();
  *m_weightedAlm       = *other.weightedAlm();
  *m_almFilter         = *other.almFilter();
  *m_almBeam           = *other.almBeam();
  *m_almNoise          = *other.almNoise();
  *m_weightedNoiseAlm  = *other.weightedAlmNoise();

  *m_inputDataMap      = *other.inputDataMap();
  *m_inputWeightsMap   = *other.inputWeightsMap();
  *m_inputMap          = *other.inputMap();
  *m_weightedInputMap  = *other.weightedInputMap();
  *m_inputNoiseMap     = *other.inputNoiseMap();
  *m_inputFilterMap    = *other.inputFilterMap();
  *m_inputBeamMap      = *other.inputBeamMap();
  *m_weightedNoiseMap  = *other.weightedNoiseMap();

  *m_pixelDataMap          = *other.pixelDataMap();
  *m_pixelWeightsMap       = *other.pixelWeightsMap();
  *m_weightedPixelMap      = *other.weightedPixelMap();
  *m_pixelMap              = *other.pixelMap();
  *m_pixelOccupancyMap     = *other.pixelOccupancyMap();
  *m_pixelNoiseMap         = *other.pixelNoiseMap();
  *m_pixelFilterMap        = *other.pixelFilterMap();
  *m_pixelBeamMap          = *other.pixelBeamMap();
  *m_pixelWeightedNoiseMap = *other.pixelWeightedNoiseMap();

  *m_invDataMap          = *other.invDataMap();
  *m_invWeightsMap       = *other.invWeightsMap();
  *m_weightedInverseMap  = *other.weightedInverseMap();
  *m_invMap              = *other.invMap();
  *m_invNoiseMap         = *other.invNoiseMap();
  *m_invFilterMap        = *other.invFilterMap();
  *m_invBeamMap          = *other.invBeamMap();
  *m_invWeightedNoiseMap = *other.invWeightedNoiseMap();

  *m_transDataGraph          = *other.transDataGraph();
  *m_transWeightsGraph       = *other.transWeightsGraph();
  *m_weightedTransformGraph  = *other.weightedTransformGraph();
  *m_transGraph              = *other.transGraph();
  //*m_spectDataGraph        = *other.spectrumGraph();
  //*m_ensembleDataGraph     = *other.ensembleGraph();
  *m_transFilterGraph        = *other.transFilterGraph();
  *m_transNoiseGraph         = *other.transNoiseGraph();
  *m_transBeamGraph          = *other.transBeamGraph();
  *m_transWeightedNoiseGraph = *other.transWeightedNoiseGraph();

  *m_ensembleAveragedNoiseGraph          = *other.EnsembleAveragedNoiseGraph();
  *m_ensembleAveragedSpectrumGraph       = *other.EnsembleAveragedSpectrumGraph();
  *m_binnedSpectrumGraph                 = *other.BinnedSpectrumGraph();
  *m_ensembleAveragedBinnedSpectrumGraph = *other.EnsembleAveragedBinnedSpectrumGraph();

  *m_fileIOEngine      = *other.fileIOEngine();
  *m_mapEngine         = *other.mappingEngine();
  *m_graphEngine       = *other.graphingEngine();
  *m_pixelEngine       = *other.pixelizationEngine();
  *m_transformEngine   = *other.transformationEngine();
  *m_powSpectEngine    = *other.powerSpectraEngine();

  m_selectedIOEngine        = other.fileIOEngineType();
  m_selectedMapEngine       = other.mappingEngineType();
  m_selectedPixelEngine     = other.pixelizationEngineType();
  m_selectedTransformEngine = other.transformationEngineType();
  m_sequence                = other.sequenceStep();

//  m_uiObject          = other.userInterface();
//  m_updateFunc        = other.updateFunction();
//  m_showProgress        = other.showProgress();

  return *this;
}

association& association::merge(association& other, bool replace) {
  if (replace)
    *this = other;

  else
  {
    if (!exists(fileType::InputData) && other.exists(fileType::InputData))
      m_inputData = new matrixData<double>(other.inputData());

    if (!exists(fileType::InputWeights) && other.exists(fileType::InputWeights))
      m_inputWeights = new matrixData<double>(other.inputWeights());

    if (!exists(fileType::WeightedData) && other.exists(fileType::WeightedData))
      m_weightedInput = new matrixData<double>(other.weightedInput());

    if (!exists(fileType::InputFilter) && other.exists(fileType::InputFilter))
      m_inputFilter = new matrixData<double>(other.inputFilter());

    if (!exists(fileType::InputNoise) && other.exists(fileType::InputNoise))
      m_inputNoise = new matrixData<double>(other.inputNoise());

    if (!exists(fileType::InputBeam) && other.exists(fileType::InputBeam))
      m_inputBeam = new matrixData<double>(other.inputBeam());

    if (!exists(fileType::InputWeightedNoise) && other.exists(fileType::InputWeightedNoise))
      m_weightedNoise = new matrixData<double>(other.weightedInputNoise());

    if(!exists(fileType::PixelizedData) && other.exists(fileType::PixelizedData))
      m_pixelData = new vectorData<double>(other.pixelizedData());

    if (!exists(fileType::PixelizedWeights) && other.exists(fileType::PixelizedWeights))
      m_pixelWeights = new vectorData<double>(other.pixelizedWeights());

    if (!exists(fileType::WeightedPixel) && other.exists(fileType::WeightedPixel))
      m_pixelWeights = new vectorData<double>(other.weightedPixel());

    if (!exists(fileType::PixelOccupancy) && other.exists(fileType::PixelOccupancy))
      m_pixelOccupancy = new vectorData<int>(other.pixelOccupancy());

    if (!exists(fileType::PixelizedFilter) && other.exists(fileType::PixelizedFilter))
      m_pixelFilter = new vectorData<double>(other.pixelizedFilter());

    if (!exists(fileType::PixelizedNoise) && other.exists(fileType::PixelizedNoise))
      m_pixelNoise = new vectorData<double>(other.pixelizedNoise());

    if (!exists(fileType::PixelizedWeightedNoise) && other.exists(fileType::PixelizedWeightedNoise))
      m_pixelWeightedNoise = new vectorData<double>(other.weightedPixelizedNoise());

    if (!exists(fileType::PixelizedBeam) && other.exists(fileType::PixelizedBeam))
      m_pixelBeam = new vectorData<double>(other.pixelizedBeam());

    if (!exists(fileType::InverseData) && other.exists(fileType::InverseData))
      m_invData = new vectorData<double>(other.inverseData());

    if (!exists(fileType::InverseWeights) && other.exists(fileType::InverseWeights))
      m_invWeights = new vectorData<double>(other.inverseWeights());

    if (!exists(fileType::WeightedInverse) && other.exists(fileType::WeightedInverse))
      m_weightedInverse = new vectorData<double>(other.weightedInverse());

    if (!exists(fileType::InverseFilter) && other.exists(fileType::InverseFilter))
      m_invFilter = new vectorData<double>(other.inverseFilter());

    if (!exists(fileType::InverseNoise) && other.exists(fileType::InverseNoise))
      m_invNoise = new vectorData<double>(other.inverseNoise());

    if (!exists(fileType::InverseWeightedNoise) && other.exists(fileType::InverseWeightedNoise))
      m_invWeightedNoise = new vectorData<double>(other.weightedInverseNoise());

    if (!exists(fileType::InverseBeam) && other.exists(fileType::InverseBeam))
      m_invBeam = new vectorData<double>(other.inverseBeam());

    if (!exists(fileType::TransformedData) && other.exists(fileType::TransformedData))
      m_transData = new vectorData<double>(other.transformedData());

    if (!exists(fileType::TransformedWeights) && other.exists(fileType::TransformedWeights))
      m_transWeights = new vectorData<double>(other.transformedWeights());

    if (!exists(fileType::WeightedTransform) && other.exists(fileType::WeightedTransform))
      m_weightedTransform = new vectorData<double>(other.weightedTransform());

    if (!exists(fileType::TransformedFilter) && other.exists(fileType::TransformedFilter))
      m_transFilter = new vectorData<double>(other.transformedFilter());

    if (!exists(fileType::TransformedNoise) && other.exists(fileType::TransformedNoise))
      m_transNoise = new vectorData<double>(other.transformedNoise());

    if (!exists(fileType::TransformedWeightedNoise) && other.exists(fileType::TransformedWeightedNoise))
      m_transWeightedNoise = new vectorData<double>(other.weightedTransformedNoise());

    if (!exists(fileType::TransformedBeam) && other.exists(fileType::TransformedBeam))
      m_transBeam = new vectorData<double>(other.transformedBeam());

    /*
    if (!exists(fileType::SpectralData) && other.exists(fileType::SpectralData))
      m_spectData = new vectorData<double>(other.spectrumData());

    if (!exists(fileType::EnsembleData) && other.exists(fileType::EnsembleData))
      m_ensembleSpectData = new vectorData<double>(other.ensembleData());

    if ((   !exists(fileType::BinCouplingMatrix) && other.exists(fileType::BinCouplingMatrix))
        && (!exists(fileType::ModeCouplingMatrix) && other.exists(fileType::ModeCouplingMatrix)))
      m_couplingMatrix = new matrixData<double>(other.couplingMatrix());

    if ((   !exists(fileType::InverseBinMatrix) && other.exists(fileType::InverseBinMatrix))
        && (!exists(fileType::InverseModeMatrix) && other.exists(fileType::InverseModeMatrix)))
      m_inverseMatrix = new matrixData<double>(other.inverseMatrix());
    */

    if(!exists(fileType::EnsembleAveragedNoise) && other.exists(fileType::EnsembleAveragedNoise))
      m_ensembleAveragedNoise = new vectorData<double>(other.EnsembleAveragedNoise());

    if(!exists(fileType::EnsembleIterationNoise) && other.exists(fileType::EnsembleIterationNoise))
      m_ensembleIterationNoise = new matrixData<double>(other.EnsembleIterationNoise());

    if(!exists(fileType::EnsembleAveragedSpectrum) && other.exists(fileType::EnsembleAveragedSpectrum))
      m_ensembleAveragedSpectrum = new vectorData<double>(other.EnsembleAveragedSpectrum());

    if(!exists(fileType::EnsembleIterationSpectrum) && other.exists(fileType::EnsembleIterationSpectrum))
      m_ensembleIterationSpectrum = new matrixData<double>(other.EnsembleIterationSpectrum());

    if(!exists(fileType::BinnedSpectrum) && other.exists(fileType::BinnedSpectrum))
      m_binnedSpectrum = new vectorData<double>(other.BinnedSpectrum());

    if(!exists(fileType::EnsembleAveragedBinnedSpectrum) && other.exists(fileType::EnsembleAveragedBinnedSpectrum))
      m_ensembleAveragedBinnedSpectrum = new vectorData<double>(other.EnsembleAveragedBinnedSpectrum());

    if(!exists(fileType::EnsembleIterationBinnedSpectrum) && other.exists(fileType::EnsembleIterationBinnedSpectrum))
      m_ensembleIterationBinnedSpectrum = new matrixData<double>(other.EnsembleIterationBinnedSpectrum());

    if(!exists(fileType::ModeModeMatrix) && other.exists(fileType::ModeModeMatrix))
      m_ModeModeMatrix = new matrixData<double>(other.ModeModeMatrix());

    if(!exists(fileType::InstrumentEffectsMatrix) && other.exists(fileType::InstrumentEffectsMatrix))
      m_InstrumentEffectsMatrix = new matrixData<double>(other.InstrumentEffectsMatrix());

    if(!exists(fileType::BinningMatrix) && other.exists(fileType::BinningMatrix))
      m_BinningMatrix = new matrixData<double>(other.BinningMatrix());

    if(!exists(fileType::UnbinningMatrix) && other.exists(fileType::UnbinningMatrix))
      m_UnbinningMatrix = new matrixData<double>(other.UnbinningMatrix());

    if(!exists(fileType::BinnedInstrumentEffectsMatrix) && other.exists(fileType::BinnedInstrumentEffectsMatrix))
      m_BinnedInstrumentEffectsMatrix = new matrixData<double>(other.BinnedInstrumentEffectsMatrix());

    if(!exists(fileType::InverseBinnedInstrumentMatrix) && other.exists(fileType::InverseBinnedInstrumentMatrix))
      m_InverseBinnedInstrumentMatrix = new matrixData<double>(other.InverseBinnedInstrumentMatrix());

    if (!exists(fileType::AlmData) && other.exists(fileType::AlmData))
      m_almData = new cubeData<std::complex<double> >(other.almData());

    if (!exists(fileType::AlmWeights) && other.exists(fileType::AlmWeights))
      m_almWeights = new cubeData<std::complex<double> >(other.almWeights());

    if (!exists(fileType::WeightedAlm) && other.exists(fileType::WeightedAlm))
      m_weightedAlm = new cubeData<std::complex<double>>(other.weightedAlm());

    if (!exists(fileType::AlmFilter) && other.exists(fileType::AlmFilter))
      m_almFilter = new cubeData<std::complex<double> >(other.almFilter());

    if (!exists(fileType::AlmNoise) && other.exists(fileType::AlmNoise))
      m_almNoise = new cubeData<std::complex<double> >(other.almNoise());

    if (!exists(fileType::AlmWeightedNoise) && other.exists(fileType::AlmWeightedNoise))
      m_weightedNoiseAlm = new cubeData<std::complex<double> >(other.weightedAlmNoise());

    if (!exists(fileType::AlmBeam) && other.exists(fileType::AlmBeam))
      m_almBeam = new cubeData<std::complex<double> >(other.almBeam());
  


    if (!exists(associatedMap::InputDataMap) && other.exists(associatedMap::InputDataMap))
      m_inputDataMap = new dataMap(other.inputDataMap());

    if (!exists(associatedMap::InputWeightsMap) && other.exists(associatedMap::InputWeightsMap))
      m_inputWeightsMap = new dataMap(other.inputWeightsMap());

    if (!exists(associatedMap::WeightedDataMap) && other.exists(associatedMap::WeightedDataMap))
      //m_weightedInputMap = new dataMap(other.weightedInputMap());
      m_inputMap = new dataMap(other.inputMap());

    if (!exists(associatedMap::InputNoiseMap) && other.exists(associatedMap::InputNoiseMap))
      m_inputNoiseMap = new dataMap(other.inputNoiseMap());

    if (!exists(associatedMap::InputWeightedNoiseMap) && other.exists(associatedMap::InputWeightedNoiseMap))
      m_weightedInputMap = new dataMap(other.weightedNoiseMap());

    if (!exists(associatedMap::InputFilterMap) && other.exists(associatedMap::InputFilterMap))
      m_inputFilterMap = new dataMap(other.inputFilterMap());

    if (!exists(associatedMap::InputBeamMap) && other.exists(associatedMap::InputBeamMap))
      m_inputBeamMap = new dataMap(other.inputBeamMap());

    if (!exists(associatedMap::PixelizedDataMap) && other.exists(associatedMap::PixelizedDataMap))
      m_pixelDataMap = new dataMap(other.pixelDataMap());

    if (!exists(associatedMap::PixelizedWeightsMap) && other.exists(associatedMap::PixelizedWeightsMap))
      m_pixelWeightsMap = new dataMap(other.pixelWeightsMap());

    if (!exists(associatedMap::WeightedPixelMap) && other.exists(associatedMap::WeightedPixelMap))
      m_pixelMap = new dataMap(other.pixelMap());

    if(!exists(associatedMap::PixelOccupancyMap) && other.exists(associatedMap::PixelOccupancyMap))
      m_pixelOccupancyMap = new dataMap(other.pixelOccupancyMap());

    if (!exists(associatedMap::PixelizedNoiseMap) && other.exists(associatedMap::PixelizedNoiseMap))
      m_pixelNoiseMap = new dataMap(other.pixelNoiseMap());

    if (!exists(associatedMap::PixelizedWeightedNoiseMap) && other.exists(associatedMap::PixelizedWeightedNoiseMap))
      m_pixelWeightedNoiseMap = new dataMap(other.pixelWeightedNoiseMap());

    if (!exists(associatedMap::PixelizedFilterMap) && other.exists(associatedMap::PixelizedFilterMap))
      m_pixelFilterMap = new dataMap(other.pixelFilterMap());

    if (!exists(associatedMap::PixelizedBeamMap) && other.exists(associatedMap::PixelizedBeamMap))
      m_pixelBeamMap = new dataMap(other.pixelBeamMap());

    if (!exists(associatedMap::InverseDataMap) && other.exists(associatedMap::InverseDataMap))
      m_invDataMap = new dataMap(other.invDataMap());

    if (!exists(associatedMap::InverseWeightsMap) && other.exists(associatedMap::InverseWeightsMap))
      m_invWeightsMap = new dataMap(other.invWeightsMap());

    if (!exists(associatedMap::WeightedInverseMap) && other.exists(associatedMap::WeightedInverseMap))
      m_invMap = new dataMap(other.invMap());

    if (!exists(associatedMap::InverseNoiseMap) && other.exists(associatedMap::InverseNoiseMap))
      m_invNoiseMap = new dataMap(other.invNoiseMap());

    if (!exists(associatedMap::InverseWeightedNoiseMap) && other.exists(associatedMap::InverseWeightedNoiseMap))
      m_invWeightedNoiseMap = new dataMap(other.invWeightedNoiseMap());

    if (!exists(associatedMap::InverseFilterMap) && other.exists(associatedMap::InverseFilterMap))
      m_invFilterMap = new dataMap(other.invFilterMap());

    if (!exists(associatedMap::InverseBeamMap) && other.exists(associatedMap::InverseBeamMap))
      m_invBeamMap = new dataMap(other.invBeamMap());

    if (!exists(associatedSpectrum::TransformedDataSpectrum) && other.exists(associatedSpectrum::TransformedDataSpectrum))
      m_transDataGraph = new dataSpectrum(other.transDataGraph());

    if (!exists(associatedSpectrum::TransformedWeightsSpectrum) && other.exists(associatedSpectrum::TransformedWeightsSpectrum))
      m_transWeightsGraph = new dataSpectrum(other.transWeightsGraph());

    if (!exists(associatedSpectrum::WeightedTransformSpectrum) && other.exists(associatedSpectrum::WeightedTransformSpectrum))
      m_transGraph = new dataSpectrum(other.transGraph());

    /*
    if (!exists(associatedSpectrum::SpectralDataSpectrum) && other.exists(associatedSpectrum::SpectralDataSpectrum))
      m_spectDataGraph = new dataSpectrum(other.spectrumGraph());

    if (!exists(associatedSpectrum::EnsembleDataSpectrum) && other.exists(associatedSpectrum::EnsembleDataSpectrum))
      m_ensembleDataGraph = new dataSpectrum(other.ensembleGraph());
    */

    if (!exists(associatedSpectrum::TransformedFilterSpectrum) && other.exists(associatedSpectrum::TransformedFilterSpectrum))
      m_transFilterGraph = new dataSpectrum(other.transFilterGraph());

    if (!exists(associatedSpectrum::TransformedNoiseSpectrum) && other.exists(associatedSpectrum::TransformedNoiseSpectrum))
      m_transNoiseGraph = new dataSpectrum(other.transNoiseGraph());

    if (!exists(associatedSpectrum::TransformedWeightedNoiseSpectrum) && other.exists(associatedSpectrum::TransformedWeightedNoiseSpectrum))
      m_transWeightedNoiseGraph = new dataSpectrum(other.transWeightedNoiseGraph());

    if (!exists(associatedSpectrum::TransformedBeamSpectrum) && other.exists(associatedSpectrum::TransformedBeamSpectrum))
      m_transBeamGraph = new dataSpectrum(other.transBeamGraph());

    if(!exists(associatedSpectrum::EnsembleAveragedNoiseSpectrum) && other.exists(associatedSpectrum::EnsembleAveragedNoiseSpectrum))
      m_ensembleAveragedNoiseGraph = new dataSpectrum(other.EnsembleAveragedNoiseGraph());

    if(!exists(associatedSpectrum::EnsembleAveragedSpectrumSpectrum) && other.exists(associatedSpectrum::EnsembleAveragedSpectrumSpectrum))
      m_ensembleAveragedSpectrumGraph = new dataSpectrum(other.EnsembleAveragedSpectrumGraph());

    if(!exists(associatedSpectrum::BinnedSpectrumSpectrum) && other.exists(associatedSpectrum::BinnedSpectrumSpectrum))
      m_binnedSpectrumGraph = new dataSpectrum(other.BinnedSpectrumGraph());

    if(!exists(associatedSpectrum::EnsembleAveragedBinnedSpectrumSpectrum) && other.exists(associatedSpectrum::EnsembleAveragedBinnedSpectrumSpectrum))
      m_ensembleAveragedBinnedSpectrumGraph = new dataSpectrum(other.EnsembleAveragedBinnedSpectrumGraph());

    if (!exists(dataEngines::fileIO) && other.exists(dataEngines::fileIO))
    {
      if (other.fileIOEngine()->fileFormat() == CSV)
        m_fileIOEngine = new csvManager((csvManager*)other.fileIOEngine());
      else if (other.fileIOEngine()->fileFormat() == Fits)
        m_fileIOEngine = new fitsManager((fitsManager*)other.fileIOEngine());
    }

    if (!exists(dataEngines::Mapping) && other.exists(dataEngines::Mapping))
      if (other.mappingEngine()->layout() == Mollweide)
        m_mapEngine = new MollweideMapper((MollweideMapper*)other.mappingEngine());

    if (!exists(dataEngines::Graphing) && other.exists(dataEngines::Graphing))
      m_graphEngine = new Grapher(other.graphingEngine());

    if (!exists(dataEngines::Pixelization) && other.exists(dataEngines::Pixelization))
      if (other.pixelizationEngine()->pixelizerScheme() == HealPIX)
        m_pixelEngine = new HealPIXPixelizer((HealPIXPixelizer*)other.pixelizationEngine());

    if (!exists(dataEngines::Transformation) && other.exists(dataEngines::Transformation))
      if (other.transformationEngine()->scheme() == Rsht)
        m_transformEngine = new RshtTransformer((RshtTransformer*)other.transformationEngine());

    if (!exists(dataEngines::PseudoSpectrum) && other.exists(dataEngines::PseudoSpectrum))
      m_powSpectEngine = new Spectrum(other.powerSpectraEngine());

    if (!m_selectedIOEngine && other.fileIOEngineType())
      m_selectedIOEngine = other.fileIOEngineType();

    if (!m_selectedMapEngine && other.mappingEngineType())
      m_selectedMapEngine = other.mappingEngineType();

    if (!m_selectedPixelEngine && other.pixelizationEngineType())
      m_selectedPixelEngine = other.pixelizationEngineType();

    if (!m_selectedTransformEngine && other.transformationEngineType())
      m_selectedTransformEngine = other.transformationEngineType();

    if (!m_sequence && other.sequenceStep())
      m_sequence = other.sequenceStep();

    /*
    if (!m_uiObject && other.userInterface())
      m_uiObject = other.userInterface();
    if (!m_updateFunc && other.updateFunction())
      m_updateFunc = other.updateFunction();
    if (!m_showProgress && other.showProgress())
      m_showProgress = other.showProgress();
    */
  }
  
  return *this;
}

baseData& association::merge (FILETYPE dataType, baseData* other, bool replace) {

  baseData* bdPtr = 0;

  switch (dataType)
  {
    case fileType::InputData:
      if (m_inputData == 0)
        m_inputData = new matrixData<double>((matrixData<double>*)other);
      else {
        if (m_inputData && replace)
          m_inputData = (matrixData<double>*)other;
      }
      bdPtr = m_inputData;
      break;
    case fileType::InputWeights:
      if (m_inputWeights == 0)
        m_inputWeights = new matrixData<double>((matrixData<double>*)other);
      else {
        if (m_inputWeights && replace)
          m_inputWeights = (matrixData<double>*)other;
      }
      bdPtr = m_inputWeights;
      break;
    case fileType::WeightedData:
      if(m_weightedInput == 0)
        m_weightedInput = new matrixData<double>((matrixData<double>*)other);
      else
      {
        if(m_weightedInput && replace)
          m_weightedInput = (matrixData<double>*)other;
      }
      bdPtr = m_weightedInput;
      break;
    case fileType::InputNoise:
      if (m_inputNoise == 0)
        m_inputNoise = new matrixData<double>((matrixData<double>*)other);
      else {
        if (m_inputNoise && replace)
          m_inputNoise = (matrixData<double>*)other;
      }
      bdPtr = m_inputNoise;
      break;
    case fileType::InputWeightedNoise:
      if (m_weightedNoise == 0)
        m_weightedNoise = new matrixData<double>((matrixData<double>*)other);
      else
      {
        if(m_weightedNoise && replace)
          m_weightedNoise = (matrixData<double>*)other;
      }
      bdPtr = m_weightedNoise;
      break;
    case fileType::InputFilter:
      if (m_inputFilter == 0)
        m_inputFilter = new matrixData<double>((matrixData<double>*)other);
      else {
        if (m_inputFilter && replace)
          m_inputFilter = (matrixData<double>*)other;
      }
      bdPtr = m_inputFilter;
      break; //*m_inputFilter;
    case fileType::InputBeam:
      if (m_inputBeam == 0)
        m_inputBeam = new matrixData<double>((matrixData<double>*)other);
      else {
        if (m_inputBeam && replace)
          m_inputBeam = (matrixData<double>*)other;
      }
      bdPtr = m_inputBeam;
      break;
    /*case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
      if (m_couplingMatrix == 0)
        m_couplingMatrix = new matrixData<double>((matrixData<double>*)other);
      else {
        if (m_couplingMatrix && replace)
          m_couplingMatrix = (matrixData<double>*)other;
      }
      bdPtr = m_couplingMatrix;
      break;
    */
    case fileType::PixelizedData:
      if (m_pixelData == 0)
        m_pixelData = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_pixelData && replace)
          m_pixelData = (vectorData<double>*)other;
      }
      bdPtr = m_pixelData;
      break;;
    case fileType::PixelizedWeights:
      if (m_pixelWeights == 0)
        m_pixelWeights = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_pixelWeights && replace)
          m_pixelWeights = (vectorData<double>*)other;
      }
      bdPtr = m_pixelWeights;
      break;
    case fileType::WeightedPixel:
      if(m_weightedPixel == 0)
        m_weightedPixel = new vectorData<double>((vectorData<double>*)other);
      else
      {
        if(m_weightedPixel && replace)
          m_weightedPixel = (vectorData<double>*)other;
      }
      bdPtr = m_weightedPixel;
      break;
    case fileType::PixelizedNoise:
      if (m_pixelNoise == 0)
        m_pixelNoise = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_pixelNoise && replace)
          m_pixelNoise = (vectorData<double>*)other;
      }
      bdPtr = m_pixelNoise;
      break;
    case fileType::PixelizedWeightedNoise:
      if (m_pixelWeightedNoise == 0)
        m_pixelWeightedNoise = new vectorData<double>((vectorData<double>*)other);
      else
      {
        if(m_pixelWeightedNoise && replace)
          m_pixelWeightedNoise = (vectorData<double>*)other;
      }
      bdPtr = m_pixelWeightedNoise;
      break;

    case fileType::PixelizedFilter:
      if (m_pixelFilter == 0)
        m_pixelFilter = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_pixelFilter && replace)
          m_pixelFilter = (vectorData<double>*)other;
      }
      bdPtr = m_pixelFilter;
      break;
    case fileType::PixelizedBeam:
      if (m_pixelBeam == 0)
        m_pixelBeam = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_pixelBeam && replace)
          m_pixelBeam = (vectorData<double>*)other;
      }
      bdPtr = m_pixelBeam;
      break;
    case fileType::PixelOccupancy:
      if (m_pixelOccupancy == 0)
        m_pixelOccupancy = new vectorData<int>((vectorData<int>*)other);
      else {
        if (m_pixelOccupancy && replace)
          m_pixelOccupancy = (vectorData<int>*)other;
      }
      bdPtr = m_pixelOccupancy;
      break;
    case fileType::TransformedData:
      if (m_transData == 0)
        m_transData = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_transData && replace)
          m_transData = (vectorData<double>*)other;
      }
      bdPtr = m_transData;
      break;
    case fileType::TransformedWeights:
      if (m_transWeights == 0)
        m_transWeights = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_transWeights && replace)
          m_transWeights = (vectorData<double>*)other;
      }
      bdPtr = m_transWeights;
      break;
    case fileType::WeightedTransform:
      if(m_weightedTransform == 0)
        m_weightedTransform = new vectorData<double>((vectorData<double>*)other);
      else
      {
        if(m_weightedTransform && replace)
          m_weightedTransform = (vectorData<double>*)other;
      }
      bdPtr = m_weightedTransform;
      break;
    case fileType::TransformedNoise:
      if (m_transNoise == 0)
        m_transNoise = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_transNoise && replace)
          m_transNoise = (vectorData<double>*)other;
      }
      bdPtr = m_transNoise;
      break;
    case fileType::TransformedWeightedNoise:
      if (m_transWeightedNoise == 0)
        m_transWeightedNoise = new vectorData<double>((vectorData<double>*)other);
      else
      {
        if(m_transWeightedNoise && replace)
          m_transWeightedNoise = (vectorData<double>*)other;
      }
      bdPtr = m_transWeightedNoise;
      break;
    case fileType::TransformedFilter:
      if (m_transFilter == 0)
        m_transFilter = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_transFilter && replace)
          m_transFilter = (vectorData<double>*)other;
      }
      bdPtr = m_transFilter;
      break;
    case fileType::TransformedBeam:
      if (m_transBeam == 0)
        m_transBeam = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_transBeam && replace)
          m_transBeam = (vectorData<double>*)other;
      }
      bdPtr = m_transBeam;
      break;
    /*
    case fileType::SpectralData:
      if (m_spectData == 0)
        m_spectData = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_spectData && replace)
          m_spectData = (vectorData<double>*)other;
      }
      bdPtr = m_spectData;
      break;
    case fileType::EnsembleData:
      if (m_ensembleSpectData == 0)
        m_ensembleSpectData = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_ensembleSpectData && replace)
          m_ensembleSpectData = (vectorData<double>*)other;
      }
      bdPtr = m_ensembleSpectData;
      break;
    */
    case fileType::EnsembleAveragedNoise:
      if(m_ensembleAveragedNoise == 0)
        m_ensembleAveragedNoise = new vectorData<double>((vectorData<double>*)other);
      else
      {
        if(m_ensembleAveragedNoise && replace)
          m_ensembleAveragedNoise = (vectorData<double>*)other;
      }
      bdPtr = m_ensembleAveragedNoise;
      break;
    case fileType::EnsembleIterationNoise:
      if(m_ensembleIterationNoise == 0)
        m_ensembleIterationNoise = new matrixData<double>((matrixData<double>*)other);
      else
      {
        if(m_ensembleIterationNoise && replace)
          m_ensembleIterationNoise = (matrixData<double>*)other;
      }
      bdPtr = m_ensembleIterationNoise;
      break;
    case fileType::EnsembleAveragedSpectrum:
      if(m_ensembleAveragedSpectrum == 0)
        m_ensembleAveragedSpectrum = new vectorData<double>((vectorData<double>*)other);
      else
      {
        if(m_ensembleAveragedSpectrum && replace)
          m_ensembleAveragedSpectrum = (vectorData<double>*)other;
      }
      bdPtr = m_ensembleAveragedSpectrum;
      break;
    case fileType::EnsembleIterationSpectrum:
      if(m_ensembleIterationSpectrum == 0)
        m_ensembleIterationSpectrum = new matrixData<double>((matrixData<double>*)other);
      else
      {
        if(m_ensembleIterationSpectrum && replace)
          m_ensembleIterationSpectrum = (matrixData<double>*)other;
      }
      bdPtr = m_ensembleIterationSpectrum;
      break;
    case fileType::BinnedSpectrum:
      if(m_binnedSpectrum == 0)
        m_binnedSpectrum = new vectorData<double>((vectorData<double>*)other);
      else
      {
        if(m_binnedSpectrum && replace)
          m_binnedSpectrum = (vectorData<double>*)other;
      }
      bdPtr = m_binnedSpectrum;
      break;
    case fileType::EnsembleAveragedBinnedSpectrum:
      if(m_ensembleAveragedBinnedSpectrum == 0)
        m_ensembleAveragedBinnedSpectrum = new vectorData<double>((vectorData<double>*)other);
      else
      {
        if(m_ensembleAveragedBinnedSpectrum && replace)
          m_ensembleAveragedBinnedSpectrum = (vectorData<double>*)other;
      }
      bdPtr = m_ensembleAveragedBinnedSpectrum;
      break;
    case fileType::EnsembleIterationBinnedSpectrum:
      if(m_ensembleIterationBinnedSpectrum == 0)
        m_ensembleIterationBinnedSpectrum = new matrixData<double>((matrixData<double>*)other);
      else
      {
        if(m_ensembleIterationBinnedSpectrum && replace)
          m_ensembleIterationBinnedSpectrum = (matrixData<double>*)other;
      }
      bdPtr = m_ensembleIterationBinnedSpectrum;
      break;
    case fileType::ModeModeMatrix:
      if(m_ModeModeMatrix == 0)
        m_ModeModeMatrix = new matrixData<double>((matrixData<double>*)other);
      else
      {
        if(m_ModeModeMatrix && replace)
          m_ModeModeMatrix = (matrixData<double>*)other;
      }
      bdPtr = m_ModeModeMatrix;
      break;
    case fileType::InstrumentEffectsMatrix:
      if(m_InstrumentEffectsMatrix == 0)
        m_InstrumentEffectsMatrix = new matrixData<double>((matrixData<double>*)other);
      else
      {
        if(m_InstrumentEffectsMatrix && replace)
          m_InstrumentEffectsMatrix = (matrixData<double>*)other;
      }
      bdPtr = m_InstrumentEffectsMatrix;
      break;
    case fileType::BinningMatrix:
      if(m_BinningMatrix == 0)
        m_BinningMatrix = new matrixData<double>((matrixData<double>*)other);
      else
      {
        if(m_BinningMatrix && replace)
          m_BinningMatrix = (matrixData<double>*)other;
      }
      bdPtr = m_BinningMatrix;
      break;
    case fileType::UnbinningMatrix:
      if(m_UnbinningMatrix == 0)
        m_UnbinningMatrix = new matrixData<double>((matrixData<double>*)other);
      else
      {
        if(m_UnbinningMatrix && replace)
          m_UnbinningMatrix = (matrixData<double>*)other;
      }
      bdPtr = m_UnbinningMatrix;
      break;
    case fileType::BinnedInstrumentEffectsMatrix:
      if(m_BinnedInstrumentEffectsMatrix == 0)
        m_BinnedInstrumentEffectsMatrix = new matrixData<double>((matrixData<double>*)other);
      else
      {
        if(m_BinnedInstrumentEffectsMatrix && replace)
          m_BinnedInstrumentEffectsMatrix = (matrixData<double>*)other;
      }
      bdPtr = m_BinnedInstrumentEffectsMatrix;
      break;
    case fileType::InverseBinnedInstrumentMatrix:
      if(m_InverseBinnedInstrumentMatrix == 0)
        m_InverseBinnedInstrumentMatrix = new matrixData<double>((matrixData<double>*)other);
      else
      {
        if(m_InverseBinnedInstrumentMatrix && replace)
          m_InverseBinnedInstrumentMatrix = (matrixData<double>*)other;
      }
      bdPtr = m_InverseBinnedInstrumentMatrix;
      break;
    case fileType::InverseData:
      if (m_invData == 0)
        m_invData = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_invData && replace)
          m_invData = (vectorData<double>*)other;
      }
      bdPtr = m_invData;
      break;
    case fileType::InverseWeights:
      if (m_invWeights == 0)
        m_invWeights = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_invWeights && replace)
          m_invWeights = (vectorData<double>*)other;
      }
      bdPtr = m_invWeights;
      break;
    case fileType::WeightedInverse:
      if(m_weightedInverse == 0)
        m_weightedInverse = new vectorData<double>((vectorData<double>*)other);
      else
      {
        if(m_weightedInverse && replace)
          m_weightedInverse = (vectorData<double>*)other;
      }
      bdPtr = m_weightedInverse;
      break;
    case fileType::InverseNoise:
      if (m_invNoise == 0)
        m_invNoise = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_invNoise && replace)
          m_invNoise = (vectorData<double>*)other;
      }
      bdPtr = m_invNoise;
      break;
    case fileType::InverseWeightedNoise:
      if (m_invWeightedNoise == 0)
        m_invWeightedNoise = new vectorData<double>((vectorData<double>*)other);
      else
      {
        if(m_invWeightedNoise && replace)
          m_invWeightedNoise = (vectorData<double>*)other;
      }
      bdPtr = m_invWeightedNoise;
      break;

    case fileType::InverseFilter:
      if (m_invFilter == 0)
        m_invFilter = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_invFilter && replace)
          m_invFilter = (vectorData<double>*)other;
      }
      bdPtr = m_invFilter;
      break;
    case fileType::InverseBeam:
      if (m_invBeam == 0)
        m_invBeam = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_invBeam && replace)
          m_invBeam = (vectorData<double>*)other;
      }
      bdPtr = m_invBeam;
      break;
    case fileType::AlmData:
      if (m_almData == 0)
        m_almData = new cubeData<std::complex<double> >((cubeData<std::complex<double> >*)other);
      else {
        if (m_almData && replace)
          m_almData = (cubeData<std::complex<double> >* )other;
      }
      bdPtr = m_almData;
      break;
    case fileType::AlmWeights:
      if (m_almWeights == 0)
        m_almWeights = new cubeData<std::complex<double> >((cubeData<std::complex<double> >*)other);
      else {
        if (m_almWeights && replace)
          m_almWeights = (cubeData<std::complex<double> >* )other;
      }
      bdPtr = m_almWeights;
      break;
    case fileType::WeightedAlm:
      if(m_weightedAlm == 0)
        m_weightedAlm = new cubeData<std::complex<double>>((cubeData<std::complex<double>>*)other);
      else
      {
        if(m_weightedAlm && replace)
          m_weightedAlm = (cubeData<std::complex<double>>*)other;
      }
      bdPtr = m_weightedAlm;
      break;
    case fileType::AlmNoise:
      if (m_almNoise == 0)
        m_almNoise = new cubeData<std::complex<double> >((cubeData<std::complex<double> >*)other);
      else {
        if (m_almNoise && replace)
          m_almNoise = (cubeData<std::complex<double> >* )other;
      }
      bdPtr = m_almNoise;
      break;
    case fileType::AlmWeightedNoise:
      if (m_weightedNoiseAlm == 0)
        m_weightedNoiseAlm = new cubeData<std::complex<double>>((cubeData<std::complex<double>>*)other);
      else
      {
        if(m_weightedNoiseAlm && replace)
          m_weightedNoiseAlm = (cubeData<std::complex<double>>*)other;
      }
      bdPtr = m_weightedNoiseAlm;
      break;
    case fileType::AlmFilter:
      if (m_almFilter == 0)
        m_almFilter = new cubeData<std::complex<double> >((cubeData<std::complex<double> >*)other);
      else {
        if (m_almFilter && replace)
          m_almFilter = (cubeData<std::complex<double> >* )other;
      }
      bdPtr = m_almFilter;
      break;
    case fileType::AlmBeam:
      if (m_almBeam == 0)
        m_almBeam = new cubeData<std::complex<double> >((cubeData<std::complex<double> >*)other);
      else {
        if (m_almBeam && replace)
          m_almBeam = (cubeData<std::complex<double> >* )other;
      }
      bdPtr = m_almBeam;
      break;
  }

  return *bdPtr;
}

dataMap& association::merge(ASSOCIATEDMAP mapType, dataMap* other, bool replace) {
  dataMap* dmPtr = 0;

  switch (mapType)
  {
    case associatedMap::InputDataMap:
      if (m_inputDataMap == 0)
        m_inputDataMap = new dataMap((dataMap*)other);
      else {
        if (m_inputDataMap && replace)
          m_inputDataMap = other;
      }
      dmPtr = m_inputDataMap;
      break;
    case associatedMap::InputWeightsMap:
      if (m_inputWeightsMap == 0)
        m_inputWeightsMap = new dataMap((dataMap*)other);
      else {
        if (m_inputWeightsMap && replace)
          m_inputWeightsMap = other;
      }
      dmPtr = m_inputWeightsMap;
      break;
    case associatedMap::WeightedDataMap:
      if (m_inputMap == 0)
        m_inputMap = new dataMap((dataMap*)other);
      else {
        if (m_inputMap && replace)
          m_inputMap = other;
      }
      dmPtr = m_inputMap;
      break;
    case associatedMap::InputNoiseMap:
      if (m_inputNoiseMap == 0)
        m_inputNoiseMap = new dataMap((dataMap*)other);
      else {
        if (m_inputNoiseMap && replace)
          m_inputNoiseMap = other;
      }
      dmPtr = m_inputNoiseMap;
      break;
    case associatedMap::InputWeightedNoiseMap:
      if (m_weightedNoiseMap == 0)
        m_weightedNoiseMap = new dataMap((dataMap*)other);
      else
      {
        if (m_weightedNoiseMap && replace)
          m_weightedNoiseMap = other;
      }
      dmPtr = m_weightedNoiseMap;
      break;
    case associatedMap::InputFilterMap:
      if (m_inputFilterMap == 0)
        m_inputFilterMap = new dataMap((dataMap*)other);
      else {
        if (m_inputFilterMap && replace)
          m_inputFilterMap = other;
      }
      dmPtr = m_inputFilterMap;
      break;
    case associatedMap::InputBeamMap:
      if (m_inputBeamMap == 0)
        m_inputBeamMap = new dataMap((dataMap*)other);
      else {
        if (m_inputBeamMap && replace)
          m_inputBeamMap = other;
      }
      dmPtr = m_inputBeamMap;
      break;
    case associatedMap::PixelizedDataMap:
      if (m_pixelDataMap == 0)
        m_pixelDataMap = new dataMap((dataMap*)other);
      else {
        if (m_pixelDataMap && replace)
          m_pixelDataMap = other;
      }
      dmPtr = m_pixelDataMap;
      break;
    case associatedMap::PixelizedWeightsMap:
      if (m_pixelWeightsMap == 0)
        m_pixelWeightsMap = new dataMap((dataMap*)other);
      else {
        if (m_pixelWeightsMap && replace)
          m_pixelWeightsMap = other;
      }
      dmPtr = m_pixelWeightsMap;
      break;
    case associatedMap::WeightedPixelMap:
      if (m_pixelMap == 0)
        m_pixelMap = new dataMap((dataMap*)other);
      else {
        if (m_pixelMap && replace)
          m_pixelMap = other;
      }
      dmPtr = m_pixelMap;
      break;
    case associatedMap::PixelOccupancyMap:
      if (m_pixelOccupancyMap == 0)
        m_pixelOccupancyMap = new dataMap((dataMap*)other);
      else {
        if (m_pixelOccupancyMap && replace)
          m_pixelOccupancyMap = other;
      }
      dmPtr = m_pixelOccupancyMap;
      break;
    case associatedMap::PixelizedNoiseMap:
      if (m_pixelNoiseMap == 0)
        m_pixelNoiseMap = new dataMap((dataMap*)other);
      else {
        if (m_pixelNoiseMap && replace)
          m_pixelNoiseMap = other;
      }
      dmPtr = m_pixelNoiseMap;
      break;
    case associatedMap::PixelizedWeightedNoiseMap:
      if (m_pixelWeightedNoiseMap == 0)
        m_pixelWeightedNoiseMap = new dataMap((dataMap*)other);
      else
      {
        if (m_pixelWeightedNoiseMap && replace)
          m_pixelWeightedNoiseMap = other;
      }
      dmPtr = m_pixelWeightedNoiseMap;
      break;
    case associatedMap::PixelizedFilterMap:
      if (m_pixelFilterMap == 0)
        m_pixelFilterMap = new dataMap((dataMap*)other);
      else {
        if (m_pixelFilterMap && replace)
          m_pixelFilterMap = other;
      }
      dmPtr = m_pixelFilterMap;
      break;
    case associatedMap::PixelizedBeamMap:
      if (m_pixelBeamMap == 0)
        m_pixelBeamMap = new dataMap((dataMap*)other);
      else {
        if (m_pixelBeamMap && replace)
          m_pixelBeamMap = other;
      }
      dmPtr = m_pixelBeamMap;
      break;
    case associatedMap::InverseDataMap:
      if (m_invDataMap == 0)
        m_invDataMap = new dataMap((dataMap*)other);
      else {
        if (m_invDataMap && replace)
          m_invDataMap = other;
      }
      dmPtr = m_invDataMap;
      break;
    case associatedMap::InverseWeightsMap:
      if (m_invWeightsMap == 0)
        m_inputWeightsMap = new dataMap((dataMap*)other);
      else {
        if (m_invWeightsMap && replace)
          m_invWeightsMap = other;
      }
      dmPtr = m_invWeightsMap;
      break;
    case associatedMap::WeightedInverseMap:
      if (m_invMap == 0)
        m_invMap = new dataMap((dataMap*)other);
      else {
        if (m_invMap && replace)
          m_invMap = other;
      }
      dmPtr = m_invMap;
      break;
    case associatedMap::InverseNoiseMap:
      if (m_invNoiseMap == 0)
        m_invNoiseMap = new dataMap((dataMap*)other);
      else {
        if (m_invNoiseMap && replace)
          m_invNoiseMap = other;
      }
      dmPtr = m_invNoiseMap;
      break;
    case associatedMap::InverseWeightedNoiseMap:
      if (m_invWeightedNoiseMap == 0)
        m_invWeightedNoiseMap = new dataMap((dataMap*)other);
      else
      {
        if (m_invWeightedNoiseMap && replace)
          m_invWeightedNoiseMap = other;
      }
      dmPtr = m_invWeightedNoiseMap;
      break;
    case associatedMap::InverseFilterMap:
      if (m_invFilterMap == 0)
        m_invFilterMap = new dataMap((dataMap*)other);
      else {
        if (m_invFilterMap && replace)
          m_invFilterMap = other;
      }
      dmPtr = m_invFilterMap;
      break;
    case associatedMap::InverseBeamMap:
      if (m_invBeamMap == 0)
        m_invBeamMap = new dataMap((dataMap*)other);
      else {
        if (m_invBeamMap && replace)
          m_invBeamMap = other;
      }
      dmPtr = m_invBeamMap;
      break;
  }

  return *dmPtr;
}

dataSpectrum& association::merge(ASSOCIATEDSPECTRUM graphType, dataSpectrum* other, bool replace) {
  dataSpectrum* dsPtr = 0;

  switch (graphType)
  {
    case associatedSpectrum::TransformedDataSpectrum:
      if (m_transDataGraph == 0)
        m_transDataGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_transDataGraph && replace)
          m_transDataGraph = other;
      }
      dsPtr = m_transDataGraph;
      break;
    case associatedSpectrum::TransformedWeightsSpectrum:
      if (m_transWeightsGraph == 0)
        m_transWeightsGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_transWeightsGraph && replace)
          m_transWeightsGraph = other;
      }
      dsPtr = m_transWeightsGraph;
      break;
    case associatedSpectrum::WeightedTransformSpectrum:
      if (m_transGraph == 0)
        m_transGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_transGraph && replace)
          m_transGraph = other;
      }
      dsPtr = m_transGraph;
      break;
    case associatedSpectrum::TransformedNoiseSpectrum:
      if (m_transNoiseGraph == 0)
        m_transNoiseGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_transNoiseGraph && replace)
          m_transNoiseGraph = other;
      }
      dsPtr = m_transNoiseGraph;
      break;
    case associatedSpectrum::TransformedWeightedNoiseSpectrum:
      if (m_transWeightedNoiseGraph == 0)
        m_transWeightedNoiseGraph = new dataSpectrum((dataSpectrum*)other);
      else
      {
        if(m_transWeightedNoiseGraph && replace)
          m_transWeightedNoiseGraph = other;
      }
      dsPtr = m_transWeightedNoiseGraph;
      break;
    case associatedSpectrum::TransformedFilterSpectrum:
      if (m_transFilterGraph == 0)
        m_transFilterGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_transFilterGraph && replace)
          m_transFilterGraph = other;
      }
      dsPtr = m_transFilterGraph;
      break;
    case associatedSpectrum::TransformedBeamSpectrum:
      if (m_transBeamGraph == 0)
        m_transBeamGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_transBeamGraph && replace)
          m_transBeamGraph = other;
      }
      dsPtr = m_transBeamGraph;
      break;
    /*
     case associatedSpectrum::SpectralDataSpectrum:
      if (m_spectDataGraph == 0)
        m_spectDataGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_spectDataGraph && replace)
          m_spectDataGraph = other;
      }
      dsPtr = m_spectDataGraph;
      break;
    case associatedSpectrum::EnsembleDataSpectrum:
      if (m_ensembleDataGraph == 0)
        m_ensembleDataGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_ensembleDataGraph && replace)
          m_ensembleDataGraph = other;
      }
      dsPtr = m_ensembleDataGraph;
      break;
    */
    case associatedSpectrum::EnsembleAveragedNoiseSpectrum:
      if(m_ensembleAveragedNoiseGraph == 0)
        m_ensembleAveragedNoiseGraph = new dataSpectrum((dataSpectrum*)other);
      else
      {
        if(m_ensembleAveragedNoiseGraph && replace)
          m_ensembleAveragedNoiseGraph = other;
      }
      dsPtr = m_ensembleAveragedNoiseGraph;
      break;
    case associatedSpectrum::EnsembleAveragedSpectrumSpectrum:
      if(m_ensembleAveragedSpectrumGraph == 0)
        m_ensembleAveragedSpectrumGraph = new dataSpectrum((dataSpectrum*)other);
      else
      {
        if(m_ensembleAveragedSpectrumGraph && replace)
          m_ensembleAveragedSpectrumGraph = other;
      }
      dsPtr = m_ensembleAveragedSpectrumGraph;
      break;
    case associatedSpectrum::BinnedSpectrumSpectrum:
      if(m_binnedSpectrumGraph == 0)
        m_binnedSpectrumGraph = new dataSpectrum((dataSpectrum*)other);
      else
      {
        if(m_binnedSpectrumGraph && replace)
          m_binnedSpectrumGraph = other;
      }
      dsPtr = m_binnedSpectrumGraph;
      break;
    case associatedSpectrum::EnsembleAveragedBinnedSpectrumSpectrum:
      if(m_ensembleAveragedBinnedSpectrumGraph == 0)
        m_ensembleAveragedBinnedSpectrumGraph = new dataSpectrum((dataSpectrum*)other);
      else
      {
        if(m_ensembleAveragedBinnedSpectrumGraph && replace)
          m_ensembleAveragedBinnedSpectrumGraph = other;
      }
      dsPtr = m_ensembleAveragedBinnedSpectrumGraph;
      break;
  }

  return *dsPtr;
}

Mapper& association::merge(MAPTYPE mapType, Mapper* other, bool replace) {
  Mapper* mapPtr = 0;

  switch (mapType) {
    case Mollweide:
      if (m_mapEngine == 0)
        m_mapEngine = new MollweideMapper((MollweideMapper*)other);
      else {
        if (m_mapEngine && replace)
          m_mapEngine = other;
      }
      mapPtr = m_mapEngine;
      break;
  }

  return *mapPtr;
}

Grapher& association::merge(Grapher* other, bool replace) {
  if (m_graphEngine == 0)
    m_graphEngine = new Grapher(other);
  else {
    if (m_graphEngine && replace)
      m_graphEngine = other;
  }
  return *m_graphEngine;
}

fileManager& association::merge(FORMAT ext, fileManager* other, bool replace) {
  fileManager* fmPtr = 0;

  switch (ext) {
    case Fits:
      if (m_fileIOEngine == 0)
        m_fileIOEngine = new fitsManager((fitsManager*)other);
      else {
        if (m_fileIOEngine && replace)
          m_fileIOEngine = other;
      }
      fmPtr = m_fileIOEngine;
      break;
    case CSV:
      if (m_fileIOEngine == 0)
        m_fileIOEngine = new csvManager((csvManager*)other);
      else {
        if (m_fileIOEngine && replace)
          m_fileIOEngine = other;
      }
      fmPtr = m_fileIOEngine;
      break;
  }

  return *fmPtr;
}

Pixelizer& association::merge(PIXELSCHEME pixType, Pixelizer* other, bool replace) {
  Pixelizer* pixPtr = 0;

  switch (pixType) {
     case HealPIX:
      if (m_pixelEngine == 0)
        m_pixelEngine = new HealPIXPixelizer((HealPIXPixelizer*)other);
      else {
        if (m_pixelEngine && replace)
          m_pixelEngine = other;
      }
      pixPtr = m_pixelEngine;
      break;
  }

  return *pixPtr;
}

Transformer& association::merge(TRANSFORMERSCHEME transType, Transformer* other, bool replace) {
  Transformer* transPtr = 0;

  switch (transType) {
    case Rsht:
      if (m_transformEngine == 0)
        m_transformEngine = new RshtTransformer((RshtTransformer*)other);
      else {
        if (m_transformEngine && replace)
          m_transformEngine = other;
      }
      transPtr = m_transformEngine;
      break;
  }

  return *transPtr;
}

Spectrum& association::merge(Spectrum* other, bool replace) {
  if (m_powSpectEngine == 0)
    m_powSpectEngine = new Spectrum(other);
  else {
    if (m_powSpectEngine && replace)
      m_powSpectEngine = other;
  }
  return *m_powSpectEngine;
}

bool association::exists(FILETYPE ft) {
  switch (ft) {
      case fileType::InputData:
      return (bool) m_inputData;
    case fileType::InputWeights:
      return (bool) m_inputWeights;
    case fileType::WeightedData:
      return (bool) m_weightedInput;
    case fileType::InputFilter:
      return (bool) m_inputFilter;
    case fileType::InputNoise:
      return (bool) m_inputNoise;
    case fileType::InputWeightedNoise:
      return (bool) m_weightedNoise;
    case fileType::InputBeam:
      return (bool) m_inputBeam;

    case fileType::PixelizedData:
      return (bool) m_pixelData;
    case fileType::PixelizedWeights:
      return (bool) m_pixelWeights;
    case fileType::WeightedPixel:
      return (bool) m_weightedPixel;
    case fileType::PixelOccupancy:
      return (bool) m_pixelOccupancy;
    case fileType::PixelizedFilter:
      return (bool) m_pixelFilter;
    case fileType::PixelizedBeam:
      return (bool) m_pixelBeam;
    case fileType::PixelizedNoise:
      return (bool) m_pixelNoise;
    case fileType::PixelizedWeightedNoise:
      return (bool) m_pixelWeightedNoise;

    case fileType::TransformedData:
      return (bool) m_transData;
    case fileType::TransformedWeights:
      return (bool) m_transWeights;
    case fileType::WeightedTransform:
      return (bool) m_weightedTransform;
    case fileType::TransformedNoise:
      return (bool) m_transNoise;
    case fileType::TransformedWeightedNoise:
      return (bool) m_transWeightedNoise;
    case fileType::TransformedFilter:
      return (bool) m_transFilter;
    case fileType::TransformedBeam:
      return (bool) m_transBeam;

    case fileType::AlmData:
      return (bool) m_almData;
    case fileType::AlmWeights:
      return (bool) m_almWeights;
    case fileType::WeightedAlm:
      return (bool) m_weightedAlm;
    case fileType::AlmNoise:
      return (bool) m_almNoise;
    case fileType::AlmWeightedNoise:
      return (bool) m_weightedNoiseAlm;
    case fileType::AlmFilter:
      return (bool) m_almFilter;
    case fileType::AlmBeam:
      return (bool) m_almBeam;

    case fileType::InverseData:
      return (bool) m_invData;
    case fileType::InverseWeights:
      return (bool) m_invWeights;
    case fileType::WeightedInverse:
      return (bool) m_weightedInverse;
    case fileType::InverseFilter:
      return (bool) m_invFilter;
    case fileType::InverseNoise:
      return (bool) m_invNoise;
    case fileType::InverseWeightedNoise:
      return (bool) m_invWeightedNoise;
    case fileType::InverseBeam:
      return (bool) m_invBeam;

    case fileType::EnsembleAveragedNoise:
      return (bool) m_ensembleAveragedNoise;
    case fileType::EnsembleIterationNoise:
      return (bool) m_ensembleIterationNoise;
    case fileType::EnsembleAveragedSpectrum:
      return (bool) m_ensembleAveragedSpectrum;
    case fileType::EnsembleIterationSpectrum:
      return (bool) m_ensembleIterationSpectrum;
    case fileType::BinnedSpectrum:
      return (bool) m_binnedSpectrum;
    case fileType::EnsembleAveragedBinnedSpectrum:
      return (bool) m_ensembleAveragedBinnedSpectrum;
    case fileType::EnsembleIterationBinnedSpectrum:
      return (bool) m_ensembleIterationBinnedSpectrum;
    case fileType::ModeModeMatrix:
      return (bool) m_ModeModeMatrix;
    case fileType::InstrumentEffectsMatrix:
      return (bool) m_InstrumentEffectsMatrix;
    case fileType::BinningMatrix:
      return (bool) m_BinningMatrix;
    case fileType::UnbinningMatrix:
      return (bool) m_UnbinningMatrix;
    case fileType::BinnedInstrumentEffectsMatrix:
      return (bool) m_BinnedInstrumentEffectsMatrix;
    case fileType::InverseBinnedInstrumentMatrix:
      return (bool) m_InverseBinnedInstrumentMatrix;
    /*
    case fileType::SpectralData:
      return (bool) m_spectData;
    case fileType::EnsembleData:
      return (bool) m_ensembleSpectData;
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
      return (bool)m_couplingMatrix && (m_couplingMatrix->dataType() == ft);
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      return (bool)m_inverseMatrix && (m_inverseMatrix->dataType() == ft);
    */
    /*
    // Pseudo targets: these are really dependencies.
    case fileType::WeightedData:
      return (bool) m_inputData && (bool) m_inputWeights;
    case fileType::WeightedPixel:
      return (bool) m_pixelData && (bool) m_pixelWeights;
    case fileType::WeightedTransform:
      return (bool) m_transData && (bool) m_transWeights;
    */
    case fileType::Null:
    default:
      break;
  }
  return false;
}

bool association::exists(ASSOCIATEDMAP mt) {
  switch (mt) {
      case associatedMap::InputDataMap:
      return (bool) m_inputDataMap;
    case associatedMap::InputWeightsMap:
      return (bool) m_inputWeightsMap;
    case associatedMap::InputNoiseMap:
      return (bool) m_inputNoiseMap;
    case associatedMap::InputFilterMap:
      return (bool) m_inputFilterMap;
    case associatedMap::InputBeamMap:
      return (bool) m_inputBeamMap;
    case associatedMap::WeightedDataMap:
      return (bool) m_inputMap;
    case associatedMap::InputWeightedNoiseMap:
      return (bool) m_weightedNoiseMap;

    case associatedMap::PixelizedDataMap:
      return (bool) m_pixelDataMap;
    case associatedMap::PixelizedWeightsMap:
      return (bool) m_pixelWeightsMap;
    case associatedMap::WeightedPixelMap:
      return (bool) m_pixelMap;
    case associatedMap::PixelOccupancyMap:
      return (bool) m_pixelOccupancyMap;
    case associatedMap::PixelizedNoiseMap:
      return (bool) m_pixelNoiseMap;
    case associatedMap::PixelizedFilterMap:
      return (bool) m_pixelFilterMap;
    case associatedMap::PixelizedBeamMap:
      return (bool) m_pixelBeamMap;
    case associatedMap::PixelizedWeightedNoiseMap:
      return (bool) m_pixelWeightedNoiseMap;

    case associatedMap::InverseDataMap:
      return (bool) m_invDataMap;
    case associatedMap::InverseWeightsMap:
      return (bool) m_invWeightsMap;
    case associatedMap::WeightedInverseMap:
      return (bool) m_invMap;
    case associatedMap::InverseNoiseMap:
      return (bool) m_invNoiseMap;
    case associatedMap::InverseFilterMap:
      return (bool) m_invFilterMap;
    case associatedMap::InverseBeamMap:
      return (bool) m_invBeamMap;
    case associatedMap::InverseWeightedNoiseMap:
      return (bool) m_invWeightedNoiseMap;
    case associatedMap::Null:
    default:
      break;
  }
  return false;
}

bool association::exists(ASSOCIATEDSPECTRUM st) {
  switch (st) {
      case associatedSpectrum::TransformedDataSpectrum:
      return (bool) m_transDataGraph;
    case associatedSpectrum::TransformedWeightsSpectrum:
      return (bool) m_transWeightsGraph;
    case associatedSpectrum::WeightedTransformSpectrum:
      return (bool) m_transGraph;
    /*
    case associatedSpectrum::SpectralDataSpectrum:
      return (bool) m_spectDataGraph;
    case associatedSpectrum::EnsembleDataSpectrum:
      return (bool) m_ensembleDataGraph;
    */
    case associatedSpectrum::TransformedFilterSpectrum:
      return (bool) m_transFilterGraph;
    case associatedSpectrum::TransformedNoiseSpectrum:
      return (bool) m_transNoiseGraph;
    case associatedSpectrum::TransformedBeamSpectrum:
      return (bool) m_transBeamGraph;
    case associatedSpectrum::TransformedWeightedNoiseSpectrum:
      return (bool) m_transWeightedNoiseGraph;

    case associatedSpectrum::EnsembleAveragedNoiseSpectrum:
      return (bool) m_ensembleAveragedNoiseGraph;
    case associatedSpectrum::EnsembleAveragedSpectrumSpectrum:
      return (bool) m_ensembleAveragedSpectrumGraph;
    case associatedSpectrum::BinnedSpectrumSpectrum:
      return (bool) m_binnedSpectrumGraph;
    case associatedSpectrum::EnsembleAveragedBinnedSpectrumSpectrum:
      return (bool) m_ensembleAveragedBinnedSpectrumGraph;

    case associatedSpectrum::Null:
    default:
      break;
  }
  return false;
}

bool association::exists(DATAENGINES de) {
  switch (de) {
    case dataEngines::fileIO:
      return (bool) m_fileIOEngine;
    case dataEngines::Mapping:
      return (bool) m_mapEngine;
    case dataEngines::Graphing:
      return (bool) m_graphEngine;
    case dataEngines::Pixelization:
      return (bool) m_pixelEngine;
    case dataEngines::Transformation:
      return (bool) m_transformEngine;
    case dataEngines::PseudoSpectrum:
      return (bool) m_powSpectEngine;

    case dataEngines::Null:
    default:
      break;
  }
  return false;
}

baseData* association::getData(FILETYPE ft) {
  switch (ft) {
    case fileType::InputData:
      return m_inputData;
    case fileType::InputWeights:
      return m_inputWeights;
    case fileType::WeightedData:
      return m_weightedInput;
    case fileType::InputNoise:
      return m_inputNoise;
    case fileType::InputFilter:
      return m_inputFilter;
    case fileType::InputBeam:
      return m_inputBeam;
    case fileType::InputWeightedNoise:
      return m_weightedNoise;

    case fileType::PixelizedData:
      return m_pixelData;
    case fileType::PixelizedWeights:
      return m_pixelWeights;
    case fileType::WeightedPixel:
      return m_weightedPixel;
    case fileType::PixelOccupancy:
      return m_pixelOccupancy;
    case fileType::PixelizedNoise:
      return m_pixelNoise;
    case fileType::PixelizedFilter:
      return m_pixelFilter;
    case fileType::PixelizedBeam:
      return m_pixelBeam;
    case fileType::PixelizedWeightedNoise:
      return m_pixelWeightedNoise;

    case fileType::TransformedData:
      return m_transData;
    case fileType::TransformedWeights:
      return m_transWeights;
    case fileType::WeightedTransform:
      return m_weightedTransform;
    case fileType::TransformedNoise:
      return m_transNoise;
    case fileType::TransformedFilter:
      return m_transFilter;
    case fileType::TransformedBeam:
      return m_transBeam;
    case fileType::TransformedWeightedNoise:
      return m_transWeightedNoise;

    case fileType::AlmData:
      return m_almData;
    case fileType::AlmWeights:
      return m_almWeights;
    case fileType::WeightedAlm:
      return m_weightedAlm;
    case fileType::AlmNoise:
      return m_almNoise;
    case fileType::AlmFilter:
      return m_almFilter;
    case fileType::AlmBeam:
      return m_almBeam;
    case fileType::AlmWeightedNoise:
      return m_weightedNoiseAlm;

    case fileType::InverseData:
      return m_invData;
    case fileType::InverseWeights:
      return m_invWeights;
    case fileType::WeightedInverse:
      return m_weightedInverse;
    case fileType::InverseBeam:
      return m_invBeam;
    case fileType::InverseNoise:
      return m_invNoise;
    case fileType::InverseFilter:
      return m_invFilter;
    case fileType::InverseWeightedNoise:
      return m_invWeightedNoise;
    /*
    case fileType::SpectralData:
      return m_spectData;
    case fileType::EnsembleData:
      return m_ensembleSpectData;
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
      return m_couplingMatrix;
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      return m_inverseMatrix;
    */
    case fileType::EnsembleAveragedNoise:
      return m_ensembleAveragedNoise;
    case fileType::EnsembleIterationNoise:
      return m_ensembleIterationNoise;
    case fileType::EnsembleAveragedSpectrum:
      return m_ensembleAveragedSpectrum;
    case fileType::EnsembleIterationSpectrum:
      return m_ensembleIterationSpectrum;
    case fileType::BinnedSpectrum:
      return m_binnedSpectrum;
    case fileType::EnsembleAveragedBinnedSpectrum:
      return m_ensembleAveragedBinnedSpectrum;
    case fileType::EnsembleIterationBinnedSpectrum:
      return m_ensembleIterationBinnedSpectrum;
    case fileType::ModeModeMatrix:
      return m_ModeModeMatrix;
    case fileType::InstrumentEffectsMatrix:
      return m_InstrumentEffectsMatrix;
    case fileType::BinningMatrix:
      return m_BinningMatrix;
    case fileType::UnbinningMatrix:
      return m_UnbinningMatrix;
    case fileType::BinnedInstrumentEffectsMatrix:
      return m_BinnedInstrumentEffectsMatrix;
    case fileType::InverseBinnedInstrumentMatrix:
      return m_InverseBinnedInstrumentMatrix;

    default:
      break;
  }
  return 0;
}

dataMap* association::getMap(ASSOCIATEDMAP mt) {
  switch (mt) {
      case associatedMap::InputDataMap:
      return m_inputDataMap;
    case associatedMap::InputWeightsMap:
      return m_inputWeightsMap;
    case associatedMap::WeightedDataMap:
      return m_inputMap;
    case associatedMap::InputNoiseMap:
      return m_inputNoiseMap;
    case associatedMap::InputFilterMap:
      return m_inputFilterMap;
    case associatedMap::InputBeamMap:
      return m_inputBeamMap;
    case associatedMap::InputWeightedNoiseMap:
      return m_weightedNoiseMap;

    case associatedMap::PixelizedDataMap:
      return m_pixelDataMap;
    case associatedMap::PixelizedWeightsMap:
      return m_pixelWeightsMap;
    case associatedMap::WeightedPixelMap:
      return m_pixelMap;
    case associatedMap::PixelOccupancyMap:
      return m_pixelOccupancyMap;
    case associatedMap::PixelizedNoiseMap:
      return m_pixelNoiseMap;
    case associatedMap::PixelizedFilterMap:
      return m_pixelFilterMap;
    case associatedMap::PixelizedBeamMap:
      return m_pixelBeamMap;
    case associatedMap::PixelizedWeightedNoiseMap:
      return m_pixelWeightedNoiseMap;

    case associatedMap::InverseDataMap:
      return m_invDataMap;
    case associatedMap::InverseWeightsMap:
      return m_invWeightsMap;
    case associatedMap::WeightedInverseMap:
      return m_invMap;
    case associatedMap::InverseNoiseMap:
      return m_invNoiseMap;
    case associatedMap::InverseFilterMap:
      return m_invFilterMap;
    case associatedMap::InverseBeamMap:
      return m_invBeamMap;
    case associatedMap::InverseWeightedNoiseMap:
      return m_invWeightedNoiseMap;
    case associatedMap::Null:
    default:
      break;
   }
   return 0;
}

dataSpectrum* association::getGraph(ASSOCIATEDSPECTRUM st) {
  switch (st) {
      case associatedSpectrum::TransformedDataSpectrum:
      return m_transDataGraph;
    case associatedSpectrum::TransformedWeightsSpectrum:
      return m_transWeightsGraph;
    case associatedSpectrum::WeightedTransformSpectrum:
      return m_transGraph;
    /*
    case associatedSpectrum::SpectralDataSpectrum:
      return m_spectDataGraph;
    case associatedSpectrum::EnsembleDataSpectrum:
      return m_ensembleDataGraph;
    */
    case associatedSpectrum::TransformedFilterSpectrum:
      return m_transFilterGraph;
    case associatedSpectrum::TransformedNoiseSpectrum:
      return m_transNoiseGraph;
    case associatedSpectrum::TransformedBeamSpectrum:
      return m_transBeamGraph;
    case associatedSpectrum::TransformedWeightedNoiseSpectrum:
      return m_transWeightedNoiseGraph;
    case associatedSpectrum::EnsembleAveragedNoiseSpectrum:
      return m_ensembleAveragedNoiseGraph;
    case associatedSpectrum::EnsembleAveragedSpectrumSpectrum:
      return m_ensembleAveragedSpectrumGraph;
    case associatedSpectrum::BinnedSpectrumSpectrum:
      return m_binnedSpectrumGraph;
    case associatedSpectrum::EnsembleAveragedBinnedSpectrumSpectrum:
      return m_ensembleAveragedBinnedSpectrumGraph;

    case associatedSpectrum::Null:
    default:
      break;
   }
   return 0;
}

void* association::getEngine(DATAENGINES de) {
  switch (de) {
      case dataEngines::fileIO:
        return (void*) m_fileIOEngine;
      case dataEngines::Mapping:
        return (void*) m_mapEngine;
      case dataEngines::Graphing:
        return (void*) m_graphEngine;
      case dataEngines::Pixelization:
        return (void*) m_pixelEngine;
      case dataEngines::Transformation:
        return (void*) m_transformEngine;
      case dataEngines::PseudoSpectrum:
        return (void*) m_powSpectEngine;
      case dataEngines::Null:
      default:
        break;
  }
  return 0;
}

void association::addEngine(DATAENGINES de, ...) {
  ERRORCODES recursiveError = noErrors;

  if (exists(de)) {
    int offset = (int)de + (int)allTypes::EnsembleAveragedBinnedSpectrum;//SpectralDataSpectrum;
    reset((ALLTYPES)offset);
  }

  const char* fileName;
  FILETYPE dataType = fileType::Null;
  FORMAT fileFormat = None;
  MAPTYPE mapType = Blank;
  PIXELSCHEME pixType = NotPixelized;
  TRANSFORMERSCHEME transType = NotTransformed;
  RWMode mode = Read;
  std::va_list args;

  switch (de) {
    case dataEngines::fileIO:
      va_start(args,de);
      fileName = va_arg(args, const char*);
      fileFormat = static_cast<FORMAT>(va_arg(args,int));
      dataType = static_cast<FILETYPE>(va_arg(args,int));
      mode = static_cast<RWMode>(va_arg(args,int));
      va_end(args);
      switch (fileFormat) {
        case Fits:
          if (mode == Read)
            try {
              m_fileIOEngine = new fitsManager(this,fileName,dataType,CCfits::Read);
            }
            catch (ERRORCODES error) {
              recursiveError = error;
            }
          else
            try {
              m_fileIOEngine = new fitsManager(this,fileName,dataType,CCfits::Write);
            }
            catch (ERRORCODES error) {
              recursiveError = error;
            }
          break;
        case HDF5:
          if (mode == Read)
            try
            {
              m_fileIOEngine = new HDF5Manager(this, fileName, dataType, H5RWMode::RDONLY);
            }
            catch(ERRORCODES error)
            {
              recursiveError = error;
            }
          else if(mode == Write)
            try
            {
              m_fileIOEngine = new HDF5Manager(this, fileName, dataType, H5RWMode::RDWR);
            }
            catch(ERRORCODES error)
            {
              recursiveError = error;
            }
          break;
        case CSV:
          try {
            m_fileIOEngine = new csvManager(this,fileName,dataType,mode);
          }
          catch (ERRORCODES error) {
            recursiveError = error;
          }
          break;
      }
      if (recursiveError != noErrors)
        throw recursiveError;

      // write the fileName to the fileIO engine aka save the file name
      m_fileIOEngine->fileName(fileName);
      m_selectedIOEngine = fileFormat;
      break;
    case dataEngines::Mapping:
      va_start(args,de);
      mapType = static_cast<MAPTYPE>(va_arg(args,int));
      va_end(args);
      switch (mapType) {
        case Mollweide:
          m_mapEngine = new MollweideMapper();
          break;
      }
      m_selectedMapEngine = mapType;
      break;
    case dataEngines::Graphing:
      m_graphEngine = new Grapher();
      break;
    case dataEngines::Pixelization:
      va_start(args,de);
      pixType = static_cast<PIXELSCHEME>(va_arg(args,int));
      va_end(args);
      switch (pixType) {
        case HealPIX:
          m_pixelEngine = new HealPIXPixelizer();
          break;
      }
      m_selectedPixelEngine = pixType;
      break;
    case dataEngines::Transformation:
      va_start(args,de);
      transType = static_cast<TRANSFORMERSCHEME>(va_arg(args,int));
      va_end(args);
      switch (transType) {
        case Rsht:
          m_transformEngine = new RshtTransformer();
          break;
      }
      m_selectedTransformEngine = transType;
      break;
    case dataEngines::PseudoSpectrum:
      m_powSpectEngine = new Spectrum();
      break;
  }
}

inputMatrixData* association::workSpace(double resRA, double resDec) {
  if (m_workSpace)
    delete m_workSpace;
  m_workSpace = new inputMatrixData(resRA,resDec);
  m_workSpace->initialize();

  return m_workSpace;
}

inputMatrixData* association::workSpace(inputMatrixData *imd) {
  if (!imd)
    return 0;

  if (m_workSpace)
    delete m_workSpace;

  m_workSpace = imd;

  return m_workSpace;
}

void association::workSpaceTo(FILETYPE type, M_OP operation) {
  if (!m_workSpace)
    return;

  switch (type) {
    case fileType::InputData:
      if (operation == Replace) {
        if (m_inputData)
          delete m_inputData;
        m_inputData = m_workSpace;
        m_workSpace = 0;
      }
      else {
        if (!m_inputData)
          m_inputData = new inputMatrixData(m_workSpace);
        else
          matrixTransfer(m_inputData,m_workSpace,operation);	
      }
      m_inputData->dataType(fileType::InputData);
      m_inputData->mapType(associatedMap::InputDataMap);
      break;
    case fileType::InputWeights:
      if (operation == Replace) {
        if (m_inputWeights)
          delete m_inputWeights;
        m_inputWeights = m_workSpace;
        m_workSpace = 0;
      }
      else {
        if (!m_inputWeights)
          m_inputWeights =  new inputMatrixData(m_workSpace);
        else
          matrixTransfer(m_inputWeights,m_workSpace,operation);
      }
      m_inputWeights->dataType(fileType::InputWeights);
      m_inputWeights->mapType(associatedMap::InputWeightsMap);
      break;
    case fileType::InputNoise:
      if(operation == Replace)
      {
        if(m_inputNoise)
          delete m_inputNoise;
        m_inputNoise = m_workSpace;
        m_workSpace = 0;
      }
      else
      {
        if(!m_inputNoise)
          m_inputNoise = new inputMatrixData(m_workSpace);
        else
          matrixTransfer(m_inputNoise, m_workSpace, operation);
      }
      m_inputNoise->dataType(fileType::InputNoise);
      m_inputNoise->mapType(associatedMap::InputNoiseMap);
      break;
    case fileType::InputFilter:
      if(operation == Replace)
      {
        if(m_inputFilter)
          delete m_inputFilter;
        m_inputFilter = m_workSpace;
        m_workSpace = 0;
      }
      else
      {
        if(!m_inputFilter)
          m_inputFilter = new inputMatrixData(m_workSpace);
        else
          matrixTransfer(m_inputFilter, m_workSpace, operation);
      }
      m_inputFilter->dataType(fileType::InputFilter);
      m_inputFilter->mapType(associatedMap::InputFilterMap);
      break;
    case fileType::InputBeam:
      if(operation == Replace)
      {
        if(m_inputBeam)
          delete m_inputBeam;
        m_inputBeam = m_workSpace;
        m_workSpace = 0;
      }
      else
      {
        if(!m_inputBeam)
          m_inputBeam = new inputMatrixData(m_workSpace);
        else
          matrixTransfer(m_inputBeam, m_workSpace, operation);
      }
      m_inputBeam->dataType(fileType::InputBeam);
      m_inputBeam->mapType(associatedMap::InputBeamMap);
      break;
    default:
      break;
  }
}

void association::matrixTransfer(matrixData<double>* to, matrixData<double>* from, M_OP operation) {
  long row, col;

  if (!from || !to)
    return;

  if (to->cols() < from->cols() || to->rows() < from->rows())
    return;

  col = 0;
  while	(col < from->cols()) {
    row = 0;
    while (row < from->rows()) {
      switch (operation) {
        case Add:
          (*to)[col][row] += (*from)[col][row];
          if ((*to)[col][row] > to->maxValue())
            to->maxValue((*to)[col][row]);
          if ((*to)[col][row] < to->minValue())
            to->minValue((*to)[col][row]);
          break;
        case Subtract:
          (*to)[col][row] -= (*from)[col][row];
          if ((*to)[col][row] > to->maxValue())
            to->maxValue((*to)[col][row]);
          if ((*to)[col][row] < to->minValue())
            to->minValue((*to)[col][row]);
          break;
        case Scale:
          (*to)[col][row] *= (*from)[col][row];
          if ((*to)[col][row] > to->maxValue())
            to->maxValue((*to)[col][row]);
          if ((*to)[col][row] < to->minValue())
            to->minValue((*to)[col][row]);
          break;
        case Replace:
          (*to)[col][row] = (*from)[col][row];
          if ((*to)[col][row] > to->maxValue())
            to->maxValue((*to)[col][row]);
          if ((*to)[col][row] < to->minValue())
            to->minValue((*to)[col][row]);
          break;
        case Invert:
          (*to)[col][row] = from->maxValue()-(*from)[col][row];
          if ((*to)[col][row] > to->maxValue())
            to->maxValue((*to)[col][row]);
          if ((*to)[col][row] < to->minValue())
            to->minValue((*to)[col][row]);
          break;
        case Mirror:
          (*to)[col][row] = (*from)[from->cols()-col][from->rows()-row];
          if ((*to)[col][row] > to->maxValue())
            to->maxValue((*to)[col][row]);
          if ((*to)[col][row] < to->minValue())
            to->minValue((*to)[col][row]);
          break;
        default:
          return;
      }
      row++;
    }
    col++;
  }
}

void association::addEmpty(FILETYPE type, int x, int y, int z) {
  discardRelation(type);

  switch (type) {
    case fileType::InputData:
      m_inputData = new matrixData<double>(x,y,type);
      break;
    case fileType::InputWeights:
      m_inputWeights = new matrixData<double>(x,y,type);
      break;
    case fileType::WeightedData:
      m_weightedInput = new matrixData<double>(x, y, type);
      break;
    case fileType::InputNoise:
      m_inputNoise = new matrixData<double>(x,y,type);
      break;
    case fileType::InputWeightedNoise:
      m_weightedNoise = new matrixData<double>(x, y, type);
      break;
    case fileType::InputFilter:
      m_inputFilter = new matrixData<double>(x,y,type);
      break;
    case fileType::InputBeam:
      m_inputBeam = new matrixData<double>(x,y,type);
      break;

    case fileType::PixelizedData:
      m_pixelData = new vectorData<double>(x,type);
      break;
    case fileType::PixelizedWeights:
      m_pixelWeights = new vectorData<double>(x,type);
      break;
    case fileType::WeightedPixel:
      m_weightedPixel = new vectorData<double>(x, type);
      break;
    case fileType::PixelOccupancy:
      m_pixelOccupancy = new vectorData<int>(x,type);
      break;
    case fileType::PixelizedFilter:
      m_pixelFilter = new vectorData<double>(x,type);
      break;
    case fileType::PixelizedNoise:
      m_pixelNoise = new vectorData<double>(x,type);
      break;
    case fileType::PixelizedWeightedNoise:
      m_pixelWeightedNoise = new vectorData<double>(x, type);
      break;
    case fileType::PixelizedBeam:
      m_pixelBeam = new vectorData<double>(x,type);
      break;

    case fileType::InverseData:
      m_invData = new vectorData<double>(x,type);
      break;
    case fileType::InverseWeights:
      m_invWeights = new vectorData<double>(x,type);
      break;
    case fileType::WeightedInverse:
      m_weightedInverse = new vectorData<double>(x, type);
      break;
    case fileType::InverseFilter:
      m_invFilter = new vectorData<double>(x, type);
      break;
    case fileType::InverseBeam:
      m_invBeam = new vectorData<double>(x, type);
      break;
    case fileType::InverseNoise:
      m_invNoise = new vectorData<double>(x, type);
      break;
    case fileType::InverseWeightedNoise:
      m_invWeightedNoise = new vectorData<double>(x, type);
      break;

    case fileType::TransformedData:
      m_transData = new vectorData<double>(x,type);
      break;
    case fileType::TransformedWeights:
      m_transWeights = new vectorData<double>(x,type);
      break;
    case fileType::WeightedTransform:
      m_weightedTransform = new vectorData<double>(x, type);
      break;
    case fileType::TransformedBeam:
      m_transBeam = new vectorData<double>(x,type);
      break;
    case fileType::TransformedNoise:
      m_transNoise = new vectorData<double>(x,type);
      break;
    case fileType::TransformedWeightedNoise:
      m_transWeightedNoise = new vectorData<double>(x, type);
      break;
    case fileType::TransformedFilter:
      m_transFilter = new vectorData<double>(x,type);
      break;

    case fileType::AlmData:
      m_almData = new cubeData<std::complex<double> >(x,y,z,type);
      break;
    case fileType::AlmWeights:
      m_almWeights = new cubeData<std::complex<double> >(x,y,z,type);
      break;
    case fileType::WeightedAlm:
      m_weightedAlm = new cubeData<std::complex<double> >(x, y, z, type);
      break;
    case fileType::AlmFilter:
      m_almFilter = new cubeData<std::complex<double> >(x, y, z, type);
      break;
    case fileType::AlmBeam:
      m_almBeam = new cubeData<std::complex<double> >(x, y, z, type);
      break;
    case fileType::AlmNoise:
      m_almNoise = new cubeData<std::complex<double> >(x, y, z, type);
      break;
    case fileType::AlmWeightedNoise:
      m_weightedNoiseAlm = new cubeData<std::complex<double> >(x, y, z, type);
      break;
    /*
    case fileType::SpectralData:
      m_spectData = new vectorData<double>(x,type);
      break;
    case fileType::EnsembleData:
      m_ensembleSpectData = new vectorData<double>(x,type);
      break;
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
      m_couplingMatrix = new matrixData<double>(x,y,type);
      m_couplingMatrix->format((type == fileType::BinCouplingMatrix) ? Bin : Mode);
      break;
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      m_inverseMatrix = new matrixData<double>(x,y,type);
      m_inverseMatrix->format((type == fileType::InverseBinMatrix) ? Bin : Mode);
      break;
    */
    case fileType::EnsembleAveragedNoise:
      m_ensembleAveragedNoise = new vectorData<double>(x, type);
      break;
    case fileType::EnsembleIterationNoise:
      m_ensembleIterationNoise = new matrixData<double>(x, y, type);
      break;
    case fileType::EnsembleAveragedSpectrum:
      m_ensembleAveragedSpectrum  = new vectorData<double>(x, type);;
      break;
    case fileType::EnsembleIterationSpectrum:
      m_ensembleIterationSpectrum = new matrixData<double>(x, y, type);
      break;
    case fileType::BinnedSpectrum:
      m_binnedSpectrum  = new vectorData<double>(x, type);
      break;
    case fileType::EnsembleAveragedBinnedSpectrum:
      m_ensembleAveragedBinnedSpectrum  = new vectorData<double>(x, type);
      break;
    case fileType::EnsembleIterationBinnedSpectrum:
      m_ensembleIterationBinnedSpectrum = new matrixData<double>(x, y, type);
      break;
    case fileType::ModeModeMatrix:
      m_ModeModeMatrix = new matrixData<double>(x, y, type);
      break;
    case fileType::InstrumentEffectsMatrix:
      m_InstrumentEffectsMatrix = new matrixData<double>(x, y, type);
      break;
    case fileType::BinningMatrix:
      m_BinningMatrix = new matrixData<double>(x, y, type);
      break;
    case fileType::UnbinningMatrix:
      m_UnbinningMatrix = new matrixData<double>(x, y, type);
      break;
    case fileType::BinnedInstrumentEffectsMatrix:
      m_BinnedInstrumentEffectsMatrix = new matrixData<double>(x, y, type);
      break;
    case fileType::InverseBinnedInstrumentMatrix:
      m_InverseBinnedInstrumentMatrix = new matrixData<double>(x, y, type);
      break;
    default:
      break;
  }
  return;
}

void association::getResolution(FILETYPE dataType, double& RARes, double& decRes) {
  switch (dataType) {
    case fileType::InputData:
      if (!exists(dataType))
        throw undefinedSizeError;
      RARes = inputData()->RARes();
      decRes = inputData()->DecRes();;
      break;
    case fileType::InputWeights:
      if (!exists(dataType))
        throw undefinedSizeError;
      RARes = inputWeights()->RARes();
      decRes = inputWeights()->DecRes();;
      break;
    case fileType::WeightedData:
      if(!exists(dataType))
        throw undefinedSizeError;
      RARes = weightedInput()->RARes();
      decRes = weightedInput()->DecRes();
      break;
    case fileType::InputNoise:
      if (!exists(dataType))
        throw undefinedSizeError;
      RARes = inputNoise()->RARes();
      decRes = inputNoise()->DecRes();
      break;
    case fileType::InputWeightedNoise:
      if (!exists(dataType))
          throw undefinedSizeError;
      RARes = weightedInputNoise()->RARes();
      decRes = weightedInputNoise()->DecRes();
      break;
    case fileType::InputFilter:
      if (!exists(dataType))
        throw undefinedSizeError;
      RARes = inputFilter()->RARes();
      decRes = inputFilter()->DecRes();;
      break;
    case fileType::InputBeam:
      if (!exists(dataType))
        throw undefinedSizeError;
      RARes = inputBeam()->RARes();
      decRes = inputBeam()->DecRes();;
      break;
    default:
      throw functionParameterError;
  }

  return;
}

void association::createEmptyDataSet(FILETYPE dataType, double RARes, double decRes) {

  if (RARes <= 0.0 || decRes <= 0.0)
    throw functionParameterError;

  //convert resolutions to number of bis

  if (RARes < 0.000001 || decRes < 0.000001)
    throw incompleteDatasetError;

  int x = (int)(360.0/RARes);
  int y = (int)(180.0/decRes);
  addEmpty(dataType, x, y);
  ((matrixData<double>*)(getData(dataType)))->RARes(RARes);
  ((matrixData<double>*)(getData(dataType)))->DecRes(decRes);
  ((matrixData<double>*)(getData(dataType)))->initialize();

  m_sequence = setSky;
  return;
}

void association::createUniformSky(FILETYPE dataType, double level, M_OP operation) {
  inputMatrixData* sandBox = 0;
  matrixData<double>* current = 0;

  if (dataType == fileType::Null || dataType == fileType::WeightedData || dataType > fileType::InputBeam)
    throw functionParameterError;

  if (exists(dataType)) {
    current = (matrixData<double>*)getData(dataType);
    sandBox = workSpace(current->RARes(), current->DecRes());
    sandBox->create(level);
    workSpaceTo(dataType, operation);
  }
  else
    throw undefinedSizeError;

  m_sequence = setSky;
  return;
}

void association::createUniformPatch(FILETYPE dataType, double decMax, double decMin, double RAMin, double RAMax, double level, M_OP operation) {
  inputMatrixData* sandBox = 0;
  matrixData<double>* current = 0;

  if (dataType == fileType::Null || dataType == fileType::WeightedData || dataType > fileType::InputBeam)
    throw functionParameterError;

  if (exists(dataType)) {
    current = (matrixData<double>*)getData(dataType);
    sandBox = workSpace(current->RARes(), current->DecRes());
    sandBox->create(decMax,decMin,RAMax,RAMin,level);
    workSpaceTo(dataType, operation);
  }
  else
    throw undefinedSizeError;

  m_sequence = setSky;
  return;
}

void association::createDeltaFunction(FILETYPE dataType, double RAPeak, double decPeak, double level, M_OP operation) {
  inputMatrixData* sandBox = 0;
  matrixData<double>* current = 0;

  if (dataType == fileType::Null || dataType == fileType::WeightedData || dataType > fileType::InputBeam)
    throw functionParameterError;

  if (exists(dataType)) {
    current = (matrixData<double>*)getData(dataType);
    sandBox = workSpace(current->RARes(), current->DecRes());
    sandBox->create(RAPeak,decPeak,0,level);
    workSpaceTo(dataType, operation);
  }
  else
    throw undefinedSizeError;

  m_sequence = setSky;
  return;
}

void association::createGaussian(FILETYPE dataType, double RAPeak, double decPeak, double width, double level, M_OP operation) {
  inputMatrixData* sandBox = 0;
  matrixData<double>* current = 0;

  if (dataType == fileType::Null || dataType == fileType::WeightedData || dataType > fileType::InputBeam)
    throw functionParameterError;

  if (exists(dataType)) {
    current = (matrixData<double>*)getData(dataType);
    sandBox = workSpace(current->RARes(), current->DecRes());
    sandBox->create(RAPeak,decPeak,width,level);
    workSpaceTo(dataType, operation);
  }
  else
    throw undefinedSizeError;

  m_sequence = setSky;
  return;
}

void association::createCheckerboard(FILETYPE dataType, double RAStride, double decStride, double level, M_OP operation) {
  inputMatrixData* sandBox = 0;
  matrixData<double>* current = 0;

  if (dataType == fileType::Null || dataType == fileType::WeightedData || dataType > fileType::InputBeam)
    throw functionParameterError;

  if (exists(dataType)) {
    current = (matrixData<double>*)getData(dataType);
    sandBox = workSpace(current->RARes(), current->DecRes());
    sandBox->create(RAStride,decStride,level);
    workSpaceTo(dataType, operation);
  }
  else
    throw undefinedSizeError;

  m_sequence = setSky;
  return;
}

void association::createHarmonic(FILETYPE dataType, int l, int m, double level, M_OP operation) {
  inputMatrixData* sandBox = 0;
  matrixData<double>* current = 0;

  if (dataType == fileType::Null || dataType == fileType::WeightedData || dataType > fileType::InputBeam)
    throw functionParameterError;

  if (exists(dataType)) {
    current = (matrixData<double>*)getData(dataType);
    sandBox = workSpace(current->RARes(), current->DecRes());
    sandBox->create(l,m,level);
    workSpaceTo(dataType, operation);
  }
  else
    throw undefinedSizeError;

  m_sequence = setSky;
  return;
}

void association::createWhiteNoise(vectorData<double>* vdd) {
  if (!m_pixelEngine)
    throw noPixelizerError;

  if (m_pixelEngine->pixelizerScheme() != HealPIX)
    throw noPixelizerError;

  HealPIXPixelizer* hp = (HealPIXPixelizer*)m_pixelEngine;

  if (!m_transData)
    throw incompleteDatasetError;
  if (!m_transWeights)
    throw incompleteDatasetError;

  // calculate the white noise value as the average value of the weight map time the pixel area in steradians
  // divided by the average number of sources in the data map
  double pixelArea = hp->pixelArea(true);
  double aveData = hp->calculateAverage(fileType::PixelizedData,this);
  double aveWeights = hp->calculateAverage(fileType::PixelizedWeights,this);
  double whiteNoise = pixelArea * aveWeights / aveData;

  // load vdd with white noise
  vdd->rwAccess().assign(m_transNoise->rows(),whiteNoise);

  return;
}

void association::createShotNoise(vectorData<double>* vdd) {
  if (!m_pixelEngine)
    throw noPixelizerError;

  if (m_pixelEngine->pixelizerScheme() != HealPIX)
    throw noPixelizerError;

  HealPIXPixelizer* hp = (HealPIXPixelizer*)m_pixelEngine;

  if (!m_transData)
    throw incompleteDatasetError;

  // initialize the random number generator
  gsl_rng_env_setup();
  const gsl_rng_type* generatorType = gsl_rng_default;
  gsl_rng* generator = gsl_rng_alloc(generatorType);

  // calculate the shot noise value by taking a random Poisson value using the data value
  // as the mean
  for (int row = 0; row < m_transNoise->rows(); ++row)
    (*vdd)[row] = (double)gsl_ran_poisson(generator,(*m_transData)[row]);

  return;
}

void association::generateWeightedData(FILETYPE ft) {
  matrixData<double>* dataInput  = 0; //m_inputData;
  matrixData<double>* dataWeight = 0; //m_inputWeights;
  matrixData<double>* weightedData;

  vectorData<double>* pixelData   = 0; //m_pixelData;
  vectorData<double>* pixelWeight = 0; //m_pixelWeights;
  vectorData<double>* weightedPixel;

  switch(ft)
  {
    case fileType::WeightedData:
      if(m_inputData == 0 ||
         m_inputWeights == 0)
        return;

      dataInput = m_inputData;
      dataWeight = m_inputWeights;

      weightedData = new matrixData<double>(dataInput->cols(), dataInput->rows(), fileType::WeightedData);
      weightedData->initialize();

      for(int r = 0; r < dataInput->rows(); r += 1)
      {
        for(int c = 0; c < dataInput->cols(); c += 1)
        {
          (*weightedData)[c][r] = (*dataInput)[c][r] * (*dataWeight)[c][r];
        }
      }
      addData(weightedData);
      break;
    case fileType::InputWeightedNoise:
      if(m_inputNoise == 0 ||
         m_inputWeights == 0)
        return;

      dataInput = m_inputNoise;
      dataWeight = m_inputWeights;

      weightedData = new matrixData<double>(dataInput->cols(), dataInput->rows(), fileType::InputWeightedNoise);
      weightedData->initialize();

      for(int r = 0; r < dataInput->rows(); r += 1)
      {
        for(int c = 0; c < dataInput->cols(); c += 1)
        {
          (*weightedData)[c][r] = (*dataInput)[c][r] * (*dataWeight)[c][r];
        }
      }

      addData(weightedData);
      break;
    case fileType::WeightedPixel:
      if(m_pixelData ==0 ||
         m_pixelWeights == 0)
        return;

      pixelData = m_pixelData;
      pixelWeight = m_pixelWeights;

      weightedPixel = new vectorData<double>(pixelData->rows(), fileType::WeightedPixel);
      weightedPixel->initialize();

      // set all the pixelizer info
      weightedPixel->sides(pixelData->sides());
      weightedPixel->pixelScheme(pixelData->pixelScheme());
      weightedPixel->layout(pixelData->layout());

      for(int r = 0; r < pixelData->rows(); r += 1)
        (*weightedPixel)[r] = (*pixelData)[r] * (*pixelWeight)[r];

      addData(weightedPixel);
      break;
    case fileType::PixelizedWeightedNoise:
      if(m_pixelNoise == 0 ||
         m_pixelWeights == 0)
        return;

      pixelData = m_pixelNoise;
      pixelWeight = m_pixelWeights;

      weightedPixel = new vectorData<double>(pixelData->rows(), fileType::PixelizedWeightedNoise);
      weightedPixel->initialize();

      weightedPixel->sides(pixelData->sides());
      weightedPixel->pixelScheme(pixelData->pixelScheme());
      weightedPixel->layout(pixelData->layout());

      for(int r = 0; r < pixelData->rows(); r += 1)
        (*weightedPixel)[r] = (*pixelData)[r] * (*pixelWeight)[r];
      addData(weightedPixel);
      break;
    default:
      return;
  }
}

/* Added for new lib layer compat on Novemer 2, 2010 by J.D.
Modified version of above functions which does not assume "ownership"
of pixelizer; returns true on success, false otherwise... */

void association::generatePixelData(Pixelizer *pixelizer, FILETYPE ft) {
  int nPixels;
  matrixData<double> *in = 0;
  vectorData<double> *pix = 0;
  vectorData<int> *occ = 0;
  
  if (!pixelizer)
    throw noPixelizerError;
  
  if (!exists(ft))
    throw noDataError;

  if (ft > fileType::InputBeam)
    throw noDataError;

  nPixels = 12 * pixelizer->scale() * pixelizer->scale();
  m_pixelAverage  = 0;
  m_pixelVariance = 0;

  int offset = (int)fileType::PixelizedData - (int)fileType::InputData;
  FILETYPE pt = static_cast<FILETYPE>((int)ft + offset);

  if (pt >= fileType::PixelOccupancy)
    pt = static_cast<FILETYPE>((int)pt + 1);

  discardRelation(pt);
  addEmpty(pt,nPixels);

  switch (ft) {
    case fileType::InputData:
//      discardRelation(fileType::PixelizedData);
//      addEmpty(fileType::PixelizedData,nPixels);
      pix = m_pixelData;

      discardRelation(fileType::PixelOccupancy);
      addEmpty(fileType::PixelOccupancy,nPixels);
      occ = m_pixelOccupancy;
      break;
    case fileType::InputWeights:
//      discardRelation(fileType::PixelizedWeights);
//      addEmpty(fileType::PixelizedWeights,nPixels);
      if(!m_pixelOccupancy)
      {
        discardRelation(fileType::PixelOccupancy);
        addEmpty(fileType::PixelOccupancy, nPixels);
      }
      pix = m_pixelWeights;
      occ = m_pixelOccupancy;
      break;
    case fileType::WeightedData:
      if(!m_pixelOccupancy)
      {
        discardRelation(fileType::PixelOccupancy);
        addEmpty(fileType::PixelOccupancy, nPixels);
      }
      pix = m_weightedPixel;
      occ = m_pixelOccupancy;
      break;
    case fileType::InputNoise:
//      discardRelation(fileType::PixelizedNoise);
//      addEmpty(fileType::PixelizedNoise,nPixels);
      if(!m_pixelOccupancy)
      {
        discardRelation(fileType::PixelOccupancy);
        addEmpty(fileType::PixelOccupancy, nPixels);
      }

      pix = m_pixelNoise;
      occ = m_pixelOccupancy;
      break;
    case fileType::InputFilter:
//      discardRelation(fileType::PixelizedFilter);
//      addEmpty(fileType::PixelizedFilter,nPixels);
      if(!m_pixelOccupancy)
      {
        discardRelation(fileType::PixelOccupancy);
        addEmpty(fileType::PixelOccupancy, nPixels);
      }
      pix = m_pixelFilter;
      occ = m_pixelOccupancy;
      break;
    case fileType::InputBeam:
//      discardRelation(fileType::PixelizedBeam);
//      addEmpty(fileType::PixelizedBeam,nPixels);
      if(!m_pixelOccupancy)
      {
        discardRelation(fileType::PixelOccupancy);
        addEmpty(fileType::PixelOccupancy, nPixels);
      }
      pix = m_pixelBeam;
      occ = m_pixelOccupancy;
      break;
    case fileType::InputWeightedNoise:
      if(!m_pixelOccupancy)
      {
        discardRelation(fileType::PixelOccupancy);
        addEmpty(fileType::PixelOccupancy, nPixels);
      }
      pix = m_pixelWeightedNoise;
      occ = m_pixelOccupancy;
      break;
  }
  pix->initialize();

  pix->pixelScheme(pixelizer->pixelizerScheme());
  pix->layout(pixelizer->pixelLayout());
  pix->sides(pixelizer->scale());
  
  if (occ) {
    occ->initialize();
    occ->pixelScheme(pixelizer->pixelizerScheme());
    occ->layout(pixelizer->pixelLayout());
    occ->sides(pixelizer->scale());
  }

  pixelizer->pixelize(this,0,0,0,ft);
  m_pixelAverage = pixelizer->calculateAverage(pt, this);
  m_pixelVariance = pixelizer->calculateVariance(pt, this);

  if(pixelizer->usePixelAvg())
  {
    baseData* oldData =pixelizer->calculateAverageVector(pt, this);

    if(FILETYPE::PixelOccupancy == pt)
      vectorData<int>* occAvg = (vectorData<int>*) oldData;
    else
      vectorData<double>* dataAvg = (vectorData<double>*) oldData;
  }

  if(pixelizer->usePixelDev())
  {
    baseData* oldData =pixelizer->calculateDevianceVector(pt, this);

    if(FILETYPE::PixelOccupancy == pt)
      vectorData<int>* occDev = (vectorData<int>*) oldData;
    else
    vectorData<double>* dataDev = (vectorData<double>*) oldData;
  }

  if(pixelizer->usePixelVar())
  {
    baseData* oldData =pixelizer->calculateVarianceVector(pt, this);

    if(FILETYPE::PixelOccupancy == pt)
      vectorData<int>* occAvg = (vectorData<int>*) oldData;
    else
    vectorData<double>* dataAvg = (vectorData<double>*) oldData;
  }

  if(pixelizer->doAvgNormalize())
    pixelizer->meanNormalize(pt, this, false);

  if(pixelizer->doVarNormalize())
    pixelizer->meanNormalize(pt, this, true);

  if(pixelizer->doMinMaxScale())
    pixelizer->minmaxNormalize(pt, this);

  m_sequence = pixelize;

  return;
}

bool association::generateTransformedData(Transformer *transformer, FILETYPE ft) {
  vectorData<double> *pix = 0, *trans = 0;
  cubeData<std::complex<double> > *alm = 0;
  
  if (!transformer)
    return false;

  if (ft < fileType::PixelizedData || ft > fileType::PixelizedBeam)
    throw noDataError;

  int ftID = static_cast<int>(ft);

  int transOffset = (int)fileType::TransformedData - (int)fileType::PixelizedData;
  int almOffset   = (int)fileType::AlmData - (int)fileType::PixelizedData;

  FILETYPE transType = static_cast<FILETYPE>((int)ft + transOffset);
  FILETYPE almType   = static_cast<FILETYPE>((int) ft + almOffset);

  if (ft >= fileType::PixelOccupancy)
  {
    transType = static_cast<FILETYPE>((int)transType - 1);
    almType   = static_cast<FILETYPE>((int)almType - 1);
  }


  discardRelation(transType);
  addEmpty(transType,transformer->maxIndex());
  addEmpty(almType,transformer->maxIndex(),transformer->maxIndex());

  switch (ft) {
    case fileType::PixelizedData:
//      discardRelation(fileType::TransformedData);
//      addEmpty(fileType::TransformedData,transformer->maxIndex());
//      m_transData->initialize();
//      addEmpty(fileType::AlmData,transformer->maxIndex(),transformer->maxIndex(),3);
//      m_almData->initialize();
      pix = m_pixelData;
      trans = m_transData;
      alm = m_almData;
      break;
    case fileType::PixelizedWeights:
//      discardRelation(fileType::TransformedWeights);
//      addEmpty(fileType::TransformedWeights,transformer->maxIndex());
//      m_transWeights->initialize();
//      addEmpty(fileType::AlmWeights,transformer->maxIndex(),transformer->maxIndex(),3);
//      m_almWeights->initialize();
      pix  = m_pixelWeights;
      trans = m_transWeights;
      alm = m_almWeights;
      break;
    case fileType::WeightedPixel:
      pix = m_weightedPixel;
      trans = m_weightedTransform;
      alm = m_weightedAlm;
      break;
    case fileType::PixelizedNoise:
//      discardRelation(fileType::TransformedNoise);
//      addEmpty(fileType::TransformedNoise,transformer->maxIndex());
//      m_transNoise->initialize();
//      addEmpty(fileType::AlmNoise,transformer->maxIndex(),transformer->maxIndex(),3);
//      m_almNoise->initialize();
      pix = m_pixelNoise;
      trans = m_transNoise;
      alm = m_almNoise;
      break;
    case fileType::PixelizedFilter:
//      discardRelation(fileType::TransformedFilter);
//      addEmpty(fileType::TransformedFilter,transformer->maxIndex());
//      m_transFilter->initialize();
//      addEmpty(fileType::AlmFilter,transformer->maxIndex(),transformer->maxIndex(),3);
//      m_almFilter->initialize();
      pix = m_pixelFilter;
      trans = m_transFilter;
      alm = m_almFilter;
      break;
    case fileType::PixelizedBeam:
//      discardRelation(fileType::TransformedBeam);
//      addEmpty(fileType::TransformedBeam,transformer->maxIndex());
//      m_transBeam->initialize();
//      addEmpty(fileType::AlmBeam,transformer->maxIndex(),transformer->maxIndex(),3);
//      m_almBeam->initialize();
      pix = m_pixelBeam;
      trans = m_transBeam;
      alm = m_almBeam;
      break;
    case fileType::PixelizedWeightedNoise:
      pix = m_pixelWeightedNoise;
      trans = m_transWeightedNoise;
      alm = m_weightedNoiseAlm;
      break;
    default:
      return false;
  }
  
  trans->initialize();
  trans->transformerScheme(transformer->scheme());
  trans->minYIndex(transformer->minIndex());

  // we should save the pixelizer method as well
  // because when we use default noise, we need the pixelizer
  trans->pixelScheme(pix->pixelScheme());
  trans->sides(pix->sides());
  trans->layout(pix->layout());

  alm->initialize();
  // save the pixelizer and transformer info for reading later on
  alm->pixelScheme(pix->pixelScheme());
  alm->sides(pix->sides());
  alm->layout(pix->layout());

  alm->transformerScheme(transformer->scheme());
  alm->transMinIndex(transformer->minIndex());
  alm->transMaxIndex(transformer->maxIndex());

  transformer->dataSize(pix->size());
  transformer->initialize(this);
  transformer->configured(true);
  transformer->loadMap(this,pix->dataType());
  transformer->transform(this,trans->dataType());
  transformer->storeAlmMap(this,alm->dataType());

  m_sequence = transform;
  return true;
}

bool association::generateTransformedDataFromAlm(Transformer* transformer, FILETYPE ft)
{
  vectorData<double> *trans = 0;
  cubeData<std::complex<double> > *alm = 0;

  if (!transformer)
    return false;

  int ftID = static_cast<int>(ft);

  int transOffSet = (int)fileType::AlmData - (int)fileType::TransformedData;
  int pixelOffSet = (int)fileType::AlmData - (int)fileType::PixelizedData;

  fileType transType = fileType(ftID - transOffSet);
  fileType pixelType = fileType(ftID - pixelOffSet);

  // this will delete the alm type needed
  //discardRelation(transType);
  // this will call discardRelation
  //addEmpty(transType,transformer->maxIndex());

  int maxInd = transformer->maxIndex();
  switch (ft) {
    case fileType::AlmData:
      m_transData = new vectorData<double>(maxInd, transType);
      trans = m_transData;
      alm = m_almData;
      break;
    case fileType::AlmWeights:
      m_transWeights = new vectorData<double>(maxInd, transType);
      trans = m_transWeights;
      alm = m_almWeights;
      break;
    case fileType::WeightedAlm:
      m_weightedTransform = new vectorData<double>(maxInd, transType);
      trans = m_weightedTransform;
      alm = m_weightedAlm;
      break;
    case fileType::AlmNoise:
      m_transNoise = new vectorData<double>(maxInd, transType);
      trans = m_transNoise;
      alm = m_almNoise;
      break;
    case fileType::AlmFilter:
      m_transFilter = new vectorData<double>(maxInd, transType);
      trans = m_transFilter;
      alm = m_almFilter;
      break;
    case fileType::AlmBeam:
      m_transBeam = new vectorData<double>(maxInd, transType);
      trans = m_transBeam;
      alm = m_almBeam;
      break;
    case fileType::AlmWeightedNoise:
      m_transWeightedNoise = new vectorData<double>(maxInd, transType);
      trans = m_transWeightedNoise;
      alm = m_weightedNoiseAlm;
      break;
    default:
      return false;
  }

  // this will initialize the powerspec
  transformer->initialize(this);
  // this will initialize all the necessary types
  transformer->initialize(this, ft);

  trans->initialize();
  trans->transformerScheme(transformer->scheme());
  trans->minYIndex(transformer->minIndex());

  // we should save the pixelizer method as well
  // because when we use default noise, we need the pixelizer
  trans->pixelScheme(alm->pixelScheme());
  trans->sides(alm->sides());
  trans->layout(alm->layout());

  int size = alm->sides() * alm->sides() * 12;
  transformer->dataSize(size);
  transformer->configured(true);
  // this will copy our alm to a Alm<hPoint> for HealPix
  transformer->loadAlmMap(this, ft);
  transformer->transformFromAlm(this, ft);
  //transformer->storeMap(this, ft);

  m_sequence = transform;
  return true;
}

bool association::generatePowerSpectrumData(Spectrum *spect) {
  if (!spect)
    return false;

  if (!m_transData || !m_transWeights || !m_weightedTransform)
    return false;

  spect->initialize();

  //if(exists(fileType::TransformedNoise))
  if(exists(fileType::TransformedWeightedNoise))
  {
    if(!exists(fileType::EnsembleAveragedNoise))
    {
      // this calls discard relation which deletes all our data!
      //addEmpty(fileType::EnsembleAveragedNoise, spect->maxIndex());
      m_ensembleAveragedNoise = new vectorData<double>(spect->maxIndex(), fileType::EnsembleAveragedNoise);
      m_ensembleAveragedNoise->initialize();

      //addEmpty(fileType::EnsembleIterationNoise, spect->maxIndex(), spect->ensembleIterations());
      m_ensembleIterationNoise = new matrixData<double>(spect->maxIndex(), spect->ensembleIterations(), fileType::EnsembleIterationNoise);
      m_ensembleIterationNoise->initialize();

      spect->calculateEnsembleAverage(this, fileType::EnsembleAveragedNoise);
    }
    //else
    //  spect->calculateEnsembleAverage(this, fileType::EnsembleAveragedNoise);
  }
  else
    throw dataMismatchError;

  if(exists(fileType::WeightedTransform))
  {
    if(!exists(fileType::EnsembleAveragedSpectrum))
    {
      //addEmpty(fileType::EnsembleAveragedSpectrum, spect->maxIndex());
      m_ensembleAveragedSpectrum = new vectorData<double>(spect->maxIndex(), fileType::EnsembleAveragedSpectrum);
      m_ensembleAveragedSpectrum->initialize();

      //addEmpty(fileType::EnsembleIterationSpectrum, spect->maxIndex(), spect->ensembleIterations());
      m_ensembleIterationSpectrum  = new matrixData<double>(spect->maxIndex(), spect->ensembleIterations(), fileType::EnsembleIterationSpectrum);
      m_ensembleIterationSpectrum->initialize();

      spect->calculateEnsembleAverage(this, fileType::EnsembleAveragedSpectrum);
    }
    //else
    //  spect->calculateEnsembleAverage(this, fileType::EnsembleAveragedSpectrum);
  }
  else
    throw dataMismatchError;


  if(exists(fileType::ModeModeMatrix))
    spect->loadIntoGslMatrix(this, fileType::ModeModeMatrix);
  else
  {
    //addEmpty(fileType::ModeModeMatrix, spect->maxIndex(), spect->maxIndex());
    m_ModeModeMatrix = new matrixData<double>(spect->maxIndex(), spect->maxIndex(), fileType::ModeModeMatrix);
    m_ModeModeMatrix->initialize();

    spect->createModeModeMatrix(this);
    spect->loadIntoGslMatrix(this, fileType::ModeModeMatrix);
  }

  if(exists(fileType::InstrumentEffectsMatrix))
    spect->loadIntoGslMatrix(this, fileType::InstrumentEffectsMatrix);
  else
  {
    //addEmpty(fileType::InstrumentEffectsMatrix, spect->maxIndex(), spect->maxIndex());
    m_InstrumentEffectsMatrix = new matrixData<double>(spect->maxIndex(), spect->maxIndex(), fileType::InstrumentEffectsMatrix);
    m_InstrumentEffectsMatrix->initialize();

    spect->calculateInstrumentEffectsMatrix(this);
    spect->loadIntoGslMatrix(this, fileType::InstrumentEffectsMatrix);
  }

  if(exists(fileType::BinningMatrix))
    spect->loadIntoGslMatrix(this, fileType::BinningMatrix);
  else
  {
    //addEmpty(fileType::BinningMatrix, spect->maxIndex(), spect->numBins());
    m_BinningMatrix = new matrixData<double>(spect->maxIndex(), spect->numBins(), fileType::BinningMatrix);
    m_BinningMatrix->initialize();

    spect->calculateBinningMatrix(this);
    spect->loadIntoGslMatrix(this, fileType::BinningMatrix);
  }

  if(exists(fileType::UnbinningMatrix))
    spect->loadIntoGslMatrix(this, fileType::UnbinningMatrix);
  else
  {
    //addEmpty(fileType::UnbinningMatrix, spect->maxIndex(), spect->numBins());
    m_UnbinningMatrix = new matrixData<double>(spect->numBins(), spect->maxIndex(), fileType::UnbinningMatrix);
    m_UnbinningMatrix->initialize();

    spect->calculateUnbinningMatrix(this);
    spect->loadIntoGslMatrix(this, fileType::UnbinningMatrix);
  }

  if(exists(fileType::BinnedInstrumentEffectsMatrix))
    spect->loadIntoGslMatrix(this, fileType::BinnedInstrumentEffectsMatrix);
  else
  {
    //addEmpty(fileType::BinnedInstrumentEffectsMatrix, spect->numBins(), spect->numBins());
    m_BinnedInstrumentEffectsMatrix = new matrixData<double>(spect->numBins(), spect->numBins(), fileType::BinnedInstrumentEffectsMatrix);
    m_BinnedInstrumentEffectsMatrix->initialize();

    spect->calculateBinnedInstrumentEffectsMatrix(this);
    spect->loadIntoGslMatrix(this, fileType::BinnedInstrumentEffectsMatrix);
  }

  if(exists(fileType::InverseBinnedInstrumentMatrix))
    spect->loadIntoGslMatrix(this, fileType::InverseBinnedInstrumentMatrix);
  else
  {
    //addEmpty(fileType::InverseBinnedInstrumentMatrix, spect->numBins(), spect->numBins());
    m_InverseBinnedInstrumentMatrix = new matrixData<double>(spect->numBins(), spect->numBins(), fileType::InverseBinnedInstrumentMatrix);
    m_InverseBinnedInstrumentMatrix->initialize();

    // matrix isn't invertible because the first row and column is 0 due to the binning and unbinning matrixes being 0 for the first 2 l's
    //spect->invertMatrix(this, fileType::BinnedInstrumentEffectsMatrix);
    //spect->loadIntoGslMatrix(this, fileType::InverseBinnedInstrumentMatrix);
  }

  if(!exists(fileType::BinnedSpectrum))
  {
    //addEmpty(fileType::BinnedSpectrum, spect->numBins());
    m_binnedSpectrum = new vectorData<double>(spect->numBins(), fileType::BinnedSpectrum);
    m_binnedSpectrum->initialize();

    //spect->calculateBinnedSpectrum(this);
  }


  if(!exists(fileType::EnsembleAveragedBinnedSpectrum))
  {
    //addEmpty(fileType::EnsembleAveragedBinnedSpectrum, spect->numBins());
    m_ensembleAveragedBinnedSpectrum = new vectorData<double>(spect->numBins(), fileType::EnsembleAveragedBinnedSpectrum);
    m_ensembleAveragedBinnedSpectrum->initialize();

    //addEmpty(fileType::EnsembleIterationBinnedSpectrum, spect->numBins(), spect->ensembleIterations());
    m_ensembleIterationBinnedSpectrum = new matrixData<double>(spect->numBins(), spect->ensembleIterations(), fileType::EnsembleIterationBinnedSpectrum);
    m_ensembleIterationBinnedSpectrum->initialize();

    //spect->calculateEnsembleAverage(this, fileType::EnsembleAveragedBinnedSpectrum);
  }

  /*
  addEmpty(fileType::SpectralData,m_transData->size());
  spect->maxIndex(m_transData->maxYIndex());

  spect->initialize();

  // set up mode-mode coupling matrix
  if (!m_couplingMatrix) {
    addEmpty(fileType::ModeCouplingMatrix,m_transData->size(),m_transData->size());
    spect->createModeCouplingMatrix(this);
  }

  if (m_couplingMatrix->format() == Mode)
    spect->loadCouplingMatrix(this);

  // Maybe some checks here, but think that most checking applies to
  //existing file loaded matrices: therefore should be in a different
  //"process from file" function...

  long max_index = spect->maxIndex(), max_bin = spect->maxBin();
  long indices = spect->indices();
  long i = 0, j = 0, total = max_index * (max_index + 1);
  long minL = 0, maxL = 1;
  long op_total, progress = 0;

  if (spect->binning()) {
    op_total = max_bin * indices;

    //Calculating bin-index coupling matrix
    for (i = 0; i < max_bin; ++i) {
      minL = i * indices;
      maxL = minL + indices;
      if (maxL > max_index)
        maxL = max_index;

      for (j = minL; j < maxL; ++j) {
        spect->calculateBinIndexMatrix(i,j);
        progress = i * max_bin + j;
      }
    }

    // Calculating index-bin coupling matrix
    for (i = 0; i < max_bin; ++i) {
      minL = i * indices;
      maxL = minL + indices;
      if (maxL > max_index)
        maxL = max_index;

      for (j = minL; j < maxL; ++j) {
        spect->calculateIndexBinMatrix(i,j);
        progress = i * max_bin + j;
      }
    }

    op_total = max_bin * max_bin;

    if (!m_couplingMatrix)
      addEmpty(fileType::BinCouplingMatrix,m_transData->size(),m_transData->size());
    m_couplingMatrix->format(Bin);
    spect->calculateBinCouplingMatrix(this);
    if (m_couplingMatrix && m_couplingMatrix->format() == Bin)
      spect->loadCouplingMatrix(this);

    m_spectData->binned(true);
  }
  else
    m_spectData->binned(false);

  if (!m_inverseMatrix) {
    if (spect->binning())
      addEmpty(fileType::InverseBinMatrix,m_transData->size(),m_transData->size());
    else
      addEmpty(fileType::InverseModeMatrix,m_transData->size(),m_transData->size());
    m_inverseMatrix->initialize();
    if (spect->invertMatrix(this) < 0)
      return false;
  }
  spect->loadInverseMatrix(this);

//  if (spect->computeInverse()) {
//    if (!spect->binning() && m_inverseMatrix && m_inverseMatrix->format() == Mode)
//      spect->loadInverseMatrix(this);
//    else if (spect->binning() && m_inverseMatrix  && m_inverseMatrix->format() == Bin)
//      spect->loadInverseMatrix(this);
//    else if (!spect->binning() && !m_inverseMatrix) {
//      addEmpty(InverseModeMatrix,m_transData->size(),m_transData->size());
//      if (spect->invertMatrix(this) < 0)
//        return false;
//    }
//    else {
//      addEmpty(InverseBinMatrix,m_transData->size(),m_transData->size());
//      if (spect->invertMatrix(this) < 0)
//        return false;
//    }

  // Calculating spectral data //
  spect->calculateSpectrum(this);

  m_spectData->mask(spect->maskIndex());
//  }
*/

  m_sequence = powerSpectrum;
  return true;
}

bool association::generateEnsembleSpectrumData(Spectrum *spect)
{
  /*
  if (!spect)
    return false;

  if (!m_spectData)
    return false;

  addEmpty(fileType::EnsembleData, m_transData->size());
  spect->maxIndex(m_transData->maxYIndex());

  if(!spect->configured())
    spect->initialize();

  // set up mode-mode coupling matrix
  if (!m_couplingMatrix) {
    addEmpty(fileType::ModeCouplingMatrix,m_transData->size(),m_transData->size());
    spect->createModeCouplingMatrix(this);
  }

  if (m_couplingMatrix->format() == Mode)
    spect->loadCouplingMatrix(this);

  // Maybe some checks here, but think that most checking applies to
  // existing file loaded matrices: therefore should be in a different
  // "process from file" function...

  long max_index = spect->maxIndex(), max_bin = spect->maxBin();
  long indices = spect->indices();
  long i = 0, j = 0, total = max_index * (max_index + 1);
  long minL = 0, maxL = 1;
  long op_total, progress = 0;

  if (spect->binning())
  {
    op_total = max_bin * indices;

    // Calculating bin-index coupling matrix
    for (i = 0; i < max_bin; ++i) {
      minL = i * indices;
      maxL = minL + indices;
      if (maxL > max_index)
        maxL = max_index;

      for (j = minL; j < maxL; ++j) {
        spect->calculateBinIndexMatrix(i,j);
        progress = i * max_bin + j;
      }
    }

    // Calculating index-bin coupling matrix
    for (i = 0; i < max_bin; ++i) {
      minL = i * indices;
      maxL = minL + indices;
      if (maxL > max_index)
        maxL = max_index;

      for (j = minL; j < maxL; ++j) {
        spect->calculateIndexBinMatrix(i,j);
        progress = i * max_bin + j;
      }
    }
    op_total = max_bin * max_bin;

    if (!m_couplingMatrix)
      addEmpty(fileType::BinCouplingMatrix,m_transData->size(),m_transData->size());

    m_couplingMatrix->format(Bin);
    spect->calculateBinCouplingMatrix(this);

    if (m_couplingMatrix && m_couplingMatrix->format() == Bin)
      spect->loadCouplingMatrix(this);

    m_spectData->binned(true);
  }
  else
    m_spectData->binned(false);

  if (!m_inverseMatrix) {
    if (spect->binning())
      addEmpty(fileType::InverseBinMatrix,m_transData->size(),m_transData->size());
    else
      addEmpty(fileType::InverseModeMatrix,m_transData->size(),m_transData->size());
    m_inverseMatrix->initialize();
    if (spect->invertMatrix(this) < 0)
      return false;
  }
  spect->loadInverseMatrix(this);

  // Calculating spectral data
  spect->calculateEnsembleAverage(this, spect->ensembleIterations());
  spect->ensembleAverageTimesInverse(this);

  m_ensembleSpectData->mask(spect->maskIndex());

  */

  m_sequence = powerSpectrum;
  return true;
}

bool association::generateInverseData(Transformer *transformer, FILETYPE ft) {
  vectorData<double> *pix = 0, *inv = 0;
  cubeData<std::complex<double> >* alm = 0;
  int size = 0;
  FILETYPE invType;
  
  if (!transformer)
    return false;

  /*
  // if we are creating inverse data we don't have pixelized data
  if (m_pixelNoise)
    pix = pixelizedNoise();
  if (m_pixelBeam)
    pix = pixelizedBeam();
  if (m_pixelFilter)
    pix = pixelizedFilter();
  if (m_pixelWeights)
    pix = pixelizedWeights();
  if (m_pixelData)
    pix = pixelizedData();
  if (!pix)
    return false;
  
  size = pix->size();
  */

  switch (ft) {
    case fileType::AlmData: //TransformedData:
      if (!m_almData)
        return false;
      alm = m_almData;
      size = alm->sides() * alm->sides() * 12;
      addEmpty(fileType::InverseData,size);
      inv = m_invData;
      //almType = fileType::AlmData;
      invType = fileType::InverseData;
      break;
    case fileType::AlmWeights: //TransformedWeights:
      if (!m_almWeights)
        return false;
      alm = m_almWeights;
      size = alm->sides() * alm->sides() * 12;
      addEmpty(fileType::InverseWeights,size);
      inv = m_invWeights;
      //almType = fileType::AlmWeights;
      invType = fileType::InverseWeights;
      break;
    case fileType::WeightedAlm:
      if(!m_weightedAlm)
        return false;
      alm = m_weightedAlm;
      size = alm->sides() * alm->sides() * 12;
      addEmpty(fileType::WeightedInverse, size);
      inv = m_weightedInverse;
      invType = fileType::WeightedInverse;
      break;
    case fileType::AlmFilter: //TransformedFilter:
      if (!m_almFilter)
        return false;
      alm = m_almFilter;
      size = alm->sides() * alm->sides() * 12;
      addEmpty(fileType::InverseFilter,size);
      inv = m_invFilter;
      //almType = fileType::AlmFilter;
      invType = fileType::InverseFilter;
      break;
    case fileType::AlmBeam: //TransformedBeam:
      if (!m_almBeam)
        return false;
      alm = m_almBeam;
      size = alm->sides() * alm->sides() * 12;
      addEmpty(fileType::InverseBeam,size);
      inv = m_invBeam;
      //almType = fileType::AlmBeam;
      invType = fileType::InverseBeam;
      break;
    case fileType::AlmNoise: //TransformedNoise:
      if (!m_almNoise)
        return false;
      alm = m_almNoise;
      size = alm->sides() * alm->sides() * 12;
      addEmpty(fileType::InverseNoise,size);
      inv = m_invNoise;
      //almType = fileType::AlmNoise;
      invType = fileType::InverseNoise;
      break;
    case fileType::AlmWeightedNoise:
      if(!m_weightedNoiseAlm)
        return false;
      alm = m_weightedNoiseAlm;
      size = alm->sides() * alm->sides() * 12;
      addEmpty(fileType::InverseWeightedNoise, size);
      inv = m_invWeightedNoise;
      invType = fileType::InverseWeightedNoise;
      break;
    default:
      return false;
  }
      
  /* Calculating Inverse Transformation */
  // this might be unnecessary since in the mainwindow.cpp file
  // we say if we have alm we call association.generateTransformedDataFromAlm
  // which calls transformer->initialize
  // and transformer.loadAlmMap

  // this will load the healpix inverse maps
  transformer->initialize(this, ft);
  // this will copy our alm to a healpix alm
  transformer->loadAlmMap(this, ft);//almType);

  transformer->invert(this, ft);

  inv->pixelScheme(alm->pixelScheme());
  inv->layout(alm->layout());
  inv->sides(alm->sides());
  inv->numberOfPixels(size);

  m_sequence = invert;
  return true;
}

void association::generateMap(FILETYPE type) {
  std::string   name;
  dataMap       *map = 0;

  if (!exists(dataEngines::Mapping))
    throw noMapperError;

  map = new dataMap();
  if (!map)
   throw noDatamapError;

  name = dataTypeNames[(int)type];
  map->title(name);
  map->orientation(m_mapEngine->orientation());
  map->aspect(m_mapEngine->aspectRatio());
  map->initialize(m_mapEngine->width(),m_mapEngine->height());
  map->colorScheme(m_mapEngine->colorScheme());
  map->createColorBar();

  switch (type) {
    case fileType::InputData:
      if (!m_inputData)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_inputDataMap)
        *m_inputDataMap = *map;
      else
        m_inputDataMap = new dataMap(map);
      break;
    case fileType::InputWeights:
      if (!m_inputWeights)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_inputWeightsMap)
        *m_inputWeightsMap = *map;
      else
        m_inputWeightsMap = new dataMap(map);
      break;
    case fileType::WeightedData:
      if (!m_weightedInput)
        throw noDataError;
      //if (!m_inputData || !m_inputWeights)
      //  throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_inputMap)
        *m_inputMap = *map;
      else
        m_inputMap = new dataMap(map);
      break;
    case fileType::InputNoise:
      if (!m_inputNoise)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_inputNoiseMap)
        *m_inputNoiseMap = *map;
      else
        m_inputNoiseMap = new dataMap(map);
      break;
    case fileType::InputWeightedNoise:
      if(!m_weightedNoise)
        throw noDataError;
      m_mapEngine->makeMap(map, type, this);
      if(m_weightedNoiseMap)
        *m_weightedNoiseMap = *map;
      else
        m_weightedNoiseMap = new dataMap(map);
      break;
    case fileType::InputFilter:
      if (!m_inputFilter)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_inputFilterMap)
        *m_inputFilterMap = *map;
      else
        m_inputFilterMap = new dataMap(map);
      break;
    case fileType::InputBeam:
      if (!m_inputBeam)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_inputBeamMap)
        *m_inputBeamMap = *map;
      else
        m_inputBeamMap = new dataMap(map);
      break;
    case fileType::PixelizedData:
      if (!m_pixelData)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelDataMap)
        *m_pixelDataMap = *map;
      else
        m_pixelDataMap = new dataMap(map);
      break;
    case fileType::PixelizedWeights:
      if (!m_pixelWeights)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelWeightsMap)
        *m_pixelWeightsMap = *map;
      else
        m_pixelWeightsMap = new dataMap(map);
      break;
    case fileType::WeightedPixel:
      if (!m_weightedPixel)
        throw noDataError;
      //if (!m_pixelData || !m_pixelWeights)
      //  throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelMap)
        *m_pixelMap = *map;
      else
        m_pixelMap = new dataMap(map);
      break;
    case fileType::PixelOccupancy:
      if (!m_pixelOccupancy)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelOccupancyMap)
        *m_pixelOccupancyMap = *map;
      else
        m_pixelOccupancyMap = new dataMap(map);
      break;
    case fileType::PixelizedNoise:
      if (!m_pixelNoise)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelNoiseMap)
        *m_pixelNoiseMap = *map;
      else
        m_pixelNoiseMap = new dataMap(map);
      break;
    case fileType::PixelizedWeightedNoise:
      if (!m_pixelWeightedNoise)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelWeightedNoiseMap)
        *m_pixelWeightedNoiseMap = *map;
      else
        m_pixelWeightedNoiseMap = new dataMap(map);
      break;
    case fileType::PixelizedFilter:
      if (!m_pixelFilter)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelFilterMap)
        *m_pixelFilterMap = *map;
      else
        m_pixelFilterMap = new dataMap(map);
      break;
    case fileType::PixelizedBeam:
      if (!m_pixelBeam)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelBeamMap)
        *m_pixelBeamMap = *map;
      else
        m_pixelBeamMap = new dataMap(map);
      break;
    case fileType::InverseData:
      if (!m_invData)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_invDataMap)
        *m_invDataMap = *map;
      else
        m_invDataMap = new dataMap(map);
      break;
    case fileType::InverseWeights:
      if (!m_invWeights)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_invWeightsMap)
        *m_invWeightsMap = *map;
      else
        m_invWeightsMap = new dataMap(map);
      break;
    case fileType::WeightedInverse:
      if (!m_weightedInverse)
        throw noDataError;
      //if (!m_invData || !m_invWeights)
      //  throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_invMap)
        *m_invMap = *map;
      else
        m_invMap = new dataMap(map);
      break;
    case fileType::InverseNoise:
      if (!m_invNoise)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_invNoiseMap)
        *m_invNoiseMap = *map;
      else
        m_invNoiseMap = new dataMap(map);
      break;
    case fileType::InverseWeightedNoise:
      if (!m_invWeightedNoise)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_invWeightedNoiseMap)
        *m_invWeightedNoiseMap = *map;
      else
        m_invWeightedNoiseMap = new dataMap(map);
      break;
    case fileType::InverseFilter:
      if (!m_invFilter)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_invFilterMap)
        *m_invFilterMap = *map;
      else
        m_invFilterMap = new dataMap(map);
      break;
    case fileType::InverseBeam:
      if (!m_invBeam)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_invBeamMap)
        *m_invBeamMap = *map;
      else
        m_invBeamMap = new dataMap(map);
      break;
    default:
      throw noDataError;
  }
  delete map;

  switch (type) {
    case fileType::InputData:
    case fileType::InputWeights:
    case fileType::WeightedData:
    case fileType::InputNoise:
    case fileType::InputWeightedNoise:
    case fileType::InputFilter:
    case fileType::InputBeam:
      m_sequence = mapSky;
      break;
    case fileType::PixelizedData:
    case fileType::PixelizedWeights:
    case fileType::WeightedPixel:
    case fileType::PixelOccupancy:
    case fileType::PixelizedNoise:
    case fileType::PixelizedWeightedNoise:
    case fileType::PixelizedFilter:
    case fileType::PixelizedBeam:
      m_sequence = mapPixel;
      break;
    case fileType::InverseData:
    case fileType::InverseWeights:
    case fileType::WeightedInverse:
    case fileType::InverseNoise:
    case fileType::InverseWeightedNoise:
    case fileType::InverseFilter:
    case fileType::InverseBeam:
      m_sequence = mapInverse;
      break;
  }
  return;
}

bool association::generateGraph(FILETYPE type) {
  std::string   name;
  dataSpectrum *graph = 0;

  if (!exists(dataEngines::Graphing))
    return false;
  
  graph = new dataSpectrum();
  if (!graph)
   return false;

  name = dataTypeNames[(int)type];

  graph->title(name);
  graph->aspect(m_graphEngine->aspectRatio());
  graph->initialize(m_graphEngine->width(),m_graphEngine->height());

  switch (type) {
    case fileType::TransformedData:
      if (!m_transData)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_transDataGraph)
        *m_transDataGraph = *graph;
      else
        m_transDataGraph = new dataSpectrum(graph);
      break;
    case fileType::TransformedWeights:
      if (!m_transWeights)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_transWeightsGraph)
        *m_transWeightsGraph = *graph;
      else
        m_transWeightsGraph = new dataSpectrum(graph);
      break;
    case fileType::WeightedTransform:
      if(!m_weightedTransform)
        return false;
      //if (!m_transData || !m_transWeights)
      //  return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_transGraph)
        *m_transGraph = *graph;
      else
        m_transGraph = new dataSpectrum(graph);
      break;
    case fileType::TransformedNoise:
      //if (!m_pixelNoise)
      //  return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_transNoiseGraph)
        *m_transNoiseGraph = *graph;
      else
        m_transNoiseGraph = new dataSpectrum(graph);
      break;
    case fileType::TransformedWeightedNoise:
      //if (!m_pixelNoise)
      //  return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_transWeightedNoiseGraph)
        *m_transWeightedNoiseGraph = *graph;
      else
        m_transWeightedNoiseGraph = new dataSpectrum(graph);
      break;
    case fileType::TransformedFilter:
      //if (!m_pixelFilter)
      //  return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_transFilterGraph)
        *m_transFilterGraph = *graph;
      else
        m_transFilterGraph = new dataSpectrum(graph);
      break;
    case fileType::TransformedBeam:
      //if (!m_pixelBeam)
      //  return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_transBeamGraph)
        *m_transBeamGraph = *graph;
      else
        m_transBeamGraph = new dataSpectrum(graph);
      break;
    /*
    case fileType::SpectralData:
      if (!m_spectData)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_spectDataGraph)
        *m_spectDataGraph = *graph;
      else
        m_spectDataGraph = new dataSpectrum(graph);
      break;
    case fileType::EnsembleData:
      if (!m_ensembleSpectData)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_ensembleDataGraph)
        *m_ensembleDataGraph = *graph;
      else
        m_ensembleDataGraph = new dataSpectrum(graph);
      break;
    */
    case fileType::EnsembleAveragedNoise:
      if (!m_ensembleAveragedNoise)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_ensembleAveragedNoiseGraph)
        *m_ensembleAveragedNoiseGraph = *graph;
      else
        m_ensembleAveragedNoiseGraph = new dataSpectrum(graph);
      break;
    case fileType::EnsembleAveragedSpectrum:
      if (!m_ensembleAveragedSpectrum)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_ensembleAveragedSpectrumGraph)
        *m_ensembleAveragedSpectrumGraph = *graph;
      else
        m_ensembleAveragedSpectrumGraph = new dataSpectrum(graph);
      break;
    case fileType::BinnedSpectrum:
      if (!m_binnedSpectrum)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_binnedSpectrumGraph)
        *m_binnedSpectrumGraph= *graph;
      else
        m_binnedSpectrumGraph = new dataSpectrum(graph);
      break;
    case fileType::EnsembleAveragedBinnedSpectrum:
      if (!m_ensembleAveragedBinnedSpectrum)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_ensembleAveragedBinnedSpectrumGraph)
        *m_ensembleAveragedBinnedSpectrumGraph = *graph;
      else
        m_ensembleAveragedBinnedSpectrumGraph = new dataSpectrum(graph);
      break;
    default:
      return false;
  }
  delete graph;

  switch (type) {
    case fileType::TransformedData:
    case fileType::TransformedWeights:
    case fileType::WeightedTransform:
    case fileType::TransformedNoise:
    case fileType::TransformedWeightedNoise:
    case fileType::TransformedFilter:
    case fileType::TransformedBeam:
      m_sequence = graphTransform;
      break;
    //case fileType::SpectralData:
    //case fileType::EnsembleData:
    case fileType::EnsembleAveragedNoise:
    case fileType::EnsembleAveragedSpectrum:
    case fileType::BinnedSpectrum:
    case fileType::EnsembleAveragedBinnedSpectrum:
      m_sequence = graphPowerSpectrum;
      break;
  }
  return true;
}

void association::addData(baseData *item) {
  if (!item)
    return;

  if (exists(item->dataType()))
    discardRelation(item->dataType());

  switch (item->dataType()) {
      case fileType::InputData:
      m_inputData = (matrixData<double>*)item;
      break;
    case fileType::InputWeights:
      m_inputWeights = (matrixData<double>*)item;
      break;
    case fileType::WeightedData:
      m_weightedInput = (matrixData<double>*)item;
      break;
    case fileType::InputNoise:
      m_inputNoise = (matrixData<double>*)item;
      break;
    case fileType::InputWeightedNoise:
      m_weightedNoise = (matrixData<double>*)item;
      break;
    case fileType::InputFilter:
      m_inputFilter = (matrixData<double>*)item;
      break;
    case fileType::InputBeam:
      m_inputBeam = (matrixData<double>*)item;
      break;

    case fileType::PixelizedData:
      m_pixelData = (vectorData<double>*)item;
      break;
    case fileType::PixelizedWeights:
      m_pixelWeights = (vectorData<double>*)item;
      break;
    case fileType::WeightedPixel:
      m_weightedPixel = (vectorData<double>*)item;
      break;
    case fileType::PixelOccupancy:
      m_pixelOccupancy = (vectorData<int>*)item;
      break;
    case fileType::PixelizedNoise:
      m_pixelNoise = (vectorData<double>*)item;
      break;
    case fileType::PixelizedWeightedNoise:
      m_pixelWeightedNoise = (vectorData<double>*)item;
      break;
    case fileType::PixelizedFilter:
      m_pixelFilter = (vectorData<double>*)item;
      break;
    case fileType::PixelizedBeam:
      m_pixelBeam = (vectorData<double>*)item;
      break;

    case fileType::InverseData:
      m_invData = (vectorData<double>*)item;
      break;
    case fileType::InverseWeights:
      m_invWeights = (vectorData<double>*)item;
      break;
    case fileType::WeightedInverse:
      m_weightedInverse = (vectorData<double>*)item;
      break;
    case fileType::InverseFilter:
      m_invFilter = (vectorData<double>*)item;
      break;
    case fileType::InverseBeam:
      m_invBeam = (vectorData<double>*)item;
      break;
    case fileType::InverseNoise:
      m_invNoise = (vectorData<double>*)item;
      break;
    case fileType::InverseWeightedNoise:
      m_invWeightedNoise = (vectorData<double>*)item;
      break;

    case fileType::TransformedData:
      m_transData = (vectorData<double>*)item;
      break;
    case fileType::TransformedWeights:
      m_transWeights = (vectorData<double>*)item;
      break;
    case fileType::WeightedTransform:
      m_weightedTransform = (vectorData<double>*)item;
      break;
    case fileType::TransformedFilter:
      m_transFilter = (vectorData<double>*)item;
      break;
    case fileType::TransformedBeam:
      m_transBeam = (vectorData<double>*)item;
      break;
    case fileType::TransformedNoise:
      m_transNoise = (vectorData<double>*)item;
      break;
    case fileType::TransformedWeightedNoise:
      m_transWeightedNoise = (vectorData<double>*)item;
      break;

    case fileType::AlmData:
      m_almData = (cubeData<std::complex<double> >*)item;
      break;
    case fileType::AlmWeights:
      m_almWeights = (cubeData<std::complex<double> >*)item;
      break;
    case fileType::WeightedAlm:
      m_weightedAlm = (cubeData<std::complex<double> >*)item;
      break;
    case fileType::AlmFilter:
      m_almFilter = (cubeData<std::complex<double>>*)item;
      break;
    case fileType::AlmBeam:
      m_almBeam = (cubeData<std::complex<double>>*)item;
      break;
    case fileType::AlmNoise:
      m_almNoise = (cubeData<std::complex<double>>*)item;
      break;
    case fileType::AlmWeightedNoise:
      m_weightedNoiseAlm = (cubeData<std::complex<double>>*)item;
      break;
    /*
    case fileType::SpectralData:
      m_spectData = (vectorData<double>*)item;
      break;
    case fileType::EnsembleData:
      m_ensembleSpectData = (vectorData<double>*)item;
      break;
    */
    case fileType::EnsembleAveragedNoise:
      m_ensembleAveragedNoise = (vectorData<double>*)item;
      break;
    case fileType::EnsembleIterationNoise:
      m_ensembleIterationNoise = (matrixData<double>*)item;
      break;
    case fileType::EnsembleAveragedSpectrum:
      m_ensembleAveragedSpectrum = (vectorData<double>*)item;
      break;
    case fileType::EnsembleIterationSpectrum:
      m_ensembleIterationSpectrum = (matrixData<double>*)item;
      break;
    case fileType::BinnedSpectrum:
      m_binnedSpectrum = (vectorData<double>*)item;
      break;
    case fileType::EnsembleAveragedBinnedSpectrum:
      m_ensembleAveragedBinnedSpectrum = (vectorData<double>*)item;
      break;
    case fileType::EnsembleIterationBinnedSpectrum:
      m_ensembleIterationBinnedSpectrum = (matrixData<double>*)item;
      break;
    case fileType::ModeModeMatrix:
      m_ModeModeMatrix = (matrixData<double>*)item;
      break;
    case fileType::InstrumentEffectsMatrix:
      m_InstrumentEffectsMatrix = (matrixData<double>*)item;
      break;
    case fileType::BinningMatrix:
      m_BinningMatrix = (matrixData<double>*)item;
      break;
    case fileType::UnbinningMatrix:
      m_UnbinningMatrix = (matrixData<double>*)item;
      break;
    case fileType::BinnedInstrumentEffectsMatrix:
      m_BinnedInstrumentEffectsMatrix = (matrixData<double>*)item;
      break;
    case fileType::InverseBinnedInstrumentMatrix:
      m_InverseBinnedInstrumentMatrix = (matrixData<double>*)item;
      break;
    default:
      break;
  }
}

SEQUENCE association::maxDataSet(GENERICTYPE type) {
  SEQUENCE seq = noSky;

  switch (type) {
    case Data:
      if (m_inputData)
        seq = setSky;
      if (m_pixelData)
        seq = pixelize;
      if (m_transData)
        seq = transform;
      //if (m_spectData)
      if(m_weightedTransform)
        seq = powerSpectrum;
      //if (m_ensembleSpectData)
      if(m_ensembleAveragedBinnedSpectrum)
        seq = DONE;
      break;
    case Weights:
      if (m_inputWeights)
        seq = setSky;
      if (m_pixelWeights)
        seq = pixelize;
      if (m_transWeights)
        seq = transform;
      //if (m_spectData)
      if(m_weightedTransform)
        seq = powerSpectrum;
      //if (m_ensembleSpectData)
      if(m_ensembleAveragedBinnedSpectrum)
        seq = DONE;
      break;
    case Noise:
      if (m_inputNoise)
        seq = setSky;
      if (m_pixelNoise)
        seq = pixelize;
      if (m_transNoise)
        seq = transform;
      //if (m_spectData)
      if(m_weightedTransform)
        seq = powerSpectrum;
      //if (m_ensembleSpectData)
      if(m_ensembleAveragedBinnedSpectrum)
        seq = DONE;
      break;
    case Filter:
      if (m_inputFilter)
        seq = setSky;
      if (m_pixelFilter)
        seq = pixelize;
      if (m_transFilter)
        seq = transform;
      //if (m_spectData)
      if(m_weightedTransform)
        seq = powerSpectrum;
      //if (m_ensembleSpectData)
      if(m_ensembleAveragedBinnedSpectrum)
        seq = DONE;
      break;
    case Beam:
      if (m_inputBeam)
        seq = setSky;
      if (m_pixelBeam)
        seq = pixelize;
      if (m_transBeam)
        seq = transform;
      //if (m_spectData)
      if(m_weightedTransform)
        seq = powerSpectrum;
      //if (m_ensembleSpectData)
      if(m_ensembleAveragedBinnedSpectrum)
        seq = DONE;
      break;
    case NoGeneric:
    default:
      break;
  }

  return seq;
}

SEQUENCE association::maxDataChain(GENERICTYPE type) {
  SEQUENCE seq = noSky;

  switch (type) {
    case Data:
      if (!m_inputData)
        break;
      seq = setSky;
      if (!m_pixelData)
        break;
      seq = pixelize;
      if (!m_transData)
        break;
      seq = transform;
      //if (!m_spectData)
      if(!m_weightedTransform)
        break;
      seq = powerSpectrum;
      //if (!m_ensembleSpectData)
      if(!m_ensembleAveragedBinnedSpectrum)
        break;
      seq = DONE;
      break;
    case Weights:
      if (!m_inputWeights)
        break;
      seq = setSky;
      if (!m_pixelWeights)
        break;
      seq = pixelize;
      if (!m_transWeights)
        break;
      seq = transform;
      //if (!m_spectData)
      if(!m_weightedTransform)
        break;
      seq = powerSpectrum;
      //if (!m_ensembleSpectData)
      if(!m_ensembleAveragedBinnedSpectrum)
        break;
      seq = DONE;
      break;
    case Noise:
      if (!m_inputNoise)
        break;
      seq = setSky;
      if (!m_pixelNoise)
        break;
      seq = pixelize;
      if (!m_transNoise)
        break;
      seq = transform;
      //if (!m_spectData)
      if(!m_weightedTransform)
        break;
      seq = powerSpectrum;
      //if (!m_ensembleSpectData)
      if(!m_ensembleAveragedBinnedSpectrum)
        break;
      seq = DONE;
      break;
    case Filter:
      if (!m_inputFilter)
        break;
      seq = setSky;
      if (!m_pixelFilter)
        break;
      seq = pixelize;
      if (!m_transFilter)
        break;
      seq = transform;
      //if (!m_spectData)
      if(!m_weightedTransform)
        break;
      seq = powerSpectrum;
      //if (!m_ensembleSpectData)
      if(!m_ensembleAveragedBinnedSpectrum)
        break;
      seq = DONE;
      break;
    case Beam:
      if (!m_inputBeam)
        break;
      seq = setSky;
      if (!m_pixelBeam)
        break;
      seq = pixelize;
      if (!m_transBeam)
        break;
      seq = transform;
      //if (!m_spectData)
      if(!m_weightedTransform)
        break;
      seq = powerSpectrum;
      //if (!m_ensembleSpectData)
      if(!m_ensembleAveragedBinnedSpectrum)
        break;
      seq = DONE;
      break;
    case NoGeneric:
    default:
        break;
  }

  return seq;
}

/*
  This method clears all dependent data structures in a
  "fall through" stack arrangement; e.g. calling for
  an InputData discard destroys ALL data on the Input
  Data portion of the chain.
*/
void association::discardRelation(FILETYPE type) {
  switch (type) {
    case fileType::InputData:
      if (m_inputData)
        delete m_inputData;
      m_inputData = 0;
    case fileType::PixelizedData:
      if (m_pixelData)
        delete m_pixelData;
      m_pixelData = 0;
    case fileType::TransformedData:
      if (m_transData)
        delete m_transData;
      m_transData = 0;
    case fileType::AlmData:
      if (m_almData)
        delete m_almData;
      m_almData = 0;
    case fileType::InverseData:
      if (m_invData)
        delete m_invData;
      m_invData = 0;
      break;
    /* End of fall through stack for input data */
    case fileType::InputWeights:
      if (m_inputWeights)
        delete m_inputWeights;
      m_inputWeights = 0;
    case fileType::PixelizedWeights:
      if (m_pixelWeights)
        delete m_pixelWeights;
      m_pixelWeights = 0;
    case fileType::TransformedWeights:
      if (m_transWeights)
        delete m_transWeights;
      m_transWeights = 0;
    case fileType::AlmWeights:
      if (m_almWeights)
        delete m_almWeights;
      m_almWeights = 0;
    case fileType::InverseWeights:
      if (m_invWeights)
        delete m_invWeights;
      m_invWeights = 0;
      break;
    /* End of input weights fall through stack */
    case fileType::WeightedData:
      if(m_weightedInput)
        delete m_weightedInput;
      m_weightedInput = 0;
    case fileType::WeightedPixel:
      if(m_weightedPixel)
        delete m_weightedPixel;
      m_weightedPixel = 0;
    case fileType::WeightedTransform:
      if(m_weightedTransform)
        delete m_weightedTransform;
      m_weightedTransform = 0;
    case fileType::WeightedAlm:
      if(m_weightedAlm)
        delete m_weightedAlm;
      m_weightedAlm = 0;
    case fileType::WeightedInverse:
      if(m_weightedInverse)
        delete m_weightedInverse;
      m_weightedInverse = 0;
      break;
      /* End of weighted fall through stack */
    case fileType::InputFilter:
      if (m_inputFilter)
        delete m_inputFilter;
      m_inputFilter = 0;
    case fileType::PixelizedFilter:
      if (m_pixelFilter)
        delete m_pixelFilter;
      m_pixelFilter = 0;
    case fileType::TransformedFilter:
      if (m_transFilter)
        delete m_transFilter;
      m_transFilter = 0;
      break;
    case fileType::AlmFilter:
      if (m_almFilter)
        delete m_almFilter;
      m_almFilter = 0;
    case fileType::InverseFilter:
      if (m_invFilter)
        delete m_invFilter;
      m_invFilter = 0;
      break;
    /* End of filter data fall through stack */
    case fileType::InputNoise:
      if (m_inputNoise)
        delete m_inputNoise;
      m_inputNoise = 0;
    case fileType::PixelizedNoise:
      if (m_pixelNoise)
        delete m_pixelNoise;
      m_pixelNoise = 0;
    case fileType::TransformedNoise:
      if (m_transNoise)
        delete m_transNoise;
      m_transNoise = 0;
    case fileType::AlmNoise:
      if (m_almNoise)
        delete m_almNoise;
      m_almNoise = 0;
    case fileType::InverseNoise:
      if (m_invNoise)
        delete m_invNoise;
      m_invNoise = 0;
      break;
    /* End of noise data fall through stack */
    case fileType::InputBeam:
      if (m_inputBeam)
        delete m_inputBeam;
      m_inputBeam = 0;
    case fileType::PixelizedBeam:
      if (m_pixelBeam)
        delete m_pixelBeam;
      m_pixelBeam = 0;
    case fileType::TransformedBeam:
      if (m_transBeam)
        delete m_transBeam;
      m_transBeam = 0;
    case fileType::AlmBeam:
      if (m_almBeam)
        delete m_almBeam;
      m_almBeam = 0;
    case fileType::InverseBeam:
      if (m_invBeam)
        delete m_invBeam;
      m_invBeam = 0;
      break;
    /* End of beam data fall through stack */
    case fileType::PixelOccupancy:
      if (m_pixelOccupancy)
        delete m_pixelOccupancy;
      m_pixelOccupancy = 0;
      break;
    /*
    case fileType::SpectralData:
      if (m_spectData)
        delete m_spectData;
      m_spectData = 0;
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
      if (m_couplingMatrix)
        delete m_couplingMatrix;
      m_couplingMatrix = 0;
      break;
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      if (m_inverseMatrix)
        delete m_inverseMatrix;
      m_inverseMatrix = 0;
    case fileType::EnsembleData:
      if (m_ensembleSpectData)
        delete m_ensembleSpectData;
      m_ensembleSpectData = 0;
      break;
    */
    case fileType::EnsembleAveragedNoise:
      if(m_ensembleAveragedNoise)
        delete m_ensembleAveragedNoise;
      m_ensembleAveragedNoise = 0;
    case fileType::EnsembleIterationNoise:
      if(m_ensembleIterationNoise)
        delete m_ensembleIterationNoise;
      m_ensembleIterationNoise = 0;
    case fileType::EnsembleAveragedSpectrum:
      if(m_ensembleAveragedSpectrum)
        delete m_ensembleAveragedSpectrum;
      m_ensembleAveragedSpectrum = 0;
    case fileType::EnsembleIterationSpectrum:
      if(m_ensembleIterationSpectrum)
        delete m_ensembleIterationSpectrum;
      m_ensembleIterationSpectrum = 0;
    case fileType::BinnedSpectrum:
      if(m_binnedSpectrum)
        delete m_binnedSpectrum;
      m_binnedSpectrum = 0;
    case fileType::EnsembleAveragedBinnedSpectrum:
      if(m_ensembleAveragedBinnedSpectrum)
        delete m_ensembleAveragedBinnedSpectrum;
      m_ensembleAveragedBinnedSpectrum = 0;
    case fileType::EnsembleIterationBinnedSpectrum:
      if(m_ensembleIterationBinnedSpectrum)
        delete m_ensembleIterationBinnedSpectrum;
      m_ensembleIterationBinnedSpectrum = 0;
    case fileType::ModeModeMatrix:
      if(m_ModeModeMatrix)
        delete m_ModeModeMatrix;
      m_ModeModeMatrix = 0;
    case fileType::InstrumentEffectsMatrix:
      if(m_InstrumentEffectsMatrix)
        delete m_InstrumentEffectsMatrix;
      m_InstrumentEffectsMatrix = 0;
    case fileType::BinningMatrix:
      if(m_BinningMatrix)
        delete m_BinningMatrix;
      m_BinningMatrix = 0;
    case fileType::UnbinningMatrix:
      if(m_UnbinningMatrix)
        delete m_UnbinningMatrix;
      m_UnbinningMatrix = 0;
    case fileType::BinnedInstrumentEffectsMatrix:
      if(m_BinnedInstrumentEffectsMatrix)
        delete m_BinnedInstrumentEffectsMatrix;
      m_BinnedInstrumentEffectsMatrix = 0;
    case fileType::InverseBinnedInstrumentMatrix:
      if(m_InverseBinnedInstrumentMatrix)
        delete m_InverseBinnedInstrumentMatrix;
      m_InverseBinnedInstrumentMatrix = 0;
    default:
      break;
  }
  return;
}

void association::reset() {
  m_uiObject = 0;
  m_updateFunc = 0;
  m_showProgress = false;

  m_pixelAverage = 0;
  m_pixelVariance = 0;

  if (m_workSpace)
    delete m_workSpace;
  m_workSpace = 0;
  
  if(m_tmpSpace)
    delete m_tmpSpace;
  m_tmpSpace = 0;

  resetData();
  resetMaps();
  resetEngines();
}

void association::reset(ALLTYPES id) {
  switch (id) {
      case allTypes::InputData:
      if (m_inputData)
        delete m_inputData;
       m_inputData = 0;
       break;
    case allTypes::InputWeights:
      if (m_inputWeights)
        delete m_inputWeights;
      m_inputWeights = 0;
      break;
    case allTypes::WeightedData:
      if(m_weightedInput)
        delete m_weightedInput;
      m_weightedInput = 0;
      break;
    case allTypes::InputNoise:
      if (m_inputNoise)
        delete m_inputNoise;
       m_inputNoise = 0;
       break;
    case allTypes::InputWeightedNoise:
      if(m_weightedNoise)
        delete m_weightedNoise;
      m_weightedNoise = 0;
      break;
    case allTypes::InputFilter:
      if (m_inputFilter)
        delete m_inputFilter;
       m_inputFilter = 0;
       break;
    case allTypes::InputBeam:
      if (m_inputBeam)
        delete m_inputBeam;
       m_inputBeam = 0;
       break;

    case allTypes::PixelizedData:
      if (m_pixelData)
        delete m_pixelData;
       m_pixelData = 0;
       break;
    case allTypes::PixelizedWeights:
      if (m_pixelWeights)
        delete m_pixelWeights;
       m_pixelWeights = 0;
       break;
    case allTypes::WeightedPixel:
      if(m_weightedPixel)
        delete m_weightedPixel;
      m_weightedPixel = 0;
      break;
    case allTypes::PixelizedNoise:
      if (m_pixelNoise)
        delete m_pixelNoise;
       m_pixelNoise = 0;
       break;
    case allTypes::PixelizedWeightedNoise:
      if(m_pixelWeightedNoise)
        delete m_pixelWeightedNoise;
      m_pixelWeightedNoise = 0;
      break;
    case allTypes::PixelizedFilter:
      if (m_pixelFilter)
        delete m_pixelFilter;
       m_pixelFilter = 0;
       break;
    case allTypes::PixelizedBeam:
      if (m_pixelBeam)
        delete m_pixelBeam;
       m_pixelBeam = 0;
       break;
    case allTypes::PixelOccupancy:
      if (m_pixelOccupancy)
        delete m_pixelOccupancy;
       m_pixelOccupancy = 0;
       break;

    case allTypes::InverseData:
      if (m_invData)
        delete m_invData;
       m_invData = 0;
       break;
    case allTypes::InverseWeights:
      if (m_invWeights)
        delete m_invWeights;
       m_invWeights = 0;
       break;
    case allTypes::WeightedInverse:
      if(m_weightedInverse)
        delete m_weightedInverse;
      m_weightedInverse = 0;
      break;
    case allTypes::InverseNoise:
      if (m_invNoise)
        delete m_invNoise;
       m_invNoise = 0;
       break;
    case allTypes::InverseWeightedNoise:
      if(m_invWeightedNoise)
        delete m_invWeightedNoise;
      m_invWeightedNoise = 0;
      break;
    case allTypes::InverseFilter:
      if (m_invFilter)
        delete m_invFilter;
       m_invFilter = 0;
       break;
    case allTypes::InverseBeam:
      if (m_invBeam)
        delete m_invBeam;
       m_invBeam = 0;
       break;

    case allTypes::TransformedData:
      if (m_transData)
        delete m_transData;
       m_transData = 0;
       break;
    case allTypes::TransformedWeights:
      if (m_transWeights)
        delete m_transWeights;
       m_transWeights = 0;
       break;
    case allTypes::WeightedTransform:
      if(m_weightedTransform)
        delete m_weightedTransform;
      m_weightedTransform = 0;
      break;
    case allTypes::TransformedNoise:
      if (m_transNoise)
        delete m_transNoise;
       m_transNoise = 0;
       break;
    case allTypes::TransformedWeightedNoise:
      if(m_transWeightedNoise)
          delete m_transWeightedNoise;
      m_transWeightedNoise = 0;
      break;
    case allTypes::TransformedFilter:
      if (m_transFilter)
        delete m_transFilter;
       m_transFilter = 0;
       break;
    case allTypes::TransformedBeam:
      if (m_transBeam)
        delete m_transBeam;
       m_transBeam = 0;
       break;
    /*
    case allTypes::SpectralData:
      if (m_spectData)
        delete m_spectData;
       m_spectData = 0;
       break;
    case allTypes::EnsembleData:
      if (m_ensembleSpectData)
        delete m_ensembleSpectData;
       m_ensembleSpectData = 0;
       break;
    */
    case allTypes::AlmData:
      if (m_almData)
        delete m_almData;
       m_almData = 0;
       break;
    case allTypes::AlmWeights:
      if (m_almWeights)
        delete m_almWeights;
       m_almWeights = 0;
       break;
    case allTypes::WeightedAlm:
      if(m_weightedAlm)
        delete m_weightedAlm;
      m_weightedAlm = 0;
      break;
    case allTypes::AlmNoise:
      if (m_almNoise)
        delete m_almNoise;
       m_almNoise = 0;
       break;
    case allTypes::AlmWeightedNoise:
      if(m_weightedNoiseAlm)
        delete m_weightedNoiseAlm;
      m_weightedNoiseAlm = 0;
      break;
    case allTypes::AlmFilter:
      if (m_almFilter)
        delete m_almFilter;
       m_almFilter = 0;
       break;
    case allTypes::AlmBeam:
      if (m_almBeam)
        delete m_almBeam;
       m_almBeam = 0;
       break;
    /*
    case allTypes::BinCouplingMatrix:
    case allTypes::ModeCouplingMatrix:
      if (m_couplingMatrix)
        delete m_couplingMatrix;
       m_couplingMatrix = 0;
       break;
    case allTypes::InverseBinMatrix:
    case allTypes::InverseModeMatrix:
      if (m_inverseMatrix)
        delete m_inverseMatrix;
       m_inverseMatrix = 0;
       break;
    */

    case allTypes::EnsembleAveragedNoise:
      if(m_ensembleAveragedNoise)
        delete m_ensembleAveragedNoise;
      m_ensembleAveragedNoise = 0;
      break;
    case allTypes::EnsembleIterationNoise:
      if(m_ensembleIterationNoise)
        delete m_ensembleIterationNoise;
      m_ensembleIterationNoise = 0;
      break;
    case allTypes::EnsembleAveragedSpectrum:
      if(m_ensembleAveragedSpectrum)
        delete m_ensembleAveragedSpectrum;
      m_ensembleAveragedSpectrum = 0;
      break;
    case allTypes::EnsembleIterationSpectrum:
      if(m_ensembleIterationSpectrum)
        delete m_ensembleIterationSpectrum;
      m_ensembleIterationSpectrum = 0;
      break;
    case allTypes::BinnedSpectrum:
      if(m_binnedSpectrum)
        delete m_binnedSpectrum;
      m_binnedSpectrum = 0;
      break;
    case allTypes::EnsembleAveragedBinnedSpectrum:
      if(m_ensembleAveragedBinnedSpectrum)
        delete m_ensembleAveragedBinnedSpectrum;
      m_ensembleAveragedBinnedSpectrum = 0;
      break;
    case allTypes::EnsembleIterationBinnedSpectrum:
      if(m_ensembleIterationBinnedSpectrum)
        delete m_ensembleIterationBinnedSpectrum;
      m_ensembleIterationBinnedSpectrum = 0;
      break;
    case allTypes::ModeModeMatrix:
      if(m_ModeModeMatrix)
        delete m_ModeModeMatrix;
      m_ModeModeMatrix = 0;
      break;
    case allTypes::InstrumentEffectsMatrix:
      if(m_InstrumentEffectsMatrix)
        delete m_InstrumentEffectsMatrix;
      m_InstrumentEffectsMatrix = 0;
      break;
    case allTypes::BinningMatrix:
      if(m_BinningMatrix)
        delete m_BinningMatrix;
      m_BinningMatrix = 0;
      break;
    case allTypes::UnbinningMatrix:
      if(m_UnbinningMatrix)
        delete m_UnbinningMatrix;
      m_UnbinningMatrix = 0;
      break;
    case allTypes::BinnedInstrumentEffectsMatrix:
      if(m_BinnedInstrumentEffectsMatrix)
        delete m_BinnedInstrumentEffectsMatrix;
      m_BinnedInstrumentEffectsMatrix = 0;
      break;
    case allTypes::InverseBinnedInstrumentMatrix:
      if(m_InverseBinnedInstrumentMatrix)
        delete m_InverseBinnedInstrumentMatrix;
      m_InverseBinnedInstrumentMatrix = 0;
      break;

    case allTypes::InputDataMap:
      if (m_inputDataMap)
        delete m_inputDataMap;
       m_inputDataMap = 0;
       break;
    case allTypes::InputWeightsMap:
      if (m_inputWeightsMap)
        delete m_inputWeightsMap;
       m_inputWeightsMap = 0;
       break;
    case allTypes::WeightedDataMap:
      if (m_inputMap)
        delete m_inputMap;
       m_inputMap = 0;
       break;
    case allTypes::InputNoiseMap:
      if (m_inputNoiseMap)
        delete m_inputNoiseMap;
       m_inputNoiseMap = 0;
       break;
    case allTypes::InputWeightedNoiseMap:
      if(m_weightedNoiseMap)
        delete m_weightedNoiseMap;
      m_weightedNoiseMap = 0;
      break;
    case allTypes::InputFilterMap:
      if (m_inputFilterMap)
        delete m_inputFilterMap;
       m_inputFilterMap = 0;
       break;
    case allTypes::InputBeamMap:
      if (m_inputBeamMap)
        delete m_inputBeamMap;
       m_inputBeamMap = 0;
       break;

    case allTypes::PixelizedDataMap:
      if (m_pixelDataMap)
        delete m_pixelDataMap;
       m_pixelDataMap = 0;
       break;
    case allTypes::PixelizedWeightsMap:
      if (m_pixelWeightsMap)
        delete m_pixelWeightsMap;
       m_pixelWeightsMap = 0;
       break;
    case allTypes::WeightedPixelMap:
      if (m_pixelMap)
        delete m_pixelMap;
       m_pixelMap = 0;
       break;
    case allTypes::PixelOccupancyMap:
      if (m_pixelOccupancyMap)
        delete m_pixelOccupancyMap;
       m_pixelOccupancyMap = 0;
       break;
    case allTypes::PixelizedNoiseMap:
      if (m_pixelNoiseMap)
        delete m_pixelNoiseMap;
       m_pixelNoiseMap = 0;
       break;
    case allTypes::PixelizedWeightedNoiseMap:
      if(m_pixelWeightedNoiseMap)
        delete m_pixelWeightedNoiseMap;
      m_pixelWeightedNoiseMap = 0;
      break;
    case allTypes::PixelizedFilterMap:
      if (m_pixelFilterMap)
        delete m_pixelFilterMap;
       m_pixelFilterMap = 0;
       break;
    case allTypes::PixelizedBeamMap:
      if (m_pixelBeamMap)
        delete m_pixelBeamMap;
       m_pixelBeamMap = 0;
       break;

    case allTypes::InverseDataMap:
      if (m_invDataMap)
        delete m_invDataMap;
       m_invDataMap = 0;
       break;
    case allTypes::InverseWeightsMap:
      if (m_invWeightsMap)
        delete m_invWeightsMap;
       m_invWeightsMap = 0;
       break;
    case allTypes::WeightedInverseMap:
      if (m_invMap)
        delete m_invMap;
       m_invMap = 0;
       break;
    case allTypes::InverseNoiseMap:
      if (m_invNoiseMap)
        delete m_invNoiseMap;
       m_invNoiseMap = 0;
       break;
    case allTypes::InverseWeightedNoiseMap:
      if(m_invWeightedNoiseMap)
        delete m_invWeightedNoiseMap;
      m_invWeightedNoiseMap = 0;
      break;
    case allTypes::InverseBeamMap:
      if (m_invBeamMap)
        delete m_invBeamMap;
       m_invBeamMap = 0;
       break;

    case allTypes::TransformedDataSpectrum:
      if (m_transDataGraph)
        delete m_transDataGraph;
       m_transDataGraph = 0;
       break;
    case allTypes::TransformedWeightsSpectrum:
      if (m_transWeightsGraph)
        delete m_transWeightsGraph;
       m_transWeightsGraph = 0;
       break;
    case allTypes::WeightedTransformSpectrum:
      if (m_transGraph)
        delete m_transGraph;
       m_transGraph = 0;
       break;
    case allTypes::TransformedNoiseSpectrum:
      if (m_transNoiseGraph)
        delete m_transNoiseGraph;
       m_transNoiseGraph = 0;
       break;
    case allTypes::TransformedWeightedNoiseSpectrum:
      if(m_transWeightedNoiseGraph)
        delete m_transWeightedNoiseGraph;
      m_transWeightedNoiseGraph = 0;
      break;
    case allTypes::TransformedFilterSpectrum:
      if (m_transFilterGraph)
        delete m_transFilterGraph;
       m_transFilterGraph = 0;
       break;
    case allTypes::TransformedBeamSpectrum:
      if (m_transBeamGraph)
        delete m_transBeamGraph;
       m_transBeamGraph = 0;
       break;
    /*case allTypes::SpectralDataSpectrum:
      if (m_spectDataGraph)
        delete m_spectDataGraph;
       m_spectDataGraph = 0;
       break;
    case allTypes::EnsembleDataSpectrum:
      if (m_ensembleDataGraph)
        delete m_ensembleDataGraph;
       m_ensembleDataGraph = 0;
       break;
    */
    case allTypes::EnsembleAveragedNoiseSpectrum:
      if(m_ensembleAveragedNoiseGraph)
        delete m_ensembleAveragedNoiseGraph;
      m_ensembleAveragedNoiseGraph = 0;
      break;
    case allTypes::EnsembleAveragedSpectrumSpectrum:
      if(m_ensembleAveragedSpectrumGraph)
        delete m_ensembleAveragedSpectrumGraph;
      m_ensembleAveragedSpectrumGraph = 0;
      break;
    case allTypes::BinnedSpectrumSpectrum:
      if(m_binnedSpectrumGraph)
        delete m_binnedSpectrumGraph;
      m_binnedSpectrumGraph = 0;
      break;
    case allTypes::EnsembleAveragedBinnedSpectrumSpectrum:
      if(m_ensembleAveragedBinnedSpectrumGraph)
        delete m_ensembleAveragedBinnedSpectrumGraph;
      m_ensembleAveragedBinnedSpectrumGraph = 0;
      break;

    case allTypes::fileIO:
      if (m_fileIOEngine)
        delete m_fileIOEngine;
       m_fileIOEngine = 0;
       break;
    case allTypes::Mapping:
      if (m_mapEngine)
        delete m_mapEngine;
      m_mapEngine = 0;
      break;
    case allTypes::Graphing:
      if (m_graphEngine)
        delete m_graphEngine;
      m_graphEngine = 0;
      break;
    case allTypes::Pixelization:
      if (m_pixelEngine)
        delete m_pixelEngine;
       m_pixelEngine = 0;
       break;
    case allTypes::Transformation:
      if (m_transformEngine)
        delete m_transformEngine;
       m_transformEngine = 0;
       break;
    case allTypes::PseudoSpectrum:
      if (m_powSpectEngine)
        delete m_powSpectEngine;
       m_powSpectEngine = 0;
       break;
    case allTypes::ALLTYPE_LIMIT:
         default:
      break;
  }
}

void association::resetData() {
  if (m_inputData)
    delete m_inputData;
  m_inputData = 0;

  if (m_inputWeights)
    delete m_inputWeights;
  m_inputWeights = 0;

  if(m_weightedInput)
    delete m_weightedInput;
  m_weightedInput = 0;

  if (m_inputFilter)
    delete m_inputFilter;
  m_inputFilter = 0;

  if (m_inputNoise)
    delete m_inputNoise;
  m_inputNoise = 0;

  if(m_weightedNoise)
    delete m_weightedNoise;
  m_weightedNoise = 0;

  if (m_inputBeam)
    delete m_inputBeam;
  m_inputBeam = 0;

  /*********************************/
  if (m_pixelData)
    delete m_pixelData;
  m_pixelData = 0;

  if (m_pixelWeights)
    delete m_pixelWeights;
  m_pixelWeights = 0;

  if(m_weightedPixel)
    delete m_weightedPixel;
  m_weightedPixel = 0;

  if (m_pixelOccupancy)
    delete m_pixelOccupancy;
  m_pixelOccupancy = 0;

  if (m_pixelFilter)
    delete m_pixelFilter;
  m_pixelFilter = 0;

  if (m_pixelNoise)
    delete m_pixelNoise;
  m_pixelNoise = 0;

  if(m_pixelWeightedNoise)
    delete m_pixelWeightedNoise;
  m_pixelWeightedNoise = 0;

  if (m_pixelBeam)
    delete m_pixelBeam;
  m_pixelBeam = 0;

  /*********************************/
  if (m_invData)
    delete m_invData;
  m_invData = 0;

  if (m_invWeights)
    delete m_invWeights;
  m_invWeights = 0;

  if(m_weightedInverse)
    delete m_weightedInverse;
  m_weightedInverse = 0;

  if(m_invFilter)
    delete m_invFilter;
  m_invFilter = 0;

  if(m_invBeam)
    delete m_invBeam;
  m_invBeam =0;

  if(m_invNoise)
    delete m_invNoise;
  m_invNoise = 0;

  if(m_invWeightedNoise)
    delete m_invWeightedNoise;
  m_invWeightedNoise = 0;

  /*********************************/
  if (m_transData)
    delete m_transData;
  m_transData = 0;

  if (m_transWeights)
    delete m_transWeights;
  m_transWeights = 0;

  if(m_weightedTransform)
    delete m_weightedTransform;
  m_weightedTransform = 0;

  if (m_transFilter)
    delete m_transFilter;
  m_transFilter = 0;

  if (m_transNoise)
    delete m_transNoise;
  m_transNoise = 0;

  if (m_transBeam)
    delete m_transBeam;
  m_transBeam = 0;

  /********************************/
  if (m_almData)
    delete m_almData;
  m_almData = 0;

  if (m_almWeights)
    delete m_almWeights;
  m_almWeights = 0;

  if(m_weightedAlm)
    delete m_weightedAlm;
  m_weightedAlm = 0;

  if(m_almFilter)
    delete m_almFilter;
  m_almFilter = 0;

  if(m_almBeam)
    delete m_almBeam;
  m_almBeam = 0;

  if(m_almNoise)
    delete m_almNoise;
  m_almNoise = 0;

  if(m_weightedNoiseAlm)
    delete m_weightedNoiseAlm;
  m_weightedNoiseAlm = 0;

  /*
  if (m_spectData)
    delete m_spectData;
  m_spectData = 0;

  if (m_ensembleSpectData)
    delete m_ensembleSpectData;
  m_ensembleSpectData = 0;

  if (m_couplingMatrix)
    delete m_couplingMatrix;
  m_couplingMatrix = 0;

  if (m_inverseMatrix)
    delete m_inverseMatrix;
  m_inverseMatrix = 0;
  */

  if(m_ensembleAveragedNoise)
    delete m_ensembleAveragedNoise;
  m_ensembleAveragedNoise = 0;

  if(m_ensembleIterationNoise)
    delete m_ensembleIterationNoise;
  m_ensembleIterationNoise = 0;

  if(m_ensembleAveragedSpectrum)
    delete m_ensembleAveragedSpectrum;
  m_ensembleAveragedSpectrum = 0;

  if(m_ensembleIterationSpectrum)
    delete m_ensembleIterationSpectrum;
  m_ensembleIterationSpectrum = 0;

  if(m_binnedSpectrum)
    delete m_binnedSpectrum;
  m_binnedSpectrum = 0;

  if(m_ensembleAveragedBinnedSpectrum)
    delete m_ensembleAveragedBinnedSpectrum;
  m_ensembleAveragedBinnedSpectrum = 0;

  if(m_ensembleIterationBinnedSpectrum)
    delete m_ensembleIterationBinnedSpectrum;
  m_ensembleIterationBinnedSpectrum = 0;

  if(m_ModeModeMatrix)
    delete m_ModeModeMatrix;
  m_ModeModeMatrix = 0;

  if(m_InstrumentEffectsMatrix)
    delete m_InstrumentEffectsMatrix;
  m_InstrumentEffectsMatrix = 0;

  if(m_BinningMatrix)
    delete m_BinningMatrix;
  m_BinningMatrix = 0;

  if(m_UnbinningMatrix)
    delete m_UnbinningMatrix;
  m_UnbinningMatrix = 0;

  if(m_BinnedInstrumentEffectsMatrix)
    delete m_BinnedInstrumentEffectsMatrix;
  m_BinnedInstrumentEffectsMatrix = 0;

  if(m_InverseBinnedInstrumentMatrix)
    delete m_InverseBinnedInstrumentMatrix;
  m_InverseBinnedInstrumentMatrix = 0;
}

void association::resetMaps() {
  if (m_inputDataMap)
    delete m_inputDataMap;
  m_inputDataMap = 0;

  if (m_inputWeightsMap)
    delete m_inputWeightsMap;
  m_inputWeightsMap = 0;
  
  if (m_inputMap)
    delete m_inputMap;
  m_inputMap = 0;

  if (m_pixelDataMap)
    delete m_pixelDataMap;
  m_pixelDataMap = 0;

  if (m_pixelWeightsMap)
    delete m_pixelWeightsMap;
  m_pixelWeightsMap = 0;
  
  if (m_pixelMap)
    delete m_pixelMap;
  m_pixelMap = 0;

  if (m_pixelOccupancyMap)
    delete m_pixelOccupancyMap;
  m_pixelOccupancyMap = 0;

  if (m_invDataMap)
    delete m_invDataMap;
  m_invDataMap = 0;

  if (m_invWeightsMap)
    delete m_invWeightsMap;
  m_invWeightsMap = 0;
  
  if (m_invMap)
    delete m_invMap;
  m_invMap = 0;
  
  if (m_inputNoiseMap)
    delete m_inputNoiseMap;
  m_inputNoiseMap = 0;

  if(m_weightedNoiseMap)
    delete m_weightedNoiseMap;
  m_weightedNoiseMap = 0;
  
  if (m_pixelNoiseMap)
    delete m_pixelNoiseMap;
  m_pixelNoiseMap = 0;

  if(m_pixelWeightedNoiseMap)
    delete m_pixelWeightedNoiseMap;
  m_pixelWeightedNoiseMap = 0;
  
  if (m_inputFilterMap)
    delete m_inputFilterMap;
  m_inputFilterMap = 0;
  
  if (m_pixelFilterMap)
    delete m_pixelFilterMap;
  m_pixelFilterMap = 0;
  
  if (m_inputBeamMap)
    delete m_inputBeamMap;
  m_inputBeamMap = 0;
  
  if (m_pixelBeamMap)
    delete m_pixelBeamMap;
  m_pixelBeamMap = 0;
}

void association::resetGraphs() {
  if (m_transDataGraph)
    delete m_transDataGraph;
  m_transDataGraph = 0;

  if (m_transWeightsGraph)
    delete m_transWeightsGraph;
  m_transWeightsGraph = 0;

  if(m_transGraph)
    delete m_transGraph;
  m_transGraph = 0;

  if (m_transNoiseGraph)
    delete m_transNoiseGraph;
  m_transNoiseGraph = 0;

  if(m_transWeightedNoiseGraph)
    delete m_transWeightedNoiseGraph;
  m_transWeightedNoiseGraph = 0;

  if (m_transFilterGraph)
    delete m_transFilterGraph;
  m_transFilterGraph = 0;

  if (m_transBeamGraph)
    delete m_transBeamGraph;
  m_transBeamGraph = 0;

  /*
  if (m_spectDataGraph)
    delete m_spectDataGraph;
  m_spectDataGraph = 0;

  if (m_ensembleDataGraph)
    delete m_ensembleDataGraph;
  m_ensembleDataGraph = 0;
  */
  if(m_ensembleAveragedNoiseGraph)
    delete m_ensembleAveragedNoiseGraph;
  m_ensembleAveragedNoiseGraph = 0;

  if(m_ensembleAveragedSpectrumGraph)
    delete m_ensembleAveragedSpectrumGraph;
  m_ensembleAveragedSpectrumGraph = 0;

  if(m_binnedSpectrumGraph)
    delete m_binnedSpectrumGraph;
  m_binnedSpectrumGraph = 0;

  if(m_ensembleAveragedBinnedSpectrumGraph)
    delete m_ensembleAveragedBinnedSpectrumGraph;
  m_ensembleAveragedBinnedSpectrumGraph = 0;
}

void association::resetEngines() {
  if (m_fileIOEngine)
    delete m_fileIOEngine;
  m_fileIOEngine = 0;

  if (m_mapEngine)
    delete m_mapEngine;
  m_mapEngine = 0;

  if (m_graphEngine)
    delete m_graphEngine;
  m_graphEngine = 0;

  if (m_pixelEngine)
    delete m_pixelEngine;
  m_pixelEngine = 0;

  if (m_transformEngine)
    delete m_transformEngine;
  m_transformEngine = 0;

  if (m_powSpectEngine)
    delete m_powSpectEngine;
  m_powSpectEngine = 0;
}

// Pass in watching object uiObject and function to call when progress bar is updated.
//  Watching object will read from data set in callback fx.

/*
void association::setProgressFunc(void* uiObject,void (*func)(void*,int, const char*)) {
  m_uiObject = uiObject;
  m_updateFunc = func;
  if(m_uiObject && m_updateFunc)
    m_showProgress = true;
}
*/
