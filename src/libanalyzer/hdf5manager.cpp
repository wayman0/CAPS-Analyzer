/***************************************************************************
 *   hdf5manager.cpp                                                       *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * This header provides the definitions for various enumerated lists used  *
 * by the data classes.                                                    *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#include <string.h>
#include <H5Cpp.h>

#include "hdf5manager.h"
#include "basedata.h"
#include "association.h"
#include <math.h>
#include "pixelizer.h"
#include "transformer.h"

HDF5Manager::HDF5Manager(association* dataMgr, const char *filename, FILETYPE dataType, H5RWMode mode)
           : fileManager() {
  *hdf5_err = 0;
  s_association = dataMgr;

  if (!filename) {
    m_err = fileInvalidError;
    s_association->errorValue(m_err);
    throw m_err;
  }

  H5::Exception::dontPrint();
  try
  {
    m_ptr = new H5::H5File(filename, H5RWMode::RDWR);
  }
  catch(H5::Exception& err)
  {
    try
    {
      m_ptr = new H5::H5File(filename, H5RWMode::TRUNCATE);
    }
    catch (H5::Exception& err)
    {
      m_err = fileFitsError;
      snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
      m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
      s_association->errorValue(m_err);
      s_association->errorDetails(m_errDetail);
      throw m_err;
    }
  }

  try
  {
    H5Complex->insertMember("real", 0, *H5Double);
    H5Complex->insertMember("imag", sizeof(H5Double), *H5Double);
  }
  catch(H5::Exception& err)
  {
    m_err = fileFitsError;
    snprintf(hdf5_err, HDF5_ERR_LEN, "%s", err.getCDetailMsg());
    m_errDetail = errorText[abs(m_err)];
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);

    throw m_err;
  }

  m_fileDataType = dataType;
  fileName(filename);
  m_fileFormat = HDF5;
}

HDF5Manager::HDF5Manager(association* dataMgr, const char *filename, baseData *data)
           : fileManager() {
  *hdf5_err = 0;
  s_association = dataMgr;

  if (!data || !filename) {
    m_err = fileInvalidError;
    s_association->errorValue(m_err);
    throw m_err;
  }

  H5::Exception::dontPrint();
  try
  {
    m_ptr = new H5::H5File(filename, H5RWMode::RDWR);
  }
  catch(H5::Exception& err)
  {
    try
    {
      m_ptr = new H5::H5File(filename, H5RWMode::TRUNCATE);
    }
    catch (H5::Exception& err)
    {
      m_err = fileFitsError;
      snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
      m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
      s_association->errorValue(m_err);
      s_association->errorDetails(m_errDetail);
      throw m_err;
    }
  }

  try
  {
    H5Complex->insertMember("real", 0, *H5Double);
    H5Complex->insertMember("imag", sizeof(H5Double), *H5Double);
  }
  catch(H5::Exception& err)
  {
    m_err = fileFitsError;
    snprintf(hdf5_err, HDF5_ERR_LEN, "%s", err.getCDetailMsg());
    m_errDetail = errorText[abs(m_err)];
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);

    throw m_err;
  }

  fileName(filename);
  m_fileDataType = data->dataType();
  m_fileFormat   = HDF5;
  m_observatory  = Analyzer;
  m_cols         = data->cols();
  m_rows         = data->rows();
  m_slices       = data->slices();
  /*
  switch (m_fileDataType) {
      case fileType::Null:
      m_err = fileInvalidError;
      s_association->errorValue(m_err);
      throw m_err;
    case fileType::InputData:
    case fileType::InputWeights:
    case fileType::WeightedData:
    case fileType::InputNoise:
    case fileType::InputFilter:
    case fileType::InputBeam:
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      m_dimensions = 2;
      m_parts = 1;
      //m_fitsType = fitsDouble;
      if (!saveBase(filename)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " +  std::string(hdf5_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      if (!saveMatrixD((matrixData<double>*)data)) {
//      if (!saveMatrixD(m_fileDataType)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      break;
    case fileType::AlmData:
    case fileType::AlmWeights:
    case fileType::AlmNoise:
    case fileType::AlmFilter:
    case fileType::AlmBeam:
      m_dimensions = 4;
      m_parts = 2;
      //m_fitsType = fitsDouble;
      if (!saveBase(filename)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      if (!saveCubeCD((cubeData<complex<double> >*)data)) {
//      if (!saveCubeCD(m_fileDataType)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      break;
    case fileType::PixelOccupancy:
      m_dimensions = 1;
      m_parts = 1;
      //m_fitsType = fitsInt32;
      if (!saveBase(filename)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      if (!saveVectorI((vectorData<int>*)data)) {
//      if (!saveVectorI(m_fileDataType)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      break;
    default:
      m_dimensions = 1;
      m_parts = 1;
      //m_fitsType = fitsDouble;
      if (!saveBase(filename)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      if (!saveVectorD((vectorData<double>*)data)) {
//      if (!saveVectorD(m_fileDataType)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      break;
  }
  */
}

HDF5Manager::HDF5Manager(HDF5Manager* from)
           : fileManager(from) {
  m_ptr =      from->filePtr();
  //m_fitsType = from->fitsType();
}

HDF5Manager::~HDF5Manager() {
  if (m_ptr) {
    delete m_ptr;
    m_ptr = 0;
  }
}

bool HDF5Manager::saveBase(const char* filename, int* numTypes, FILETYPE* dataTypes)
{
  std::string text, comment = "Analyzer";

  if(!m_ptr)
  {
    try
    {
      m_ptr = new H5::H5File(filename, H5RWMode::RDWR);
    }
    catch(H5::Exception& err)
    {
      try
      {
        m_ptr = new H5::H5File(filename, H5RWMode::TRUNCATE);
      }
      catch (H5::Exception& err)
      {
        m_err = fileFitsError;
        snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        return false;
      }
    }
  }

  /* All data saved will be tagged as "Analyzer" data. In memory
     data generated from other observatories will be noted as such in
     the FITS comment section... */
  if(m_observatory >= OBSERVATORY_LIMIT)
    m_observatory = Analyzer;

  if (m_observatory != Analyzer) {
    text = observatoryNames[(int)m_observatory];
    comment += "\tCompiled from ";
    comment += text;
    comment += " data file.";
    m_observatory = Analyzer;
  }

  FILETYPE dataType = fileType::Null;

  int numDims = 2;
  hsize_t dims[numDims];
  dims[0] = 2;
  dims[1] = (*numTypes) + 1;

  //const char* infoData[dims[0]][dims[1]];
  //infoData[0][0] = "TELESCOPE";
  //infoData[1][0] = comment.c_str();

  int offset = dims[1];
  const char** infoData = new const char*[dims[0]*dims[1]];
  infoData[0] = "TELESCOPE";
  infoData[offset] = comment.c_str();
  for(int i = 0; i < *numTypes; i += 1)
  {
    infoData[i+1] = "DATA STEP";
    infoData[offset + i + 1] = (dataTypeNames[static_cast<int>(dataTypes[i])]).c_str();
    //infoData[0][i+1] = "Data Step";
    //infoData[1][i+1] = (dataTypeNames[static_cast<int>(dataTypes[i])]).c_str();
  }

  // save the info first
  try
  {
    if(!m_ptr->exists(infoGroupName))
      infoGroup = new H5::Group(m_ptr->createGroup(infoGroupName));
    else
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));

    if(infoGroup->exists("PRIMARY"))
      infoGroup->unlink("PRIMARY"); // essentially deletes PRIMARY dataset

    currInfoDataSpace = new H5::DataSpace(numDims, dims);
    currInfoDataSet   = new H5::DataSet(infoGroup->createDataSet("PRIMARY", *H5String, *currInfoDataSpace));
    currInfoDataSet->write(infoData, *H5String, *currInfoDataSpace);

    currInfoDataSpace->close();
    currInfoDataSet->close();
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    return false;
  }

  // build the info tree structure
 try
 {
    if(!infoGroup->exists("DATA"))
      infoGroup->createGroup("DATA");

    if(!infoGroup->exists("WEIGHTS"))
      infoGroup->createGroup("WEIGHTS");

    if(!infoGroup->exists("WEIGHTED"))
      infoGroup->createGroup("WEIGHTED");

    if(!infoGroup->exists("NOISE"))
      infoGroup->createGroup("NOISE");

    if(!infoGroup->exists("FILTER"))
      infoGroup->createGroup("FILTER");

    if(!infoGroup->exists("BEAM"))
      infoGroup->createGroup("BEAM");

    if(!infoGroup->exists("OCCUPANCY"))
      infoGroup->createGroup("OCCUPANCY");

    if(!infoGroup->exists("SPECTRUM"))
      infoGroup->createGroup("SPECTRUM");
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    return false;
  }

  // build the data tree structure
  try
  {
    if(!m_ptr->exists(dataGroupName))
      dataGroup = new H5::Group(m_ptr->createGroup(dataGroupName));
    else
      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));

    if(!dataGroup->exists("DATA"))
      dataGroup->createGroup("DATA");

    if(!dataGroup->exists("WEIGHTS"))
      dataGroup->createGroup("WEIGHTS");

    if(!dataGroup->exists("WEIGHTED"))
      dataGroup->createGroup("WEIGHTED");

    if(!dataGroup->exists("NOISE"))
      dataGroup->createGroup("NOISE");

    if(!dataGroup->exists("FILTER"))
      dataGroup->createGroup("FILTER");

    if(!dataGroup->exists("BEAM"))
      dataGroup->createGroup("BEAM");

    if(!dataGroup->exists("OCCUPANCY"))
      dataGroup->createGroup("OCCUPANCY");

    if(!dataGroup->exists("SPECTRUM"))
      dataGroup->createGroup("SPECTRUM");
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    return false;
  }

  return true;
}

void HDF5Manager::save(int* numTypes, FILETYPE* dataTypes)
{
  baseData *data = 0;
  *hdf5_err = 0;
  m_err = noErrors;
  m_fileFormat   = HDF5;
  m_observatory  = Analyzer;

  for(int i = 0; i < *numTypes; i += 1)
  {
    if (s_association->exists(dataTypes[i]))
    {
      data = s_association->getData(dataTypes[i]);

      m_fileDataType = data->dataType();
      m_cols         = data->cols();
      m_rows         = data->rows();
      m_slices       = data->slices();

      switch (m_fileDataType)
      {
        case fileType::Null:
          m_err = fileInvalidError;
          s_association->errorValue(m_err);
          throw m_err;
        case fileType::InputData:
        case fileType::InputWeights:
        case fileType::WeightedData:
        case fileType::InputNoise:
        case fileType::InputWeightedNoise:
        case fileType::InputFilter:
        case fileType::InputBeam:
        /*
        case fileType::BinCouplingMatrix:
        case fileType::ModeCouplingMatrix:
        case fileType::InverseBinMatrix:
        case fileType::InverseModeMatrix:
        */
        case fileType::EnsembleIterationNoise:
        case fileType::EnsembleIterationSpectrum:
        case fileType::EnsembleIterationBinnedSpectrum:
        case fileType::ModeModeMatrix:
        case fileType::InstrumentEffectsMatrix:
        case fileType::BinningMatrix:
        case fileType::UnbinningMatrix:
        case fileType::BinnedInstrumentEffectsMatrix:
        case fileType::InverseBinnedInstrumentMatrix:
          m_dimensions = 2;
          m_parts = 1;
          if (!saveMatrixD((matrixData<double>*)data))
            throw m_err;
          break;
        case fileType::AlmData:
        case fileType::AlmWeights:
        case fileType::WeightedAlm:
        case fileType::AlmNoise:
        case fileType::AlmWeightedNoise:
        case fileType::AlmFilter:
        case fileType::AlmBeam:
          m_dimensions = 4;
          m_parts = 2;
          if (!saveCubeCD((cubeData<complex<double> >*)data))
            throw m_err;
          break;
        case fileType::PixelOccupancy:
          m_dimensions = 1;
          m_parts = 1;
          if (!saveVectorI((vectorData<int>*)data))
            throw m_err;
          break;
        default:
          m_dimensions = 1;
          m_parts = 1;
          if (!saveVectorD((vectorData<double>*)data))
            throw m_err;
          break;
      }
    }
  }

  currInfoGroup->close();
  currDataGroup->close();
  infoGroup->close();
  dataGroup->close();

  m_ptr->close();
  return;
}

void HDF5Manager::save(ASSOCIATEDMAP map)
{
}

void HDF5Manager::save(ASSOCIATEDSPECTRUM spect)
{
}

bool HDF5Manager::saveVectorI(vectorData<int> *v)
{
  unsigned long long int numOps, updateUnit, currOp;

  string nsides = std::to_string(v->sides());
  string layout = std::to_string(static_cast<int>(v->layout()));
  string scheme = std::to_string(static_cast<int>(v->pixelScheme()));
  string minVal = std::to_string(v->minValue());
  string maxVal = std::to_string(v->maxValue());

  int numInfoDims = 2;
  hsize_t infoDims[numInfoDims];
  infoDims[0] = 2;
  infoDims[1] = 5;

  const char* infoData[2][5] = {{"NSIDES",       "PIXLAYOUT",    "PIXSCHEME",    "PIXMINVALUE",     "PIXMAXVALUE"},
                                {nsides.c_str(), layout.c_str(), scheme.c_str(), minVal.c_str(), maxVal.c_str()}};

  try
  {
    currInfoGroup     = new H5::Group(infoGroup->openGroup("OCCUPANCY"));

    if(currInfoGroup->exists("OCCUPANCY"))
      currInfoGroup->unlink("OCCUPANCY");

    currInfoDataSpace = new H5::DataSpace(numInfoDims, infoDims);
    currInfoDataSet   = new H5::DataSet(currInfoGroup->createDataSet("OCCUPANCY", *H5String, *currInfoDataSpace));

    currInfoDataSet->write(infoData, *H5String, *currInfoDataSpace);

    currInfoDataSpace->close();
    currInfoDataSet->close();
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    return false;
  }

 numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1)
    updateUnit = 1;
  currOp = 0;

  int numDataDims = 1;
  hsize_t dataDims[numDataDims];
  dataDims[0] = m_rows;

  int* data = new int[m_rows];
  for (int row = 0; row < m_rows; row++) {
    data[row] = (*v)[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }

  try
  {
    currDataGroup = new H5::Group(dataGroup->openGroup("OCCUPANCY"));

    if(currDataGroup->exists("OCCUPANCY"))
      currDataGroup->unlink("OCCUPANCY");

    currDataDataSpace = new H5::DataSpace(numDataDims, dataDims);
    currDataDataSet   = new H5::DataSet(currDataGroup->createDataSet("OCCUPANCY", *H5Int32, *currDataDataSpace));

    currDataDataSet->write(data, *H5Int32, *currDataDataSpace);

    currDataDataSpace->close();
    currDataDataSet->close();
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    return false;
  }


  if (m_err != noErrors) {
    m_err = incompleteTableWrittenError;
    s_association->errorValue(m_err);
    return false;
  }

  return true;
}

bool HDF5Manager::saveVectorD(vectorData<double> *v)
{
  unsigned long long int numOps, updateUnit, currOp;
  std::string dataSetName = "";

  int numInfoDims = 2;
  hsize_t infoDims[numInfoDims];
  infoDims[0] = 2;
  infoDims[1] = 6;

  const char* infoData[infoDims[0]][infoDims[1]];

  switch (m_fileDataType) {
    case fileType::PixelizedData:
      dataSetName = dataTypeNames[static_cast<int>(fileType::PixelizedData)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("DATA"));
      currDataGroup = new H5::Group(dataGroup->openGroup("DATA"));
      //hduName = "PIXEL_DATA";
      break;
    case fileType::PixelizedWeights:
      dataSetName = dataTypeNames[static_cast<int>(fileType::PixelizedWeights)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTS"));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTS"));
      //hduName = "PIXEL_MASK";
      break;
    case fileType::WeightedPixel:
      dataSetName = dataTypeNames[static_cast<int>(fileType::WeightedPixel)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      //hduName = "PIXEL_DATA";
      break;
    case fileType::PixelizedNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::PixelizedNoise)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("NOISE"));
      currDataGroup = new H5::Group(dataGroup->openGroup("NOISE"));
      //hduName = "PIXEL_NOISE";
      break;
    case fileType::PixelizedWeightedNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::PixelizedWeightedNoise)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      break;
    case fileType::PixelizedFilter:
      dataSetName = dataTypeNames[static_cast<int>(fileType::PixelizedFilter)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("FILTER"));
      currDataGroup = new H5::Group(dataGroup->openGroup("FILTER"));
      //hduName = "PIXEL_FILTER";
      break;
    case fileType::PixelizedBeam:
      dataSetName = dataTypeNames[static_cast<int>(fileType::PixelizedBeam)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("BEAM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("BEAM"));
      //hduName = "PIXEL_BEAM";
      break;
    case fileType::InverseData:
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseData)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("DATA"));
      currDataGroup = new H5::Group(dataGroup->openGroup("DATA"));
      //hduName = "INVERSE_DATA";
      break;
    case fileType::InverseWeights:
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseWeights)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTS"));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTS"));
      //hduName = "INVERSE_MASK";
      break;
    case fileType::WeightedInverse:
      dataSetName = dataTypeNames[static_cast<int>(fileType::WeightedInverse)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("DATA"));
      currDataGroup = new H5::Group(dataGroup->openGroup("DATA"));
      //hduName = "PIXEL_DATA";
      break;
    case fileType::InverseNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseNoise)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("NOISE"));
      currDataGroup = new H5::Group(dataGroup->openGroup("NOISE"));
      //hduName = "INVERSE_NOISE";
      break;
    case fileType::InverseWeightedNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseWeightedNoise)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      break;
    case fileType::InverseFilter:
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseFilter)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("FILTER"));
      currDataGroup = new H5::Group(dataGroup->openGroup("FILTER"));
      //hduName = "INVERSE_FILTER";
      break;
    case fileType::InverseBeam:
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseBeam)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("BEAM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("BEAM"));
      //hduName = "INVERSE_BEAM";
      break;
    case fileType::TransformedData:
      dataSetName = dataTypeNames[static_cast<int>(fileType::TransformedData)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("DATA"));
      currDataGroup = new H5::Group(dataGroup->openGroup("DATA"));
      //hduName = "TRANSFORMED_DATA";
      break;
    case fileType::TransformedWeights:
      dataSetName = dataTypeNames[static_cast<int>(fileType::TransformedWeights)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTS"));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTS"));
      //hduName = "TRANSFORMED_MASK";
      break;
    case fileType::WeightedTransform:
      dataSetName = dataTypeNames[static_cast<int>(fileType::WeightedTransform)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      //hduName = "PIXEL_DATA";
      break;
    case fileType::TransformedNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::TransformedNoise)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("NOISE"));
      currDataGroup = new H5::Group(dataGroup->openGroup("NOISE"));
      //hduName = "TRANSFORMED_NOISE";
      break;
    case fileType::TransformedWeightedNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::TransformedWeightedNoise)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      break;
    case fileType::TransformedFilter:
      dataSetName = dataTypeNames[static_cast<int>(fileType::TransformedFilter)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("FILTER"));
      currDataGroup = new H5::Group(dataGroup->openGroup("FILTER"));
      //hduName = "TRANSFORMED_FILTER";
      break;
    case fileType::TransformedBeam:
      dataSetName = dataTypeNames[static_cast<int>(fileType::TransformedBeam)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("BEAM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("BEAM"));
      //hduName = "TRANSFORMED_BEAM";
      break;
    case fileType::EnsembleAveragedNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::EnsembleAveragedNoise)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      //hduName = "TRANSFORMED_BEAM";
      break;
    case fileType::EnsembleAveragedSpectrum:
      dataSetName = dataTypeNames[static_cast<int>(fileType::EnsembleAveragedSpectrum)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      //hduName = "TRANSFORMED_BEAM";
      break;
    case fileType::BinnedSpectrum:
      dataSetName = dataTypeNames[static_cast<int>(fileType::BinnedSpectrum)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      //hduName = "TRANSFORMED_BEAM";
      break;
    case fileType::EnsembleAveragedBinnedSpectrum:
      dataSetName = dataTypeNames[static_cast<int>(fileType::EnsembleAveragedBinnedSpectrum)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      //hduName = "TRANSFORMED_BEAM";
      break;
    /*
    case fileType::SpectralData:
      dataSetName = dataTypeNames[static_cast<int>(fileType::SpectralData)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      //hduName = "PSEUDO-SPECTRAL_DATA";
      break;
    case fileType::EnsembleData:
      dataSetName = dataTypeNames[(int)(fileType::EnsembleData)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      break;
    */
  }


  switch (m_fileDataType) {
    case fileType::PixelizedData:
    case fileType::PixelizedWeights:
    case fileType::WeightedPixel:
    case fileType::PixelizedNoise:
    case fileType::PixelizedWeightedNoise:
    case fileType::PixelizedFilter:
    case fileType::PixelizedBeam:
    case fileType::InverseData:
    case fileType::InverseWeights:
    case fileType::WeightedInverse:
    case fileType::InverseNoise:
    case fileType::InverseWeightedNoise:
    case fileType::InverseFilter:
    case fileType::InverseBeam:
    {
      string nsides = std::to_string(v->sides());
      string layout = std::to_string(static_cast<int>(v->layout()));
      string scheme = std::to_string(static_cast<int>(v->pixelScheme()));
      string minVal = std::to_string(static_cast<int>(v->minValue()));
      string maxVal = std::to_string(static_cast<int>(v->maxValue()));

      infoData[0][0] = "NSIDES";
      infoData[1][0] = nsides.c_str();

      infoData[0][1] = "PIXLAYOUT";
      infoData[1][1] = layout.c_str();

      infoData[0][2] = "PIXSCHEME";
      infoData[1][2] = scheme.c_str();

      infoData[0][3] = "MINVALUE";
      infoData[1][3] = minVal.c_str();

      infoData[0][4] = "MAXVALUE";
      infoData[1][4] = maxVal.c_str();

      infoData[0][5] = "NA";
      infoData[1][5] = "NA";

      break;
    }
    case fileType::TransformedData:
    case fileType::TransformedWeights:
    case fileType::WeightedTransform:
    case fileType::TransformedNoise:
    case fileType::TransformedWeightedNoise:
    case fileType::TransformedFilter:
    case fileType::TransformedBeam:
    {
      string nsides = std::to_string(v->sides());
      string layout = std::to_string(static_cast<int>(v->layout()));
      string scheme = std::to_string(static_cast<int>(v->pixelScheme()));

      string trans = std::to_string(static_cast<int>(v->transformerScheme()));
      string minInd = std::to_string(static_cast<int>(v->minYIndex()));
      string maxInd = std::to_string(static_cast<int>(v->maxYIndex()));

      infoData[0][0] = "NSIDES";
      infoData[1][0] = nsides.c_str();

      infoData[0][1] = "PIXLAYOUT";
      infoData[1][1] = layout.c_str();

      infoData[0][2] = "PIXSCHEME";
      infoData[1][2] = scheme.c_str();

      infoData[0][3] = "TRANSSCHEME";
      infoData[1][3] = trans.c_str();

      infoData[0][4] = "MINYINDEX";
      infoData[1][4] = minInd.c_str();

      infoData[0][5] = "MAXYINDEX";
      infoData[1][5] = maxInd.c_str();

      break;
    }
    //case fileType::SpectralData:
    //case fileType::EnsembleData:
    case fileType::EnsembleAveragedNoise:
    case fileType::EnsembleAveragedSpectrum:
    case fileType::BinnedSpectrum:
    case fileType::EnsembleAveragedBinnedSpectrum:
    {
      string minInd  = std::to_string(v->minYIndex());
      string maxInd  = std::to_string(v->maxYIndex());
      string minVal  = std::to_string(v->minValue());
      string maxVal  = std::to_string(v->maxValue());
      string maskInd = std::to_string(v->mask());

      infoData[0][0] = "MININDEX";
      infoData[1][0] = minInd.c_str();

      infoData[0][1] = "MAXINDEX";
      infoData[1][1] = maxInd.c_str();

      infoData[0][2] = "MINVALUE";
      infoData[1][2] = minVal.c_str();

      infoData[0][3] = "MAXVALUE";
      infoData[1][3] = maxVal.c_str();

      infoData[0][4] = "MASKINDEX";
      infoData[1][4] = maskInd.c_str();

      infoData[0][5] = "NA";
      infoData[1][5] = "NA";

      break;
    }
  }

  try
  {
    if(currInfoGroup->exists(dataSetName))
      currInfoGroup->unlink(dataSetName);

    currInfoDataSpace = new H5::DataSpace(numInfoDims, infoDims);
    currInfoDataSet   = new H5::DataSet(currInfoGroup->createDataSet(dataSetName, *H5String, *currInfoDataSpace));

    currInfoDataSet->write(infoData, *H5String, *currInfoDataSpace);

    currInfoDataSpace->close();
    currInfoDataSet->close();
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    return false;
  }

 numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1)
    updateUnit = 1;
  currOp = 0;

  int numDataDims = 1;
  hsize_t dataDims[numDataDims];
  dataDims[0] = m_rows;

  double* data = new double[m_rows];
  for (int row = 0; row < m_rows; row++) {
    data[row] = (*v)[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }

  try
  {
    if(currDataGroup->exists(dataSetName))
      currDataGroup->unlink(dataSetName);

    currDataDataSpace = new H5::DataSpace(numDataDims, dataDims);
    currDataDataSet   = new H5::DataSet(currDataGroup->createDataSet(dataSetName, *H5Double, *currDataDataSpace));

    currDataDataSet->write(data, *H5Double, *currDataDataSpace);

    currDataDataSpace->close();
    currDataDataSet->close();
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    return false;
  }

  if (m_err != noErrors) {
    m_err = incompleteTableWrittenError;
    s_association->errorValue(m_err);
    return false;
  }

  return true;
}

bool HDF5Manager::saveMatrixD(matrixData<double> *m)
{
  unsigned long long int numOps, updateUnit, currOp;
  std::string dataSetName = "";

  switch (m_fileDataType) {
    case fileType::InputData:
      currInfoGroup = new H5::Group(infoGroup->openGroup("DATA"));
      currDataGroup = new H5::Group(dataGroup->openGroup("DATA"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::InputData)];
      //dataSetName = "RAW_DATA";
      break;
    case fileType::InputWeights:
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTS"));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTS"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::InputWeights)];
      //dataSetName = "RAW_MASK";
      break;
    case fileType::WeightedData:
      dataSetName = dataTypeNames[static_cast<int>(fileType::WeightedData)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      //hduName = "PIXEL_DATA";
      break;
    case fileType::InputNoise:
      currInfoGroup = new H5::Group(infoGroup->openGroup("NOISE"));
      currDataGroup = new H5::Group(dataGroup->openGroup("NOISE"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::InputNoise)];
      //dataSetName = "RAW_NOISE";
      break;
    case fileType::InputWeightedNoise:
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::InputWeightedNoise)];
      break;
    case fileType::InputFilter:
      currInfoGroup = new H5::Group(infoGroup->openGroup("FILTER"));
      currDataGroup = new H5::Group(dataGroup->openGroup("FILTER"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::InputFilter)];
      //dataSetName = "RAW_FILTER";
      break;
    case fileType::InputBeam:
      currInfoGroup = new H5::Group(infoGroup->openGroup("BEAM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("BEAM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::InputBeam)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::EnsembleIterationNoise:
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::EnsembleIterationNoise)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::EnsembleIterationSpectrum:
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::EnsembleIterationSpectrum)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::EnsembleIterationBinnedSpectrum:
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::EnsembleIterationBinnedSpectrum)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::ModeModeMatrix:
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::ModeModeMatrix)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::InstrumentEffectsMatrix:
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::InstrumentEffectsMatrix)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::BinningMatrix:
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::BinningMatrix)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::UnbinningMatrix:
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::UnbinningMatrix)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::BinnedInstrumentEffectsMatrix:
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::BinnedInstrumentEffectsMatrix)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::InverseBinnedInstrumentMatrix:
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseBinnedInstrumentMatrix)];
      //dataSetName = "RAW_BEAM";
      break;
    /*
    case fileType::BinCouplingMatrix:
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::BinCouplingMatrix)];
      //dataSetName = "BIN_COUPLING_MATRIX";
      break;
    case fileType::ModeCouplingMatrix:
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::ModeCouplingMatrix)];
      //dataSetName = "MODE_COUPLING_MATRIX";
      break;
    case fileType::InverseBinMatrix:
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseBinMatrix)];
      //dataSetName = "INVERSE_BIN_COUPLING_MATRIX";
      break;
    case fileType::InverseModeMatrix:
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseModeMatrix)];
      //dataSetName = "INVERSE_MODE_COUPLING_MATRIX";
      break;
    */
  }

  int numInfoDims = 2;
  hsize_t infoDims[numInfoDims];
  infoDims[0] = 2;
  infoDims[1] = 2;

  std::string raRes = std::to_string(m->RARes());
  std::string decRes = std::to_string(m->DecRes());
  const char* infoData[2][2] = {{"CDELT1",      "CDELT2"},
                                {raRes.c_str(), decRes.c_str()}};
  try
  {
    if(currInfoGroup->exists(dataSetName))
      currInfoGroup->unlink(dataSetName);

    currInfoDataSpace = new H5::DataSpace(numInfoDims, infoDims);
    currInfoDataSet   = new H5::DataSet(currInfoGroup->createDataSet(dataSetName, *H5String, *currInfoDataSpace));

    currInfoDataSet->write(infoData, *H5String, *currInfoDataSpace);

    currInfoDataSpace->close();
    currInfoDataSet->close();
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    return false;
  }

  numOps = m_cols * m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1)
    updateUnit = 1;
  currOp = 0;

  int numDataDims = 2;
  hsize_t dataDims[2];

  dataDims[0] = m_rows;
  dataDims[1] = m_cols;

  double* data = new double[m_rows * m_cols];
  for(int r = 0; r < m_rows; r += 1)
    for(int c = 0; c < m_cols; c += 1)
      data[r * m_cols + c] = (*m)[c][r];

  try
  {
    if(currDataGroup->exists(dataSetName))
      currDataGroup->unlink(dataSetName);

    currDataDataSpace = new H5::DataSpace(numDataDims, dataDims);
    currDataDataSet   = new H5::DataSet(currDataGroup->createDataSet(dataSetName, *H5Double, *currDataDataSpace));

    currDataDataSet->write(data, *H5Double, *currDataDataSpace);

    currDataDataSpace->close();
    currDataDataSet->close();
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  if (m_err != noErrors) {
    m_err = incompleteTableWrittenError;
    s_association->errorValue(m_err);
    return false;
  }

  return true;
}

bool HDF5Manager::saveCubeCD(cubeData<complex<double> > *c)
{
  unsigned long long int numOps, updateUnit, currOp;
  std::string dataSetName = "";

  switch (m_fileDataType)
  {
    case fileType::AlmData:
      currInfoGroup = new H5::Group(infoGroup->openGroup("DATA"));
      currDataGroup = new H5::Group(dataGroup->openGroup("DATA"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::AlmData)];
      //dataSetName = "ALM_DATA";
      break;
    case fileType::AlmWeights:
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTS"));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTS"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::AlmWeights)];
      //dataSetName = "ALM_MASK";
      break;
    case fileType::WeightedAlm:
      dataSetName = dataTypeNames[static_cast<int>(fileType::WeightedAlm)];
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      //hduName = "PIXEL_DATA";
      break;
    case fileType::AlmNoise:
      currInfoGroup = new H5::Group(infoGroup->openGroup("NOISE"));
      currDataGroup = new H5::Group(dataGroup->openGroup("NOISE"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::AlmNoise)];
      //dataSetName = "ALM_NOISE";
      break;
    case fileType::AlmWeightedNoise:
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::AlmWeightedNoise)];
      break;
    case fileType::AlmFilter:
      currInfoGroup = new H5::Group(infoGroup->openGroup("FILTER"));
      currDataGroup = new H5::Group(dataGroup->openGroup("FILTER"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::AlmFilter)];
      //dataSetName = "ALM_FILTER";
      break;
    case fileType::AlmBeam:
      currInfoGroup = new H5::Group(infoGroup->openGroup("BEAM"));
      currDataGroup = new H5::Group(dataGroup->openGroup("BEAM"));
      dataSetName = dataTypeNames[static_cast<int>(fileType::AlmBeam)];
      //dataSetName = "ALM_BEAM";
      break;
  }

  int numInfoDims = 2;
  hsize_t infoDims[2];
  infoDims[0] = 2;
  infoDims[1] = 8;

  std::string polarization = std::to_string(c->polarization());
  std::string index        = std::to_string(c->index());
  std::string sides        = std::to_string(c->sides());
  std::string scheme       = c->pixelScheme() == HealPIX ? "HealPIX":"NotPixelized";
  std::string layout       = c->layout() == Ring? "Ring":"Nest";
  std::string trans        = c->transformerScheme() == Rsht ? "Rsht":"NotTransformed";
  std::string minInd       = std::to_string(c->transMinIndex());
  std::string maxInd       = std::to_string(c->transMaxIndex());
  const char* infoData[2][8] = { {"POLARIZATION",       "INDEX",       "NSIDES",     "PIXSCHEME",     "PIXLAYOUT",   "TRANSFORMERSCHEME", "TRANSMININDEX", "TRANSMAXINDEX"},
                                 {polarization.c_str(), index.c_str(), sides.c_str(), scheme.c_str(), layout.c_str(), trans.c_str(),       minInd.c_str(),  maxInd.c_str()}};

  try
  {
    if(currInfoGroup->exists(dataSetName))
      currInfoGroup->unlink(dataSetName);

    currInfoDataSpace = new H5::DataSpace(numInfoDims, infoDims);
    currInfoDataSet   = new H5::DataSet(currInfoGroup->createDataSet(dataSetName, *H5String, *currInfoDataSpace));

    currInfoDataSet->write(infoData, *H5String, *currInfoDataSpace);

    currInfoDataSpace->close();
    currInfoDataSet->close();
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    return false;
  }


  std::vector<std::vector<std::vector<complex<double> > > > dataAccess = c->roAccess();

  numOps = m_slices * m_rows * m_cols;
  updateUnit = numOps / 100;
  if(updateUnit < 1)
    updateUnit = 1;
  currOp = 0;

  int numDataDims = 3;
  hsize_t dataDims[3];
  dataDims[0] = m_slices;
  dataDims[1] = m_rows;
  dataDims[2] = m_cols;

  complex<double>* data = new complex<double>[m_slices * m_rows * m_cols];
  /*
  for(int slice = 0; slice < m_slices; slice += 1)
  {
    data[slice] = new complex<double>*[m_rows];
    for(int row = 0; row < m_rows; row += 1)
      data[slice][row] = new complex<double>[m_cols];
  }
  */

  for(int slice = 0; slice < m_slices; slice += 1)
  {
    for(int row = 0; row < m_rows; row += 1)
    {
      for(int col = 0; col < m_cols; col += 1)
        data[slice * m_rows * m_cols + row * m_cols + col] = complex<double>( (*c)[slice][col][row].real(),
                                                                              (*c)[slice][col][row].imag());
        //data[slice][row][col].real(dataAccess[slice][col][row].real());

    }
  }

  try
  {
    if(currDataGroup->exists(dataSetName))
      currDataGroup->unlink(dataSetName);

    currDataDataSpace = new H5::DataSpace(numDataDims, dataDims);
    currDataDataSet   = new H5::DataSet(currDataGroup->createDataSet(dataSetName, *H5Complex, *currDataDataSpace));

    currDataDataSet->write(data, *H5Complex, *currDataDataSpace);

    currDataDataSpace->close();
    currDataDataSet->close();
  }
  catch (H5::Exception& err)
  {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  if (m_err != noErrors) {
    m_err = incompleteTableWrittenError;
    s_association->errorValue(m_err);
    return false;
  }

  return true;
}

bool HDF5Manager::getHeaders(int hdrNum)
{
  return false;
}

FILETYPE* HDF5Manager::getHeaders(int* numTypes)
{
  char** data;
  hsize_t* dims;

  *numTypes = 0;
  FILETYPE* dataTypes;

  if(m_observatory == Analyzer)
  {
    try
    {
        infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
        currInfoDataSet = new H5::DataSet(infoGroup->openDataSet("PRIMARY"));
        currInfoDataSpace = new H5::DataSpace(currInfoDataSet->getSpace());

        int numDims = currInfoDataSpace->getSimpleExtentNdims();
        dims = new hsize_t[numDims];

        currInfoDataSpace->getSimpleExtentDims(dims, NULL);

        data = new char*[ dims[0] * dims[1]];
        currInfoDataSet->read(data, *H5String, *currInfoDataSpace);
    }
    catch (H5::Exception& err) {
      snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
      m_err = fileFitsError;
      m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
      return 0;//false;
    }
    catch(...)
    {
      currInfoDataSpace->close();
      currInfoDataSet->close();
      currInfoGroup->close();
      infoGroup->close();
      m_ptr->close();
    }

    string telescope(data[dims[1]]);

    if(telescope.find("\t") < telescope.size())
      telescope = telescope.substr(0, telescope.find("\t"));

    OBSERVATORY obsType = Unknown;
    int obsValue = (int)Unknown;
    while (obsType < OBSERVATORY_LIMIT) {
      obsType = static_cast<OBSERVATORY>(obsValue);
      if (telescope == observatoryNames[obsValue])
        break;
      obsValue++;
    }
    m_observatory = obsType;
    m_fileDataType = fileType::InputData;

    *numTypes = dims[1]-1;
    dataTypes = new FILETYPE[*numTypes];

    for(int dataIndex = 0; dataIndex < dims[1]-1; dataIndex += 1)
    {
      for(int nameIndex = 0; nameIndex < static_cast<int>(fileType::FILETYPE_LIMIT); nameIndex += 1)
      {
        int offset = dims[1];
        if(data[offset + dataIndex + 1] == dataTypeNames[nameIndex])
          dataTypes[dataIndex] = static_cast<FILETYPE>(nameIndex);
      }
    }

    delete[] data;
  }
  else if(m_observatory == Gadget)
  {
    dataTypes = new FILETYPE[1];
    dataTypes[0] = fileType::InputData;
    *numTypes = 1;
  }

  if (m_observatory == OBSERVATORY_LIMIT) {
    m_err = fileNoKeyError;
    m_errDetail = errorText[abs(m_err)] + ": Observatory not recognized";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;//false;
  }

  return dataTypes;
}

void HDF5Manager::open()
{
  return;
}

void HDF5Manager::open(int* numTypes, FILETYPE* dataTypes)
{
  *hdf5_err = 0;

  for(int i = 0; i < *numTypes; i += 1)
  {
      m_fileDataType = dataTypes[i];
      m_fileFormat = HDF5;

      int hitStepInto = 0;

      baseData* dataValue = data();

      dataValue->fileName(this->fileName());
      dataValue->fileFormat(HDF5);

      s_association->addData(dataValue);
  }

  /*
  if(m_observatory == Analyzer)
  {
    for(int i = 0; i < *numTypes; i += 1)
    {
      m_fileDataType = dataTypes[i];
      m_fileFormat = HDF5;

      baseData* dataValue = data();

      dataValue->fileName(this->fileName());
      dataValue->fileFormat(HDF5);

      s_association->addData(dataValue);
    }
  }
  else
  {
    // this is where we will handle the logic for outside sources
    if(m_observatory == Gadget)
    {
      gadgetData();
    }

    return;
  }
  */
  return;
}

bool HDF5Manager::getDataType()
{
  return false;
}

bool HDF5Manager::getDimensions()
{
  return false;
}

bool HDF5Manager::getEnergy()
{
  return false;
}


baseData *HDF5Manager::data()
{
  if (!m_ptr)
    return 0;

  if(m_observatory == Gadget)
    return gadgetData();
  else
  {
    switch (m_fileDataType) {
      case fileType::Null:
        return 0;
      case fileType::InputData:
      case fileType::InputWeights:
      case fileType::WeightedData:
      case fileType::InputNoise:
      case fileType::InputWeightedNoise:
      case fileType::InputFilter:
      case fileType::InputBeam:
        if (m_observatory != Analyzer)
          return data(m_minSlice,m_maxSlice);
      /*
      case fileType::WeightedData:
      case fileType::BinCouplingMatrix:
      case fileType::ModeCouplingMatrix:
      case fileType::InverseBinMatrix:
      case fileType::InverseModeMatrix:
      */
      case fileType::EnsembleIterationNoise:
      case fileType::EnsembleIterationSpectrum:
      case fileType::EnsembleIterationBinnedSpectrum:
      case fileType::ModeModeMatrix:
      case fileType::InstrumentEffectsMatrix:
      case fileType::BinningMatrix:
      case fileType::UnbinningMatrix:
      case fileType::BinnedInstrumentEffectsMatrix:
      case fileType::InverseBinnedInstrumentMatrix:
        return getMatrixD();
      case fileType::AlmData:
      case fileType::AlmWeights:
      case fileType::WeightedAlm:
      case fileType::AlmNoise:
      case fileType::AlmWeightedNoise:
      case fileType::AlmFilter:
      case fileType::AlmBeam:
        return getCubeCD();
      case fileType::PixelOccupancy:
        return getVectorI();
      default:
        return getVectorD();
    }
  }

  return 0;
}

inputMatrixData *HDF5Manager::data(int slice_min, int slice_max)
{
  /*
  std::valarray<double> fitsData;
  inputMatrixData* in_mat;
  long span, n, begin;
  std::string hduName = "";
  std::vector<string> colName(m_cols,"");
  const std::string cols = "COLUMN-";
  double ra_res = 0, dec_res = 0;
  unsigned long long int numOps, updateUnit, currOp;

  if (!m_ptr) {
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": No CCfits pointer";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (!(m_observatory == Egret || m_observatory == Fermi)) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": No slices in file";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min < 0 || slice_max < 0) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": Minimum slice number or maximum slice number less than 0";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min > m_slices || slice_max > m_slices) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": Slice number is greater than the available slices";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min > slice_max) {
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": Minimum slice number greater than maximum slice number";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  span  = slice_max - slice_min + 1;
  n     = span * m_cols * m_rows;
  begin = slice_min * m_cols * m_rows + 1;

  // set appropriate hdu name to identify extension
  switch (m_fileDataType) {
    case fileType::InputData:
      hduName = "RAW_DATA";
      break;
    case fileType::InputWeights:
      hduName = "RAW_MASK";
      break;
    case fileType::WeightedData:
      hduName = "WEIGHTED_DATA";
      break;
    case fileType::InputNoise:
      hduName = "RAW_NOISE";
      break;
    case fileType::InputFilter:
      hduName = "RAW_FILTER";
      break;
    case fileType::InputBeam:
      hduName = "RAW_BEAM";
      break;
    case fileType::BinCouplingMatrix:
      hduName = "BIN_COUPLING_MATRIX";
      break;
    case fileType::ModeCouplingMatrix:
      hduName = "MODE_COUPLING_MATRIX";
      break;
    case fileType::InverseBinMatrix:
      hduName = "INVERSE_BIN_COUPLING_MATRIX";
      break;
    case fileType::InverseModeMatrix:
      hduName = "INVERSE_MODE_COUPLING_MATRIX";
      break;
  }

  // set column names
  for (int col = 0; col < m_cols; col++)
    colName[col] = cols + std::to_string(col);

  // create data structure for storage
  in_mat = new inputMatrixData(m_cols,m_rows,m_fileDataType);
  in_mat->initialize();

  numOps = m_rows * m_cols;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  // load data
  try {
    LOAD("CDELT1",ra_res);
    LOAD("CDELT2",dec_res);
    in_mat->RARes(ra_res);
    in_mat->DecRes(dec_res);

    H5::ExtHDU& binTable = m_ptr->extension(hduName);
    for (int col = 0; col < m_cols; ++col) {
      binTable.column(colName[col]).read(fitsData,1,m_rows);
      for (int row = 0; row < m_rows; ++row) {
        (*in_mat)[col][row] = fitsData[row];
        currOp++;
//        if(m_showProgress && !(currOp % updateUnit))
//          informProgress(currOp / updateUnit);
      }
    }
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    delete in_mat;
    return 0;
  }

  return in_mat;
  */
  return NULL;
}

inputMatrixData *HDF5Manager::data(float e_min,float e_max)
{
  return NULL;
}

baseData* HDF5Manager::gadgetData()
{
  try
  {
    currDataGroup = new H5::Group(m_ptr->openGroup("PartType1"));
    currDataDataSet = new H5::DataSet(currDataGroup->openDataSet("Coordinates"));
    currDataDataSpace = new H5::DataSpace(currDataDataSet->getSpace());

    int numDims = currDataDataSpace->getSimpleExtentNdims();
    hsize_t* dims1 = new hsize_t[numDims];
    currDataDataSpace->getSimpleExtentDims(dims1, NULL);

    double* coorData = new double[dims1[0] * dims1[1]];
    currDataDataSet->read(coorData, currDataDataSet->getDataType(), *currDataDataSpace);

    // get the box size
    currDataGroup = new H5::Group(m_ptr->openGroup("Header"));
    H5::Attribute* boxSizeAttr = new H5::Attribute(currDataGroup->openAttribute("BoxSize"));
    double* boxSize = new double(0);
    boxSizeAttr->read(boxSizeAttr->getDataType(), boxSize);

    //currDataDataSet = new H5::DataSet(currDataGroup->openDataSet("Velocities"));
    //currDataDataSpace = new H5::DataSpace(currDataDataSet->getSpace());

    //numDims = currDataDataSpace->getSimpleExtentNdims();
    //hsize_t* dims2 = new hsize_t[numDims];
    //currDataDataSpace->getSimpleExtentDims(dims2, NULL);

    //double* velData = new double[dims2[0] * dims2[1]];
    //currDataDataSet->read(velData, currDataDataSet->getDataType(), *currDataDataSpace);


    double minX = INT_MAX, maxX = 0;
    double minY = INT_MAX, maxY = 0;
    double minZ = INT_MAX, maxZ = 0;

    for(int i = 0; i < dims1[0] * dims1[1]; i += 3)
    {
      if(coorData[i+0] < minX)
        minX = coorData[i+0];
      else if(coorData[i+0] > maxX)
        maxX = coorData[i+0];

      if(coorData[i+1] < minY)
        minY = coorData[i+1];
      else if(coorData[i+1] > maxY)
        maxY = coorData[i+1];

      if(coorData[i+2] < minZ)
        minZ = coorData[i+2];
      else if(coorData[i+2] > maxZ)
        maxZ = coorData[i+2];
    }

    double xCenter = (maxX - minX)/2;
    double yCenter = (maxY - minY)/2;
    double zCenter = (maxZ - minZ)/2;


    //double xCenter = *boxSize/2;
    //double yCenter = *boxSize/2;
    //double zCenter = *boxSize/2;

    std::cout << *boxSize << "\n";
    std::cout << xCenter << ", " << yCenter << ", " << zCenter << "\n";

    double minTheta = INT_MAX;
    double minPhi = INT_MAX;
    double minRA = INT_MAX;
    double minDec = INT_MAX;

    double* wrappedData = new double[dims1[0] * dims1[1]];
    double* shiftedData = new double[dims1[0] * dims1[1]];
    double* spherData = new double[dims1[0] * dims1[1]];

    for(int i = 0; i < dims1[0] * dims1[1]; i += 3)
    {
        double origX = coorData[i+0];
        double origY = coorData[i+1];
        double origZ = coorData[i+2];

        double xNumTimesInto = origX > *boxSize ? ((int)(origX / *boxSize)) : 0;
        double yNumTimesInto = origY > *boxSize ? ((int)(origY / *boxSize)) : 0;
        double zNumTimesInto = origZ > *boxSize ? ((int)(origZ / *boxSize)) : 0;

        double origXRem = origX - (xNumTimesInto * *boxSize); // = origX; // = modf(origX, &origXInt);
        double origYRem = origY - (yNumTimesInto * *boxSize); // = origY; // = modf(origY, &origYInt);
        double origZRem = origZ - (zNumTimesInto * *boxSize); // = origZ; // = modf(origZ, &origZInt);

        /*
        while(origXRem > *boxSize)
          origXRem -= *boxSize;

        while(origYRem > *boxSize)
          origYRem -= *boxSize;

        while(origZRem > *boxSize)
          origZRem -= *boxSize;
        */

        wrappedData[i+0] = origX;
                           //origXRem;
        wrappedData[i+1] = origY;
                           //origYRem;
        wrappedData[i+2] = origZ;
                           //origZRem;

        shiftedData[i+0] = wrappedData[i+0] - xCenter;
        shiftedData[i+1] = wrappedData[i+1] - yCenter;
        shiftedData[i+2] = wrappedData[i+2] - zCenter;

        shiftedData[i+0] = coorData[i+0] - xCenter;
        shiftedData[i+1] = coorData[i+1] - yCenter;
        shiftedData[i+2] = coorData[i+2] - zCenter;

        double x = shiftedData[i+0];
        double y = shiftedData[i+1];
        double z = shiftedData[i+2];

        /*
        //double theta, phi, rho;
        //rho = sqrt(x*x + y*y + z*z);
        //theta = atan(y/x);
        //phi = atan(sqrt(x*x + y*y)/z);

        //rho = sqrt(x*x + y*y + z*z);
        //phi = acos(z/rho);
        //theta = acos(x / (rho * sin(phi)));

        // based on
        // where theta = rotation around z
        // and phi = rotation off of z
        // x = r sin(phi) cos(theta);
        // y = r sin(phi) sin(theta);
        // z = r cos(phi)

        // so we get
        // r2 = x2 + y2 + z2
        // cos(phi) = z/r --> phi = cos-1(z/r)
        // cos(theta) = x/(rsin(phi)) --> theta = cos-1(x/rsin(phi))

        // acos returns in radians
        //rho = sqrt(x*x + y*y + z*z);
        //double rotOffZ = acos(z/rho);

        //double rotAbtZ;

        // acos(-1) returns nan even though documentation says it shouldn't
        // so we need to account for that
        //if(x/(rho*sin(rotOffZ)) <= -.99999)
        //  rotAbtZ = acos(-.99999);
        //else
        // rotAbtZ = acos(x/(rho * sin(rotOffZ)));

        //theta = rotOffZ * 180 / M_PI; // theta is our rows so it equals rotation off of z
        // since acos returns a number between 0 and pi but our data is from 0 to 2pi we need to fix this!
        // one simple way is to just double the angle, but I don't know if that is correct, the picture looks wonky
        //phi   = 2 * (rotAbtZ * 180 / M_PI); // phi is our cols so it equals the rotation around the z axis

        //theta = 90 - theta;
        //phi = phi + 180;

        //coorData[i+0] = theta;
        //coorData[i+1] = phi;
        //coorData[i+2] = rho;

        //double thetaDecim;
        //double thetaInt;
        //double phiDecim;
        //double phiInt;

        //thetaDecim = modf(theta, &thetaInt);

        //if(std::abs(thetaDecim) < minTheta)
        //if(thetaDecim < minTheta)
        //  minTheta = std::abs(thetaDecim);

        //phiDecim = modf(phi, &phiInt);

        //if(std::abs(phiDecim) < minPhi)
        //  if(phiDecim < minPhi)
        //    minPhi = std::abs(phiDecim);
        */

        double ra, dec, r;
        r = sqrt(x*x + y*y + z*z);
        if(r == 0)
          dec = 0;
        else
          dec = asin(z/r);

        // shift from 90 to -90 latitude to 0 to 180 style
        dec = (M_PI/2) - dec;

        // make dec wrap around
        //if(dec >= (M_PI))
        //  dec = dec - M_PI;

        if(r == 0)
          ra = 0;
        else
          ra = atan2(y, x);

        // shift from -180 to 180 to 0 to 360 style
        ra = ra + M_PI;

        //if(ra < 0)
        //  ra = ra + 2 * M_PI;
        // make ra wrap around
        //if(ra >= (2*M_PI))
        //  ra = ra - (2*M_PI);

        // convert to degrees
        spherData[i+0] = ra * 180 / M_PI;
        spherData[i+1] = dec * 180 / M_PI;
        spherData[i+2] = r;

        double raInt;
        double raDecim = modf(spherData[i+0], &raInt);
        if(raDecim < minRA)
          minRA = raDecim;

        double decInt;
        double decDecim = modf(spherData[i+1], &decInt);
        if(decDecim < minDec)
          minDec = decDecim;
    }

    double resDec;
    double resRA;
    //string minThetaStr = std::to_string(minTheta);
    string minDecStr = std::to_string(minDec);
    for(int i = 0; i < strlen(minDecStr.c_str()); i += 1)
    {
      char c = minDecStr[i];
      if(isdigit(c))
        minDecStr[i] = '0';
    }
    minDecStr[strlen(minDecStr.c_str())-1] = '1';
    resDec = std::stod(minDecStr);

    //string minPhiStr = std::to_string(minPhi);
    string minRaStr = std::to_string(minRA);
    for(int i = 0; i < strlen(minRaStr.c_str()); i += 1)
    {
      char c = minRaStr[i];
      if(isdigit(c))
        minRaStr[i] = '0';
    }
    minRaStr[strlen(minRaStr.c_str())-1] = '1';
    resRA = std::stod(minRaStr);

    std::cout << minDecStr << " = " << resDec << "\n";
    std::cout << minRaStr << " = " << resRA << "\n";

    if(resRA < .01)
      resRA = .01;

    if(resDec < .01)
      resDec = .01;

    inputMatrixData* mat = new inputMatrixData(resRA, resDec, m_fileDataType);
    m_cols = 360/resRA;
    m_rows = 180/resDec;

    mat->initialize();
    mat->RARes(resRA);
    mat->DecRes(resDec);

    for(int i = 0; i < dims1[0] * dims1[1]; i += 3)
    {
      double ra  = spherData[i+0];
      double dec = spherData[i+1];

      long c = ra / resRA;
      long r = dec/resDec;

      //std::cout << "Orig X: " << coorData[i+0] << " Orig Y: " << coorData[i+1]
      //          << "Shift X: " << shiftedData[i+0] << "Shifted Y: " << shiftedData[i+1]
      //          << "COL DEG: " << ra << " COL IND: " << c
      //          << " ROW DEG: " << dec << " ROW IND: " << r << "\n";

      //printf("%s: %010.5f\t%s: %010.5f\t\n", "Orig  X", coorData[i+0],    "Orig  Y", coorData[i+1]);
      //printf("%s: %010.5f\t%s: %010.5f\t\n", "Wrap  X", wrappedData[i+0], "Wrap  Y", wrappedData[i+1]);
      //printf("%s: %010.5f\t%s: %010.5f\t\n", "Shift X", shiftedData[i+0], "Shift Y", shiftedData[i+1]);
      //printf("%s: %010.5f\t%s: %010.5f\t\n", "Col Deg", spherData[i+0],   "Row Deg", spherData[i+1]);
      //printf("\n");

      // this maps to the same point a lot of times causing the rest of the graph to get shifted to all blue
      //(*mat)[c][r] += 1;
      (*mat)[c][r] = 1;
    }

    return mat;
  }
  catch (H5::Exception& err)
  {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    return 0;
  }

  return 0;
}

vectorData<int> *HDF5Manager::getVectorI()
{
  vectorData<int> *i_vec;
  std::string dataSetName = "OCCUPANCY";
  int sides = 0, layout = 0, scheme = 0;
  double minValue = 0, maxValue = 0;
  unsigned long long int numOps, updateUnit, currOp;

  char** infoData;
  hsize_t* infoDims;
  try
  {
    currInfoGroup = new H5::Group(m_ptr->openGroup("Occupancy"));
    currInfoDataSet = new H5::DataSet(currInfoGroup->openDataSet("OCCUPANCY"));
    currInfoDataSpace = new H5::DataSpace(currInfoDataSet->getSpace());

    int numInfoDims = currInfoDataSpace->getSimpleExtentNdims();
    infoDims = new hsize_t[numInfoDims];

    currInfoDataSpace->getSimpleExtentDims(infoDims, NULL);

    infoData = new char*[infoDims[0] * infoDims[1]];
    currDataDataSet->read(infoData, *H5String, *currInfoDataSpace);
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    return 0;
  }

  sides    = atoi(infoData[infoDims[1] + 0]);
  layout   = atoi(infoData[infoDims[1] + 1]);
  scheme   = atoi(infoData[infoDims[1] + 2]);
  minValue = atof(infoData[infoDims[1] + 3]);
  maxValue = atof(infoData[infoDims[1] + 4]);
  //sides = atoi(infoData[1][0]);
  //layout = atoi(infoData[1][1]);
  //scheme = atoi(infoData[1][2]);
  //minValue = atoi(infoData[1][3]);
  //maxValue = atoi(infoData[1][4]);

  int* data;
  hsize_t* dataDims;
  try
  {
    currDataGroup = new H5::Group(m_ptr->openGroup("Occupancy"));
    currDataDataSet = new H5::DataSet(currDataGroup->openDataSet("OCCUPANCY"));
    currDataDataSpace = new H5::DataSpace(currDataDataSet->getSpace());

    int numDataDims = currDataDataSpace->getSimpleExtentNdims();
    dataDims = new hsize_t[numDataDims];

    currDataDataSpace->getSimpleExtentDims(dataDims, NULL);
    data = new int[dataDims[0]];
    m_rows = dataDims[0];

    currDataDataSet->read(data, *H5Int32, *currDataDataSpace);
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  i_vec = new vectorData<int>(m_rows, m_fileDataType);
  i_vec->initialize();
  i_vec->sides(sides);
  i_vec->maxYIndex(maxValue);
  i_vec->minYIndex(minValue);
  i_vec->layout(static_cast<LAYOUT>(layout));
  i_vec->pixelScheme(static_cast<PIXELSCHEME>(scheme));

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  for (int row = 0; row < m_rows; ++row) {
    (*i_vec)[row] = data[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }

  return i_vec;
}

vectorData<double> *HDF5Manager::getVectorD()
{
  vectorData<double> *d_vec;
  int layout = 0, scheme = 0, trans = 0;
  int sides = 0, maxIndex = 0, minIndex = 0, mask = 0;
  std::string dataSetName = "";
  double minValue = 0, maxValue = 0;
  unsigned long long int numOps, updateUnit, currOp;

  switch (m_fileDataType)
  {
    case fileType::PixelizedData:
      dataSetName = dataTypeNames[static_cast<int>(fileType::PixelizedData)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("DATA"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("DATA"));
      //hduName = "PIXEL_DATA";
      break;
    case fileType::PixelizedWeights:
      dataSetName = dataTypeNames[static_cast<int>(fileType::PixelizedWeights)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTS"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTS"));
      //hduName = "PIXEL_MASK";
      break;
    case fileType::WeightedPixel:
      dataSetName = dataTypeNames[static_cast<int>(fileType::WeightedPixel)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      //hduName = "PIXEL_DATA";
      break;
    case fileType::PixelizedNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::PixelizedNoise)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("NOISE"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("NOISE"));
      //hduName = "PIXEL_NOISE";
      break;
    case fileType::PixelizedWeightedNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::PixelizedWeightedNoise)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      break;
    case fileType::PixelizedFilter:
      dataSetName = dataTypeNames[static_cast<int>(fileType::PixelizedFilter)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("FILTER"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("FILTER"));
      //hduName = "PIXEL_FILTER";
      break;
    case fileType::PixelizedBeam:
      dataSetName = dataTypeNames[static_cast<int>(fileType::PixelizedBeam)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("BEAM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("BEAM"));
      //hduName = "PIXEL_BEAM";
      break;
    case fileType::InverseData:
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseData)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("DATA"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("DATA"));
      //hduName = "INVERSE_DATA";
      break;
    case fileType::InverseWeights:
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseWeights)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTS"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTS"));
      //hduName = "INVERSE_MASK";
      break;
    case fileType::WeightedInverse:
      dataSetName = dataTypeNames[static_cast<int>(fileType::WeightedInverse)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      //hduName = "PIXEL_DATA";
      break;
    case fileType::InverseNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseNoise)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("NOISE"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("NOISE"));
      //hduName = "INVERSE_NOISE";
      break;
    case fileType::InverseWeightedNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseWeightedNoise)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      break;
    case fileType::InverseFilter:
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseFilter)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("FILTER"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("FILTER"));
      //hduName = "INVERSE_FILTER";
      break;
    case fileType::InverseBeam:
      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseBeam)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("BEAM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("BEAM"));
      //hduName = "INVERSE_BEAM";
      break;
    case fileType::TransformedData:
      dataSetName = dataTypeNames[static_cast<int>(fileType::TransformedData)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("DATA"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("DATA"));
      //hduName = "TRANSFORMED_DATA";
      break;
    case fileType::TransformedWeights:
      dataSetName = dataTypeNames[static_cast<int>(fileType::TransformedWeights)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTS"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTS"));
      //hduName = "TRANSFORMED_MASK";
      break;
    case fileType::WeightedTransform:
      dataSetName = dataTypeNames[static_cast<int>(fileType::WeightedTransform)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      //hduName = "PIXEL_DATA";
      break;
    case fileType::TransformedNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::TransformedNoise)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("NOISE"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("NOISE"));
      //hduName = "TRANSFORMED_NOISE";
      break;
    case fileType::TransformedWeightedNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::TransformedWeightedNoise)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      //hduName = "PIXEL_DATA";
      break;
    case fileType::TransformedFilter:
      dataSetName = dataTypeNames[static_cast<int>(fileType::TransformedFilter)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("FILTER"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("FILTER"));
      //hduName = "TRANSFORMED_FILTER";
      break;
    case fileType::TransformedBeam:
      dataSetName = dataTypeNames[static_cast<int>(fileType::TransformedBeam)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("BEAM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("BEAM"));
      //hduName = "TRANSFORMED_BEAM";
      break;
    /*
    case fileType::SpectralData:
      dataSetName = dataTypeNames[static_cast<int>(fileType::SpectralData)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      //hduName = "PSEUDO-SPECTRAL_DATA";
      break;
    */
    case fileType::EnsembleAveragedNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::EnsembleAveragedNoise)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      //hduName = "TRANSFORMED_BEAM";
      break;
    case fileType::EnsembleAveragedSpectrum:
      dataSetName = dataTypeNames[static_cast<int>(fileType::EnsembleAveragedSpectrum)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      //hduName = "TRANSFORMED_BEAM";
      break;
    case fileType::BinnedSpectrum:
      dataSetName = dataTypeNames[static_cast<int>(fileType::BinnedSpectrum)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      //hduName = "TRANSFORMED_BEAM";
      break;
    case fileType::EnsembleAveragedBinnedSpectrum:
      dataSetName = dataTypeNames[static_cast<int>(fileType::EnsembleAveragedBinnedSpectrum)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));
      //hduName = "TRANSFORMED_BEAM";
      break;

  }

  char** infoData;
  hsize_t* infoDims;
  try
  {
    currInfoDataSet = new H5::DataSet(currInfoGroup->openDataSet(dataSetName));
    currInfoDataSpace = new H5::DataSpace(currInfoDataSet->getSpace());

    int numInfoDims = currInfoDataSpace->getSimpleExtentNdims();
    infoDims = new hsize_t[numInfoDims];

    currInfoDataSpace->getSimpleExtentDims(infoDims, NULL);

    infoData = new char*[infoDims[0] * infoDims[1]];
    currInfoDataSet->read(infoData, *H5String, *currInfoDataSpace);
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    return 0;
  }

  switch (m_fileDataType)
  {
      case fileType::PixelizedData:
      case fileType::PixelizedWeights:
      case fileType::WeightedPixel:
      case fileType::PixelizedNoise:
      case fileType::PixelizedWeightedNoise:
      case fileType::PixelizedFilter:
      case fileType::PixelizedBeam:
      case fileType::InverseData:
      case fileType::InverseWeights:
      case fileType::WeightedInverse:
      case fileType::InverseNoise:
      case fileType::InverseWeightedNoise:
      case fileType::InverseFilter:
      case fileType::InverseBeam:
        sides  = atoi(infoData[infoDims[1] + 0]);
        layout = atoi(infoData[infoDims[1] + 1]);
        scheme = atoi(infoData[infoDims[1] + 2]);

        //sides = atoi(infoData[1][0]);
        //layout = atoi(infoData[1][1]);
        //scheme = atoi(infoData[1][2]);
        break;
      case fileType::TransformedData:
      case fileType::TransformedWeights:
      case fileType::WeightedTransform:
      case fileType::TransformedNoise:
      case fileType::TransformedWeightedNoise:
      case fileType::TransformedFilter:
      case fileType::TransformedBeam:
        sides  = atoi(infoData[infoDims[1] + 0]);
        layout = atoi(infoData[infoDims[1] + 1]);
        scheme = atoi(infoData[infoDims[1] + 2]);
        trans    = atoi(infoData[infoDims[1] + 3]);
        minIndex = atoi(infoData[infoDims[1] + 4]);
        maxIndex = atoi(infoData[infoDims[1] + 5]);
        //trans = atoi(infoData[1][0]);
        //minIndex = atoi(infoData[1][1]);
        //maxIndex = atoi(infoData[1][2]);
        break;
      //case fileType::SpectralData:
      case fileType::EnsembleAveragedNoise:
      case fileType::EnsembleAveragedSpectrum:
      case fileType::BinnedSpectrum:
      case fileType::EnsembleAveragedBinnedSpectrum:
        minIndex = atoi(infoData[infoDims[1] + 0]);
        maxIndex = atoi(infoData[infoDims[1] + 1]);
        minValue = atof(infoData[infoDims[1] + 2]);
        maxValue = atof(infoData[infoDims[1] + 3]);
        mask     = atoi(infoData[infoDims[1] + 4]);
        //minIndex = atoi(infoData[1][0]);
        //maxIndex = atoi(infoData[1][1]);
        //minValue = atoi(infoData[1][2]);
        //maxValue = atoi(infoData[1][3]);
        //mask     = atoi(infoData[1][4]);
        break;
  }

  double* data;
  hsize_t* dataDims;
  try
  {
    currDataDataSet = new H5::DataSet(currDataGroup->openDataSet(dataSetName));
    currDataDataSpace = new H5::DataSpace(currDataDataSet->getSpace());

    int numDataDims = currDataDataSpace->getSimpleExtentNdims();
    dataDims = new hsize_t[numDataDims];

    currDataDataSpace->getSimpleExtentDims(dataDims, NULL);

    data = new double[dataDims[0]];
    m_rows = dataDims[0];

    currDataDataSet->read(data, *H5Double, *currDataDataSpace);
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  d_vec = new vectorData<double>(m_rows,m_fileDataType);
  d_vec->initialize();
  d_vec->sides(sides);
  d_vec->maxYIndex(maxIndex);
  d_vec->minYIndex(minIndex);
  d_vec->maxValue(maxValue);
  d_vec->minValue(minValue);
  d_vec->mask(mask);

  if(layout)
    d_vec->layout(static_cast<LAYOUT>(layout));
  else
    d_vec->layout(Unordered);

  if (scheme)
  {
    d_vec->pixelScheme(static_cast<PIXELSCHEME>(scheme));
    d_vec->numberOfPixels(12 * sides * sides);

    if(!s_association->exists(dataEngines::Pixelization))
    {
      s_association->addEngine(dataEngines::Pixelization, PIXELSCHEME::HealPIX);
      s_association->pixelizationEngine()->pixelLayout(d_vec->layout());
      s_association->pixelizationEngine()->pixelizerScheme(d_vec->pixelScheme());
      s_association->pixelizationEngine()->scale(sides);
    }
  }
  else
  {
    d_vec->pixelScheme(NotPixelized);
    d_vec->numberOfPixels(0);
  }

  if (trans)
  {
    d_vec->transformerScheme(static_cast<TRANSFORMERSCHEME>(trans));

    if(!s_association->exists(dataEngines::Transformation))
    {
      s_association->addEngine(dataEngines::Transformation, TRANSFORMERSCHEME::Rsht);
      s_association->transformationEngine()->transformerScheme(d_vec->transformerScheme());
      s_association->transformationEngine()->minIndex(d_vec->minYIndex());
      s_association->transformationEngine()->maxIndex(d_vec->maxYIndex());
    }
  }
  else
    d_vec->transformerScheme(NotTransformed);

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  for (int row = 0; row < m_rows; ++row) {
    (*d_vec)[row] = data[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }

  delete[] infoData;
  delete[] data;

  return d_vec;
}

matrixData<double> *HDF5Manager::getMatrixD()
{
  matrixData<double> *d_mat;
  std::string dataSetName = "";
  int dataCols = 0, dataRows = 0;
  double ra_res = 0, dec_res = 0;
  unsigned long long int numOps, updateUnit, currOp;

  // set appropriate hdu name to identify extension
  switch (m_fileDataType)
  {
    case fileType::InputData:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("DATA"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("DATA"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::InputData)];
      //dataSetName = "RAW_DATA";
      break;
    case fileType::InputWeights:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTS"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTS"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::InputWeights)];
      //dataSetName = "RAW_MASK";
      break;
    case fileType::WeightedData:
      dataSetName = dataTypeNames[static_cast<int>(fileType::WeightedData)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      break;
    case fileType::InputNoise:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("NOISE"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("NOISE"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::InputNoise)];
      //dataSetName = "RAW_NOISE";
      break;
    case fileType::InputWeightedNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::InputWeightedNoise)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      //hduName = "PIXEL_DATA";
      break;
    case fileType::InputFilter:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("FILTER"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("FILTER"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::InputFilter)];
      //dataSetName = "RAW_FILTER";
      break;
    case fileType::InputBeam:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("BEAM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("BEAM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::InputBeam)];
      //dataSetName = "RAW_BEAM";
      break;

    case fileType::EnsembleIterationNoise:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::EnsembleIterationNoise)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::EnsembleIterationSpectrum:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::EnsembleIterationSpectrum)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::EnsembleIterationBinnedSpectrum:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::EnsembleIterationBinnedSpectrum)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::ModeModeMatrix:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::ModeModeMatrix)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::InstrumentEffectsMatrix:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::InstrumentEffectsMatrix)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::BinningMatrix:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::BinningMatrix)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::UnbinningMatrix:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::UnbinningMatrix)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::BinnedInstrumentEffectsMatrix:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::BinnedInstrumentEffectsMatrix)];
      //dataSetName = "RAW_BEAM";
      break;
    case fileType::InverseBinnedInstrumentMatrix:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseBinnedInstrumentMatrix)];
      //dataSetName = "RAW_BEAM";
      break;
    /*
    case fileType::BinCouplingMatrix:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::BinCouplingMatrix)];
      //dataSetName = "BIN_COUPLING_MATRIX";
      break;
    case fileType::ModeCouplingMatrix:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::ModeCouplingMatrix)];
      //dataSetName = "MODE_COUPLING_MATRIX";
      break;
    case fileType::InverseBinMatrix:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseBinMatrix)];
      //dataSetName = "INVERSE_BIN_COUPLING_MATRIX";
      break;
    case fileType::InverseModeMatrix:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("SPECTRUM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("SPECTRUM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::InverseModeMatrix)];
      //dataSetName = "INVERSE_MODE_COUPLING_MATRIX";
      break;
    */
  }

  char** infoData;
  hsize_t* infoDims;
  try
  {
    currInfoDataSet = new H5::DataSet(currInfoGroup->openDataSet(dataSetName));
    currInfoDataSpace = new H5::DataSpace(currInfoDataSet->getSpace());

    int numInfoDims = currInfoDataSpace->getSimpleExtentNdims();
    infoDims = new hsize_t[numInfoDims];
    currInfoDataSpace->getSimpleExtentDims(infoDims, NULL);

    infoData = new char*[infoDims[0] * infoDims[1]];
    currInfoDataSet->read(infoData, *H5String, *currInfoDataSpace);
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    std::cout << err.getCDetailMsg() << "\n";
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    delete d_mat;
    return 0;
  }

  ra_res  = atof(infoData[infoDims[1] + 0]);
  dec_res = atof(infoData[infoDims[1] + 1]);

  double* data;
  hsize_t* dataDims;
  try
  {
    currDataDataSet = new H5::DataSet(currDataGroup->openDataSet(dataSetName));
    currDataDataSpace = new H5::DataSpace(currDataDataSet->getSpace());

    int numDataDims = currDataDataSpace->getSimpleExtentNdims();
    dataDims = new hsize_t[numDataDims];
    currDataDataSpace->getSimpleExtentDims(dataDims, NULL);

    m_rows = dataDims[0];
    m_cols = dataDims[1];

    data = new double[dataDims[0] * dataDims[1]];
    for(int i = 0; i < dataDims[0] * dataDims[1]; i += 1)
      data[i] = 0;

    currDataDataSet->read(data, *H5Double, *currDataDataSpace);
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    delete d_mat;
    return 0;
  }

  // create data structure for storage
  d_mat = new matrixData<double>(m_cols,m_rows,m_fileDataType);
  d_mat->initialize();

  d_mat->RARes(ra_res);
  d_mat->DecRes(dec_res);

  double minValue = 100;
  double maxValue = 0;

  for(int r = 0; r < dataDims[0]; r += 1)
  {
    for(int c = 0; c < dataDims[1]; c += 1)
      (*d_mat)[c][r] = data[r * m_cols + c];
  }

  delete[] infoData;
  delete[] data;

  return d_mat;
}

cubeData<std::complex<double> > *HDF5Manager::getCubeCD()
{
  cubeData<std::complex<double> > *dc_cube;
  std::vector<std::vector<std::vector<complex<double>>>> cubeDataAccess;
  std::string dataSetName = "";
  int polarization, index; //, offset;
  unsigned long long int numOps, updateUnit, currOp;
  int slice = 0, col = 0, row = 0;
  int dataCols = 0, dataRows = 0, dataSlices = 0;

  switch (m_fileDataType)
  {
    case fileType::AlmData:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("DATA"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("DATA"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::AlmData)];
      //dataSetName = "ALM_DATA";
      break;
    case fileType::AlmWeights:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTS"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTS"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::AlmWeights)];
      //dataSetName = "ALM_MASK";
      break;
    case fileType::WeightedAlm:
      dataSetName = dataTypeNames[static_cast<int>(fileType::WeightedAlm)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      break;
    case fileType::AlmNoise:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("NOISE"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("NOISE"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::AlmNoise)];
      //dataSetName = "ALM_NOISE";
      break;
    case fileType::AlmWeightedNoise:
      dataSetName = dataTypeNames[static_cast<int>(fileType::AlmWeightedNoise)];

      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("WEIGHTED"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("WEIGHTED"));
      //hduName = "PIXEL_DATA";
      break;
    case fileType::AlmFilter:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("FILTER"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("FILTER"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::AlmFilter)];
      //dataSetName = "ALM_FILTER";
      break;
    case fileType::AlmBeam:
      infoGroup = new H5::Group(m_ptr->openGroup(infoGroupName));
      currInfoGroup = new H5::Group(infoGroup->openGroup("BEAM"));

      dataGroup = new H5::Group(m_ptr->openGroup(dataGroupName));
      currDataGroup = new H5::Group(dataGroup->openGroup("BEAM"));

      dataSetName = dataTypeNames[static_cast<int>(fileType::AlmBeam)];
      //dataSetName = "ALM_BEAM";
      break;
  }

  char** infoData;
  hsize_t* infoDims;
  try
  {
    currInfoDataSet = new H5::DataSet(currInfoGroup->openDataSet(dataSetName));
    currInfoDataSpace = new H5::DataSpace(currInfoDataSet->getSpace());

    int numInfoDims = currInfoDataSpace->getSimpleExtentNdims();
    infoDims = new hsize_t[numInfoDims];
    currInfoDataSpace->getSimpleExtentDims(infoDims, NULL);

    infoData = new char*[infoDims[0] * infoDims[1]];
    currInfoDataSet->read(infoData, *H5String, *currInfoDataSpace);
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  //  const char* infoData[6][6] = { {"POLARIZATION",       "INDEX",       "NSIDES",     "PIXSCHEME",     "PIXLAYOUT",   "TRANSFORMERSCHEME"},


  polarization = atoi(infoData[infoDims[1] + 0]);
  index        = atoi(infoData[infoDims[1] + 1]);

  int sides    = atoi(infoData[infoDims[1] + 2]);
  string scheme = infoData[infoDims[1] + 3];
  string layout = infoData[infoDims[1] + 4];

  string trans  = infoData[infoDims[1] + 5];
  int minIndex  = atoi(infoData[infoDims[1] + 6]);
  int maxIndex  = atoi(infoData[infoDims[1] + 7]);

  complex<double>* data;
  hsize_t* dataDims;
  try
  {
    currDataDataSet = new H5::DataSet(currDataGroup->openDataSet(dataSetName));
    currDataDataSpace = new H5::DataSpace(currDataDataSet->getSpace());

    int numDataDims = currDataDataSpace->getSimpleExtentNdims();
    dataDims = new hsize_t[numDataDims];
    currDataDataSpace->getSimpleExtentDims(dataDims, NULL);

    m_slices = dataDims[0];
    m_rows = dataDims[1];
    m_cols = dataDims[2];

    data = new complex<double>[m_slices * m_rows * m_cols];
    currDataDataSet->read(data, *H5Complex, *currDataDataSpace);
  }
  catch (H5::Exception& err) {
    snprintf(hdf5_err,HDF5_ERR_LEN,"%s",err.getCDetailMsg());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(hdf5_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  dc_cube = new cubeData<std::complex<double> >(m_cols,m_rows,m_slices,m_fileDataType);
  dc_cube->initialize();
  cubeDataAccess = dc_cube->rwAccess();

  dc_cube->polarization(polarization);
  dc_cube->index(index);

  dc_cube->sides(sides);
  dc_cube->pixelScheme(scheme == "HealPIX"? HealPIX:NotPixelized);
  dc_cube->layout(layout == "Ring"?Ring:Nest);

  dc_cube->transformerScheme(trans == "Rsht"?Rsht:NotTransformed);
  dc_cube->transMinIndex(minIndex);
  dc_cube->transMaxIndex(maxIndex);

  if(scheme == "HealPIX")
  {
    if(!s_association->exists(dataEngines::Pixelization))
    {
      s_association->addEngine(dataEngines::Pixelization, PIXELSCHEME::HealPIX);
      s_association->pixelizationEngine()->pixelLayout(dc_cube->layout());
      s_association->pixelizationEngine()->pixelizerScheme(dc_cube->pixelScheme());
      s_association->pixelizationEngine()->scale(sides);
    }
  }

  if (trans == "Rsht")
  {
    if(!s_association->exists(dataEngines::Transformation))
    {
      s_association->addEngine(dataEngines::Transformation, TRANSFORMERSCHEME::Rsht);
      s_association->transformationEngine()->transformerScheme(dc_cube->transformerScheme());
      s_association->transformationEngine()->minIndex(dc_cube->transMinIndex());
      s_association->transformationEngine()->maxIndex(dc_cube->transMaxIndex());
    }
  }

  numOps = m_slices;
  updateUnit = numOps / 100;
  if(updateUnit < 1)
    updateUnit = 1;
  currOp = 0;

  for (int slice = 0; slice < m_slices; ++slice)
    for (int col = 0; col < m_cols; ++col)
      for (int row = 0; row < m_rows; ++row)
        (*dc_cube)[slice][col][row] = data[slice * m_rows * m_cols + row * m_cols + col];

  delete[] infoData;
  delete[] data;

  return dc_cube;
}

dataMap* HDF5Manager::getMap() {
  return 0;
}

dataSpectrum* HDF5Manager::getSpectrum() {
  return 0;
}

bool HDF5Manager::saveMap(dataMap* map) {
  return true;
}

bool HDF5Manager::saveSpectrum(dataSpectrum* spect) {
  return true;
}
