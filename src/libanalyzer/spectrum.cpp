/****************************************************************************
                              \spectrum.cpp
Description:\brief (put short description here)

Begin    : Fri Jul 1 2005
Copyright: (C) 2005 by Daniel Suson
email    : daniel.suson@tamuk.edu

-----------------------------------------------------------------------------
                                Change Log
Date       Name                Description

-----------------------------------------------------------------------------

This program was developed at Texas A&M University-Kingsville by Daniel Suson.
It is free software; you may redistribute and/or modify it under the terms
of the GNU General License as published by the Free Software Foundation;
either version 2 of the License. or (at your option) any later version.

This software evolved from work that was done by Eric Hivon at the
California Institute of Technology on the MASTER algorithm (Hivon, E.,
et al., ApJ, vol 567, p 2).  It adapts or interfaces with these packages:

HealPix         (http://www.eso.org/science/healpix/)
FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)

Any publications or presentations that use results generated by this program
must reference the fact that it was developed at Texas A&M
University-Kingsville by Daniel Suson
***************************************************************************/
#include <math.h>
#include <gsl/gsl_sf_coupling.h>
#include <gsl/gsl_permutation.h>
#include <gsl/gsl_linalg.h>
#include <gsl/gsl_rng.h>
#include <healpix_cxx/arr.h>
#include <healpix_cxx/xcomplex.h>
#include <healpix_cxx/planck_rng.h>
#include <healpix_cxx/powspec.h>
#include <healpix_cxx/alm.h>
#include <healpix_cxx/alm_powspec_tools.h>
#include <healpix_cxx/healpix_map.h>

#include "spectrum.h"

#include "rsht.h"
#include <healpix_cxx/alm_healpix_tools.h>

Spectrum::Spectrum() {
  m_configured = false;
  m_active = false;
  m_minIndex  = 0;
  m_maxIndex  = 1;
  m_minBin    = 0;
  m_maxBin    = 1;
  m_indices   = 1;
  m_maskIndex = 0;
  m_ensIter   = 1;
  m_lowBinL   = 0;
  m_binning = true;
  m_invert  = true;
}

Spectrum::Spectrum(Spectrum* from) {
  m_configured = from->configured();
  m_active = from->active();
  m_minIndex  = from->minIndex();
  m_maxIndex  = from->maxIndex();
  m_minBin    = from->minBin();
  m_maxBin    = from->maxBin();
  m_indices   = from->indices();
  m_maskIndex = from->maskIndex();
  m_lowBinL   = from->lowBinL();
  m_binning = from->binning();
  m_invert  = from->invert();
  m_ensIter = from->ensembleIterations();
}

Spectrum::~Spectrum() {
  clear();
}

void Spectrum::initialize()
{
  if(m_maxIndex % m_lPerBin != 0)
    throw dataMismatchError;

  m_numBins = m_maxIndex / m_lPerBin;

  m_ModeModeMatrix                 = gsl_matrix_calloc(m_maxIndex, m_maxIndex); // mll
  m_InverseModeModeMatrix          = gsl_matrix_calloc(m_maxIndex, m_maxIndex); // mll-1
  m_InstrumentEffectsMatrix        = gsl_matrix_calloc(m_maxIndex, m_maxIndex); // kll = mll fl bl2
  m_InverseInstrumentEffectsMatrix = gsl_matrix_calloc(m_maxIndex, m_maxIndex); // kll-1
  m_BinningMatrix                  = gsl_matrix_calloc(m_numBins,  m_maxIndex); // Pbl
  m_InverseBinningMatrix           = gsl_matrix_calloc(m_numBins,  m_maxIndex); // Pbl-1
  m_UnbinningMatrix                = gsl_matrix_calloc(m_maxIndex, m_numBins);  // Qlb
  m_InverseUnbinningMatrix         = gsl_matrix_calloc(m_maxIndex, m_numBins);  // Qlb-1
  m_BinnedInstrumentEffectsMatrix  = gsl_matrix_calloc(m_numBins,  m_numBins); // kbb = Pbl Kll Qlb
  m_InverseBinnedInstrumentMatrix  = gsl_matrix_calloc(m_numBins,  m_numBins); // kbb -1

  m_configured = true;
}

// copy our matrixData to a gsl_matrix
void Spectrum::loadIntoGslMatrix(association *asc, FILETYPE ft)
{
  matrixData<double>* matData = 0;
  gsl_matrix*         gslData = 0;

  switch(ft)
  {
    case fileType::ModeModeMatrix:
      matData = asc->ModeModeMatrix();
      gslData = m_ModeModeMatrix;
      break;
    case fileType::BinningMatrix:
      matData = asc->BinningMatrix();
      gslData = m_BinningMatrix;
      break;
    case fileType::UnbinningMatrix:
      matData = asc->UnbinningMatrix();
      gslData = m_UnbinningMatrix;
      break;
    case fileType::InstrumentEffectsMatrix:
      matData = asc->InstrumentEffectsMatrix();
      gslData = m_InstrumentEffectsMatrix;
      break;
    case fileType::BinnedInstrumentEffectsMatrix:
      matData = asc->BinnedInstrumentEffectsMatrix();
      gslData = m_BinnedInstrumentEffectsMatrix;
      break;
    case fileType::InverseBinnedInstrumentMatrix:
      matData = asc->InverseBinnedInstrumentMatrix();
      gslData = m_InverseBinnedInstrumentMatrix;
      break;
    default:
      return;
  }

  for (int r = 0; r < gslData->size1; r++)
    for (int c = 0; c < gslData->size2; c++)
      gsl_matrix_set(gslData, r, c, (*matData)[c][r]);
}

// copy a gsl_matrix to our matrixData
void Spectrum::loadIntoMatrixData(association* asc, FILETYPE ft)
{
  matrixData<double>* matData = 0;
  gsl_matrix*         gslData = 0;

  switch(ft)
  {
    case fileType::ModeModeMatrix:
      matData = asc->ModeModeMatrix();
      gslData = m_ModeModeMatrix;
      break;
    case fileType::BinningMatrix:
      matData = asc->BinningMatrix();
      gslData = m_BinningMatrix;
      break;
    case fileType::UnbinningMatrix:
      matData = asc->UnbinningMatrix();
      gslData = m_UnbinningMatrix;
      break;
    case fileType::InstrumentEffectsMatrix:
      matData = asc->InstrumentEffectsMatrix();
      gslData = m_InstrumentEffectsMatrix;
      break;
    case fileType::BinnedInstrumentEffectsMatrix:
      matData = asc->BinnedInstrumentEffectsMatrix();
      gslData = m_BinnedInstrumentEffectsMatrix;
      break;
    case fileType::InverseBinnedInstrumentMatrix:
      matData = asc->InverseBinnedInstrumentMatrix();
      gslData = m_InverseBinnedInstrumentMatrix;
      break;
    default:
      return;
  }

  for (int r = 0; r < gslData->size1; r++)
    for (int c = 0; c < gslData->size2; c++)
      (*matData)[c][r] = gsl_matrix_get(gslData, r, c);
}

void Spectrum::createModeModeMatrix(association *asc)
{
  long l1, l2, l3;  // individual l values
  double sum_l3;    // sum of l3 contributions
  double cg2;       // Clebsch-Gordan coefficient squared
  double value;     // value stored in mode matrix
  matrixData<double>* modeMatrix = asc->ModeModeMatrix();

  for (l1 = 0; l1 < m_maxIndex; l1++)
  {
    for (l2 = 0; l2 < m_maxIndex; l2++)
    {
      sum_l3 = 0.0;
      for (l3 = 0; l3 < m_maxIndex; l3++)
      {
        cg2     = coupling_3j(l1,l2,l3);
        cg2    *= cg2;
        sum_l3 += (*(asc->transformedWeights()))[l3] * (2 * l3 + 1) * cg2;
      }

      value = (2 * l2 + 1) * sum_l3 / (4 * M_PI);

      gsl_matrix_set(m_ModeModeMatrix, l1, l2, value);

      if (!modeMatrix->initialized())
        modeMatrix->initialize();

      // our matrixes are column row indexing so this is backwards!
      //(*modeMatrix)[l1][l2] = value;
      (*modeMatrix)[l2][l1] = value;
    }
  }
}

void Spectrum::calculateInstrumentEffectsMatrix(association* asc)
{
  matrixData<double>* Mll = asc->ModeModeMatrix();
  vectorData<double>* f   = asc->transformedFilter();
  vectorData<double>* b   = asc->transformedBeam();
  vectorData<double>* b2  = b->elementMult(b);
  vectorData<double>* fb2 = f->elementMult(b2);
  matrixData<double>* Kll = Mll->elementMult(fb2);

  Kll->dataType(fileType::InstrumentEffectsMatrix);
  asc->addData(Kll);
}

void Spectrum::calculateBinningMatrix(association *asc)
{
  matrixData<double>* Pbl = asc->BinningMatrix();
  //gsl_matrix* Pbl = m_BinningMatrix;

  //if(Pbl->size1 != m_numBins)
  if(Pbl->rows() != m_numBins)
    throw dataMismatchError;

  for(int b = 0; b < m_numBins; b += 1)
  {
    int lBLow  = b * m_lPerBin;
    int lB1Low = lBLow + m_lPerBin;

    for(int l = 0; l < m_maxIndex; l += 1)
    {
      if(2 <= l && lBLow <= l && l < lB1Low)
      {
        // our matrixes are column then row indexing
        (*Pbl)[l][b] = (l * (l+1))/(2*M_PI*m_lPerBin);
        //gsl_matrix_set(Pbl, b, l, (l * (l+1))/(2*M_PI * m_lPerBin));
      }
    }
  }
}

void Spectrum::calculateUnbinningMatrix(association* asc)
{
  matrixData<double>* Qlb = asc->UnbinningMatrix();
  //gsl_matrix* Qlb = m_UnbinningMatrix;

  //if(Qlb->size2 != m_numBins)
  if(Qlb->cols() != m_numBins)
    throw dataMismatchError;

  for(int l = 0; l < m_maxIndex; l += 1)
  {
    for(int b = 0; b < m_numBins; b += 1)
    {
      int lBLow  = b * m_lPerBin;
      int lB1Low = lBLow + m_lPerBin;

      if(2 <= l && lBLow <= l && l < lB1Low)
      {
        // our matrixes are column then row indexing
        (*Qlb)[b][l] = (2*M_PI)/(l * (l+1));

        //gsl_matrix_set(Qlb, l, b, (2*M_PI)/(l*(l+1)));
      }
    }
  }
}

void Spectrum::calculateBinnedSpectrum(association* asc)
{
  matrixData<double>* inverseBinInstrEffMat  = asc->InverseBinnedInstrumentMatrix();
  matrixData<double>* binMatrix              = asc->BinningMatrix();
  vectorData<double>* ensSpectrum            = asc->EnsembleAveragedSpectrum();
  vectorData<double>* ensNoise               = asc->EnsembleAveragedNoise();
  vectorData<double>* CN                     = ensSpectrum->elementSub(ensNoise);
  vectorData<double>* PCN                    = binMatrix->matrixMult(CN);
  vectorData<double>* KPCN                   = inverseBinInstrEffMat->matrixMult(PCN);

  KPCN->dataType(fileType::BinnedSpectrum);
  asc->addData(KPCN);
}

void Spectrum::calculateBinnedInstrumentEffectsMatrix(association* asc)
{
  /*
  matrixData<double>* Pbl = asc->BinningMatrix();
  matrixData<double>* Kll = asc->InstrumentEffectsMatrix();
  matrixData<double>* Qlb = asc->UnbinningMatrix();
  matrixData<double>* KllQlb = Kll->matrixMult(Qlb);
  matrixData<double>* PlbKllQlb = Pbl->matrixMult(KllQlb);

  PlbKllQlb->dataType(fileType::BinnedInstrumentEffectsMatrix);
  asc->addData(PlbKllQlb);
  */

  gsl_matrix* Pbl = m_BinningMatrix;
  gsl_matrix* Kll = m_InstrumentEffectsMatrix;
  gsl_matrix* Qlb = m_UnbinningMatrix;

  gsl_matrix* KllQlb    = gsl_matrix_calloc(m_maxIndex, m_numBins);
  gsl_matrix* PblKllQlb = m_BinnedInstrumentEffectsMatrix;

  gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1.0, Kll, Qlb,    0.0, KllQlb);
  gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1.0, Pbl, KllQlb, 0.0, PblKllQlb);

  loadIntoMatrixData(asc, fileType::BinnedInstrumentEffectsMatrix);
}

void Spectrum::invertMatrix(association* asc, FILETYPE ft)
{
  int gslErrorNumber    = 0;
  gsl_permutation *p    = 0;
  gsl_matrix* gslOrig   = 0;
  gsl_matrix* gslOrigLU = 0;
  gsl_matrix* gslInvert = 0;

  switch(ft)
  {
    case fileType::ModeModeMatrix:
      gslOrig = m_ModeModeMatrix;
      gslInvert = m_InverseModeModeMatrix;
      break;
    case fileType::BinningMatrix:
      gslOrig = m_BinningMatrix;
      gslInvert = m_InverseBinningMatrix;
      break;
    case fileType::UnbinningMatrix:
      gslOrig = m_UnbinningMatrix;
      gslInvert = m_InverseUnbinningMatrix;
      break;
    case fileType::InstrumentEffectsMatrix:
      gslOrig = m_InstrumentEffectsMatrix;
      gslInvert = m_InverseInstrumentEffectsMatrix;
      break;
    case fileType::BinnedInstrumentEffectsMatrix:
      gslOrig = m_BinnedInstrumentEffectsMatrix;
      gslOrigLU = m_BinnedInstrumentEffectsMatrix;
      gslInvert = m_InverseBinnedInstrumentMatrix;
      break;
    default:
      return;
  }

  int gslOrigDet = gsl_linalg_LU_det(gslOrig, gslErrorNumber);

  if (gslOrigDet == 0)
  {
    std::cout << "MATRIX ISN'T INVERTABLE\n";
    throw undefinedError;
  }
  else
  {
    p = gsl_permutation_alloc(gslOrigLU->size1);
    gsl_linalg_LU_decomp(gslOrigLU, p, &gslErrorNumber);

    gsl_linalg_LU_invert((const gsl_matrix*)gslOrigLU, (const gsl_permutation*)p, gslInvert);
    gsl_permutation_free(p);
  }
}

void Spectrum::calculateEnsembleAverage(association *asc, FILETYPE ft)
{
  int i = 0;
  int length; //m_maxIndex;
  vectorData<double>* base;
  vectorData<double>* avgData;
  matrixData<double>* iterData;

  switch(ft)
  {
    case fileType::EnsembleAveragedNoise:
      length = m_maxIndex;
      base = asc->weightedTransformedNoise();
      avgData = asc->EnsembleAveragedNoise();
      iterData = asc->EnsembleIterationNoise();
      break;
    case fileType::EnsembleAveragedSpectrum:
      length = m_maxIndex;
      base = asc->weightedTransform();
      avgData = asc->EnsembleAveragedSpectrum();
      iterData = asc->EnsembleIterationSpectrum();
      break;
    case fileType::EnsembleAveragedBinnedSpectrum:
      length = m_numBins;
      base = asc->BinnedSpectrum();
      avgData = asc->EnsembleAveragedBinnedSpectrum();
      iterData = asc->EnsembleIterationBinnedSpectrum();
      break;
    default:
      return;
  }

  // initialize gsl random number generator
  int seed = 1234;
  planck_rng *generator = new planck_rng(seed);

  // set up HealPIX objects
  PowSpec *original = 0, *randomized = 0;
  Alm<xcomplex<double> > *randAlm = 0;

  original = new PowSpec(1,length);
  randomized = new PowSpec(1,length);
  randAlm = new Alm<xcomplex<double> >(length,length);
  for (i = 0; i < length; ++i)
    original->tt(i) = (*base)[i];

  // create randomized alm instances of the psuedo power spectrum //
  for (i = 0; i < m_ensIter; ++i)
  {
    create_alm(*original,*randAlm,*generator);
    extract_powspec(*randAlm,*randomized);

    for (int l = 0; l < length; l += 1)
      (*iterData)[l][i] = randomized->tt(l);
  }

  for(int l = 0; l < length; l += 1)
  {
    double sum = 0;
    for(int iter = 0; iter < m_ensIter; iter += 1)
      sum += (*iterData)[l][iter];

    (*avgData)[l] = sum / m_ensIter;
  }
}

void Spectrum::clear() {
  if (!m_configured)
    return;

  if (m_ModeModeMatrix)
    gsl_matrix_free(m_ModeModeMatrix);

  if (m_InstrumentEffectsMatrix)
    gsl_matrix_free(m_InstrumentEffectsMatrix);

  if (m_BinningMatrix)
    gsl_matrix_free(m_BinningMatrix);

  if (m_UnbinningMatrix)
    gsl_matrix_free(m_UnbinningMatrix);

  if (m_BinnedInstrumentEffectsMatrix)
    gsl_matrix_free(m_BinnedInstrumentEffectsMatrix);

  if (m_InverseModeModeMatrix)
    gsl_matrix_free(m_InverseModeModeMatrix);

  if (m_InverseInstrumentEffectsMatrix)
    gsl_matrix_free(m_InverseInstrumentEffectsMatrix);

  if (m_InverseBinningMatrix)
    gsl_matrix_free(m_InverseBinningMatrix);

  if (m_InverseUnbinningMatrix)
    gsl_matrix_free(m_InverseUnbinningMatrix);

  if (m_InverseBinnedInstrumentMatrix)
    gsl_matrix_free(m_InverseBinnedInstrumentMatrix);


  m_active = false;
  m_configured = false;
}

double Spectrum::gammln(double xx) {
  static double cof[6] = {
    76.18009172947146,
    -86.50532032941677,
    24.01409824083091,
    -1.231739572450155,
    0.1208650973866179e-2,
    -0.5395239384953e-5
  };

  double x, y, tmp, ser;
  int j;
  double result;

  y = x = xx;
  tmp  = x + 5.5;
  tmp -= (x + 0.5) * log(tmp);
  ser  = 1.000000000190015;

  for (j = 0; j <= 5; j++)
    ser += cof[j] / ++y;
  result = -tmp + log(2.506628274631005 * ser / x);

  return result;
}

double Spectrum::factln(int n) {
  static double a[101];

  if (n < 0)
    return -1.0;

  if (n <= 1)
    return 0.0;

  if (n <= 100) {
    if (a[n] == 0)
      a[n] = gammln(n + 1.0);
    return a[n];
  }

  return gammln(n + 1.0);
}

double Spectrum::coupling_3j(int l1, int l2, int l3) {
  int L;
  double diff_l1, diff_l2, diff_l3, half_l1, half_l2, half_l3;
  double lnDiff_l1, lnDiff_l2, lnDiff_l3, ln_L,
         lnHalf_L, lnHalf_l1, lnHalf_l2, lnHalf_l3;
  double rootTerm, fract;
  double coefficient;

  L = l1 + l2 + l3;

  if ((L % 2) || (l2 < abs(l1 - l3)) || (l2 > l1 + l3))
    return 0.0;

  diff_l1 = (double)(L - 2.0 * l1);
  diff_l2 = (double)(L - 2.0 * l2);
  diff_l3 = (double)(L - 2.0 * l3);
  half_l1 = (double)(L / 2.0 - l1);
  half_l2 = (double)(L / 2.0 - l2);
  half_l3 = (double)(L / 2.0 - l3);

  lnDiff_l1 = factln((int)diff_l1);
  lnDiff_l2 = factln((int)diff_l2);
  lnDiff_l3 = factln((int)diff_l3);
  ln_L      = factln((int)L + 1);
  lnHalf_L  = factln((int)L / 2);
  lnHalf_l1 = factln((int)half_l1);
  lnHalf_l2 = factln((int)half_l2);
  lnHalf_l3 = factln((int)half_l3);

  rootTerm    = (lnDiff_l1 + lnDiff_l2 + lnDiff_l3 - ln_L) / 2.0;
  fract       = lnHalf_L - lnHalf_l1 - lnHalf_l2 - lnHalf_l3;
  coefficient = exp(rootTerm + fract);

  return coefficient;
}
